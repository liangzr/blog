<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>译-Why Do We Write super(props)?</title>
      <link href="/2018/12/30/fork__why_do_we_write_super/"/>
      <url>/2018/12/30/fork__why_do_we_write_super/</url>
      
        <content type="html"><![CDATA[<p><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">React Hooks</a> 是当下社区的热门，但我却想从 <em>class</em> 组件的一些有趣实现讲起！</p><p>理解这些内容对你如何运用 React 来说并不重要，但如果你喜欢探寻事物动作的原理的话，就很有趣了。</p><hr><p>我写过不计其数的 <code>super(props)</code> :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkbox</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，使用 <a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">class fields proposal</a> 可以让我省去这种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkbox</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 从 0.13 增加对普通 class 的支持开始，就计划要使用这种语法。现在这种定义 <code>constructor</code> 然后调用 <code>super(props)</code> 的做法只是 <code>class field</code> 来临之前的一种替代方案。</p><a id="more"></a><p>但是现在让我们回到这个例子，只使用 ES2015 的特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lass Checkbox extends React.Component &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我们要调用 <code>super</code>？可以省去吗？如果我们不得不调用它，不传 <code>props</code> 会怎么样？除了 <code>props</code> 还需要传递别的参数吗？我们来看一下这个问题。</p><hr><p>在 JavaScript 中, <code>super</code> 指的是父类的 constructor（在我们的例子中，它指的就是 React.Component）</p><p>要注意的是，在 constructor 中，你只能在调用父类的 constructor 之后才能使用 <code>this</code>，JavaScript 不会让你这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkbox</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="comment">// 🔴 Can’t use `this` yet</span></span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// ✅ Now it’s okay though</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个很好的理由说明为什么 JavaScript 强制你在使用 <code>this</code> 之前要执行父类的 constructor，参考下面这个类结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolitePerson</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greetColleagues(); <span class="comment">// 🔴 This is disallowed, read below why</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  greetColleagues() &#123;</span><br><span class="line">    alert(<span class="string">'Good morning folks!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想象一下，如果你在调用 <code>super</code> 之前就调用了 <code>this</code>，一个月之后，我们可能修改了 <code>greetColleagues</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greetColleagues() &#123;</span><br><span class="line">  alert(<span class="string">'Good morning folks!'</span>);</span><br><span class="line">  alert(<span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', nice to meet you!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们忘记了 <code>this.greetColleagues()</code> 是在 <code>super()</code> 之前调用的，这个时候 <code>this.name</code> 还没有被定义！所以像这样的代码就很不好维护。</p><p>为了避开这个陷阱，<strong>JavaScript 强制你如果想要在 constructor 中使用 <code>this</code>，则必须先调用 <code>super</code></strong>，让父类先处理完该做的事情！这个限制也适用于使用类来定义 React 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="comment">// ✅ Okay to use `this` now</span></span><br><span class="line">  <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就只剩下另外一个问题，为什么要传递 <code>props</code> 参数？</p><hr><p>你可能认为向 <code>super</code> 传递 <code>props</code> 是有必要的，以便 <code>React.Component</code> 的 constructor 可以初始化 <code>this.props</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实也差不多，准确地说，这是<a href="https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22" target="_blank" rel="noopener">它的过程</a></p><p>但不知道为什么，即使你没有把 <code>props</code> 参数传递给 <code>super()</code>，你还是可以在 <code>render</code> 和其它方法中访问 <code>this.props</code>。（不信的话可以试试看）</p><p>所以它内部是如何运作的？事实上，React 会在你调用 constructor 之后重新赋值 <code>props</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> YourComponent(props);</span><br><span class="line">instance.props = props;</span><br></pre></td></tr></table></figure><p>所以即使你忘了把 <code>props</code> 传递给 <code>super()</code>，React 也会在之后正确的赋值，这就是原因。</p><p>当 React 支持 class 的时候，并不只是简单的添加了 ES6 的特性，它的目标是尽可能广泛抽象地支持 class。因为不能确定 ClojureScript、CoffeeScript、ES6、Fable、Scala.js、TypeScript 或其它的方式是如何定义一个组件的，所以 React 故意地不关心 <code>super()</code> 方法有没有被调用——尽管这是 ES6 class 规定的</p><p>所以，这是不是就意味着，你可以只写 <code>super()</code> 而不用 <code>super(props)</code> 了？</p><p><strong>恐怕并不是这样，因为它依然令人困惑。</strong> 当然，React 会在 constructor 之后重新赋值 <code>this.props</code>，但是在 constructor 内部调用了 <code>super</code> 之后，<code>this.props</code> 依然是 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside your code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// 😬 We forgot to pass props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props);      <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// 😬 undefined </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在 constructor 中调用的某些方法中遇到了这种问题，就更难定位了。<strong>这就是为什么要强调要坚持<code>super(props)</code>，即使没有严格限制</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props); <span class="comment">// ✅ We passed props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props);      <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以保证 <code>this.props</code> 在 constructor 执行完之前就正确赋值。</p><hr><p>还有最后一个 React 用户可能会困惑的问题。</p><p>你可能注意到了，当你使用 Context API 的时候（无论是旧的 <code>contextTypes</code> 或者在 React 16.6 中新添加的 <code>contextType</code> API），<code>context</code> 是 constructor 的第二个参数。</p><p>所以为什么我们不写成 <code>super(props, context)</code>？确实可以这样写，但是 context 用的相对比较少，所以也不容易碰到这个陷阱。</p><p>如果使用 class fields proposal 的话，这个陷阱就不复存在了。不需要特别地写一个 constructor，所以的变量都可以自动传递。这样也可以在 <code>state = {}</code> 中直接引用 <code>this.props</code> 或 <code>this.context</code> 了。</p><p>当然，使用 React Hooks 的话，我们甚至不需要使用 <code>super</code> 或 <code>this</code>，但这是以后的事儿了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> reprinted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Immutable 数据来优化 React 应用</title>
      <link href="/2018/05/29/optimizing-react-app-with-immutable-data/"/>
      <url>/2018/05/29/optimizing-react-app-with-immutable-data/</url>
      
        <content type="html"><![CDATA[<p>一直以来，Virtual DOM 都是 React 的一大特色，Facebook 宣称 React 借其能很大程度提高 SPA 的性能表现。但这就意味着 React 的性能一定优秀吗，可能并不是，在某些情况下，React 慢的令人抓狂，这时你可能就需要用一些正确的手段来优化它了。</p><h2 id="React-的更新机制"><a href="#React-的更新机制" class="headerlink" title="React 的更新机制"></a>React 的更新机制</h2><p>我们不妨先简单了解下 React 的更新机制，如果能降低它的更新频率，自然能大大提高整体渲染速度。</p><h3 id="Props-amp-State"><a href="#Props-amp-State" class="headerlink" title="Props &amp; State"></a>Props &amp; State</h3><p>props 和 state 的基本概念不再赘述，组件的 props 是只读的，只能通过上层 JSX 声明时的属性传递进来，state 则完全受组件自身控制，并且只存在于 <code>class</code> 语法声明的组件。</p><p>无论是 props 还是 state 发生变化都可以触发组件更新，下面这些生命周期方法会在组件重新渲染时被依次调用：</p><ul><li>componentWillReceiveProps*</li><li>static getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate*</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><a id="more"></a><blockquote><p><code>*</code> 号标注的生命周期方法将会在 React 17 移除，一旦调用了新的生命周期方法，这些方法将不会被调用。</p></blockquote><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frj8i1dy0jj30aq0g9dgp.jpg" alt="Update lifecycle"></p><p>从上面的生命周期中我们可以看到，<code>shouldComponentUpdate</code> 方法将在组件接收到新的 props 或者 state 时被调用。然而在默认情况下， 每次更新，React 都会去调用 <strong>render</strong> 方法重新生成 Virtual DOM 并通过 diff 算法计算出需要变动的部分，然后操作 DOM 完成这部分更新。</p><p>对于一些简单的 React 应用来说，每次 <strong>render</strong> 带来的消耗不会特别大，不过一旦你的应用有了一定规模，尤其是复杂的树形结构时，每次更新都会消耗不少的系统资源。</p><h3 id="shouleComponentUpdate（SCU）"><a href="#shouleComponentUpdate（SCU）" class="headerlink" title="shouleComponentUpdate（SCU）"></a>shouleComponentUpdate（SCU）</h3><p>我们先来看下<a href="https://reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action" target="_blank" rel="noopener">官方文档</a>里的示意图。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1frsifbmx0kj30tc0oitci.jpg" alt></p><p>从图中可以看到，在这个简单的树形结构中，仅仅是 c7 的状态发生了改变，所有的组件都要进行一次 <strong>render</strong>，那如果我这个树下有 10 个组件呢，50 个呢？尤其当这个 c7 的状态变化与鼠标移动这种高频操作相关时，所有的组件不停的重新生成 Virtual DOM，这样能有多卡顿你能想象的到吗？不要问我是怎么知道的，某天 Leader 叫我写了个表单设计器……</p><p>如果不用 <strong>SCU</strong> 对 React 的更新进行限制，你可能像我之前一样，对着 Chrome 的 Perfomance 工具里锯齿般的火焰图束手无策。那假如 <strong>SCU</strong> 可以正确的感知数据变化并返回你期待的结果，实际情况又会如何呢？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1frsixpjyzij30sv0oi0w9.jpg" alt></p><p>如上所示，如果 <strong>SCU</strong> 正常工作，只会发生 3 次 Virtual DOM 的比较，换言之，只有发生改变的 c7 以及它的父级组件会进入 <strong>render</strong> 方法，生成 Virtual DOM。那这次如果我们有 100 个子组件，但 c7 的深度还是 3 呢？没错，它依然是只会调用 3 次 <strong>render</strong> 方法，在大型树形结构里，这样的渲染效率无疑是成几何倍提升。</p><p>那么问题又来了，<strong>SCU</strong> 是一定要实现的，但在每个组件中都手写 <strong>SCU</strong>，手动地比较复杂的对象中每个键的值，难度非同一般，那么如何轻松地让 <strong>SCU</strong> 返回你期待的结果？</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>虽然完全手写 <strong>SCU</strong> 不现实，但这里依然有一些组合方案可以助我们实现目标。</p><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>PureComponent 是 React 提供的另一个组件，它默认帮你实现了 <strong>SCU</strong> 方法，其实在它出现之前，它的前身是 React 的 addons 提供的 PureRenderMixin，它的源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowEqual = <span class="built_in">require</span>(<span class="string">'fbjs/lib/shallowEqual'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  shouldComponentUpdate: <span class="function"><span class="keyword">function</span>(<span class="params">nextProps, nextState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      !shallowEqual(<span class="keyword">this</span>.props, nextProps) ||</span><br><span class="line">      !shallowEqual(<span class="keyword">this</span>.state, nextState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 我们可以看到它帮我们实现了 <strong>SCU</strong> 方法，实现的机制是浅比较（Shallow Compare），也就是说，它只简单的比较了 <code>this.props</code> 和 <code>nextProps</code> 两个变量（以及他们的第一层子属性）引用的是否为同一个地址，如果是则返回 <strong>false</strong>，否则返回 <strong>true</strong>。</p><blockquote><p><code>shallowEqual</code> 的具体实现请查阅<a href="https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js" target="_blank" rel="noopener">源码</a></p></blockquote><p>同样的我们也来看下使用 PureComponent 时的具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkShouldComponentUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ...</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">const</span> ctor = workInProgress.type;</span><br><span class="line">  <span class="comment">// 用户自己实现</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.shouldComponentUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> shouldUpdate = instance.shouldComponentUpdate(</span><br><span class="line">      newProps,</span><br><span class="line">      newState,</span><br><span class="line">      newContext,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果用户不定义 <strong>SCU</strong> 方法，并且当前组件为 PureComponent 时，最终依然会对新旧 Props 和 State 进行一个浅比较。</p><p>虽然 PureComponent 帮我们实现了 <strong>SCU</strong> 方法，但这并不意味着我们已经达到目标了，别忘了它只是实现了浅比较，在 JavaScript 中，Primitive 数据能直接的用 <code>=</code> 号简单的浅比较，而 Object 数据仅仅表示两个变量引用的堆地址相同，但这块儿内存中的数据有没有改动过，就无从得知了，看个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oldState = &#123; <span class="attr">expand</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">oldState.expand = <span class="literal">false</span>;</span><br><span class="line">newState = oldState;</span><br><span class="line"></span><br><span class="line">shallowEqual(newState, oldState) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  如上我们更新了 state 的 expand 的值，但 PureComponent 在比较时会认为 state 并没有更新返回 <strong>SCU</strong> 返回 <code>false</code>，这样我们的组件就得不到正确的更新了。</p><h3 id="深拷贝就行了，是这样吗"><a href="#深拷贝就行了，是这样吗" class="headerlink" title="深拷贝就行了，是这样吗"></a>深拷贝就行了，是这样吗</h3><p>可能比较有经验的童鞋会说，只要用深拷贝就行了，那我们来看下几种常见的深拷贝实现</p><h4 id="JSON-之-stringify-parse"><a href="#JSON-之-stringify-parse" class="headerlink" title="JSON 之 stringify + parse"></a>JSON 之 stringify + parse</h4><p>这个原理比较简单，序列化之后，对象变成了一个字符串，<code>JSON.parse</code> 会从字符串重新生成对象，很明显这已经不是之前那个对象了，实现了完全的深拷贝。但是别忘了，JSON 只有 6 种基本数据类型，这样转换很显然不少对象会出现问题，比如 Function 对象，Date 对象等等，都无法正常转换。可见这种方案的适用场景也是比较少的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">false</span>,</span><br><span class="line">  c: <span class="string">'react'</span>,</span><br><span class="line">  d: <span class="literal">null</span>,</span><br><span class="line">  e: [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Forget me!'</span>) &#125;,</span><br><span class="line">  g: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  h: <span class="regexp">/forget me/g</span>,</span><br><span class="line">  i: [<span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()],</span><br><span class="line">  j: <span class="built_in">Symbol</span>(<span class="string">'Forget me'</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(o)));</span><br></pre></td></tr></table></figure><p>Output:</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frt9x393n1j30gf054t94.jpg" alt></p><h4 id="lodash-cloneDeep"><a href="#lodash-cloneDeep" class="headerlink" title="lodash.cloneDeep"></a>lodash.cloneDeep</h4><p>相较于用 JSON 粗暴的转换，lodash 的处理更为细致，Primitive 数据直接返回，Object 数据则逐一处理。</p><p>还是上面的例子，lodash 的输出结果：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1frt9wmakpgj30fh05zmxp.jpg" alt></p><p>类似的还有 jQuery 的 extend 方法（第一个参数为 true 时为深拷贝）。虽然深拷贝帮我们重新处理了浅比较的问题，但当你使用的时候可能会发现，每次修改树形结构的里的一个值，所有的组件依然会全部渲染。这是因为树形结构中所有的对象引用地址都被改变了，PureComponent 在浅比较时，自然所有的 <strong>SCU</strong> 都会返回 ture，我们似乎又回到了起点，那如何只让变动的部分改变引用呢？</p><h3 id="优雅的-Immutable-数据"><a href="#优雅的-Immutable-数据" class="headerlink" title="优雅的 Immutable 数据"></a>优雅的 Immutable 数据</h3><p>Immutable 即不可变的，意思是对象创建后，无法通过简单的赋值更改值或引用。Facebook 推出了 ImmutableJS 来实现这套机制，它有自己的一套 API 来对已有的 Immutable 对象进行修改并返回一个全新的对象，但与深拷贝不同，这个对象只修改了变动的部分，示意如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1frt9vy605zj30lz0ctq47.jpg" alt></p><h4 id="ImmutableJS"><a href="#ImmutableJS" class="headerlink" title="ImmutableJS"></a>ImmutableJS</h4><p>Facebook 推荐使用 ImmutableJS 来优化 React 应用，但使用它的同时也意味需要重新学习大量的 API</p><h4 id="Immutability-helper"><a href="#Immutability-helper" class="headerlink" title="Immutability-helper"></a>Immutability-helper</h4><p>Immutability-helper 原来是 React 的 addons 里面的 update 模块，独立出来后又新增了拓展模块，它提供了一种语法糖，你可以直接描述需要修改的对象，并且用预置命令对这部分进行修改，最后返回一个修改后的对象，以此来模拟 Immutable 数据的行为</p><p>extend 的行为与 Object.assign 一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newData = extend(myData, &#123;</span><br><span class="line">  x: extend(myData.x, &#123;</span><br><span class="line">    y: extend(myData.x.y, &#123;<span class="attr">z</span>: <span class="number">7</span>&#125;),</span><br><span class="line">  &#125;),</span><br><span class="line">  a: extend(myData.a, &#123;<span class="attr">b</span>: myData.a.b.concat(<span class="number">9</span>)&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 immutability-helper:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> update <span class="keyword">from</span> <span class="string">'immutability-helper'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newData = update(myData, &#123;</span><br><span class="line">  x: &#123;<span class="attr">y</span>: &#123;<span class="attr">z</span>: &#123;<span class="attr">$set</span>: <span class="number">7</span>&#125;&#125;&#125;,</span><br><span class="line">  a: &#123;<span class="attr">b</span>: &#123;<span class="attr">$push</span>: [<span class="number">9</span>]&#125;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到通过这个库提供的语法糖，我们可以更快速清晰便捷的修改对象，而不用一层一层地用 Object.assign 之类的包起来。这种方式相较于 ImmutableJS 比较没有侵入性，性能也不比 Immutable 差多少（有待测试），没有学习成本，比较<strong>推荐</strong>！</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实说到这里，本篇基本已经结束了，在 PureComponent 和 Immutable Data 的搭配使用下，<strong>SCU</strong> 能很大程度提高 React 应用的性能，不过这也只是从组件更新的角度来优化 React，实际上我们能做的事还有很多。</p><h2 id="问题与建议"><a href="#问题与建议" class="headerlink" title="问题与建议"></a>问题与建议</h2><p>上文只是作者本人在 React 优化中的实践，翻阅网上的资料与源码总结而出的一篇分享，如有谬误欢迎指正！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://reactjs.org/docs/optimizing-performance.html" target="_blank" rel="noopener">Optimizing Performance - reactjs.org</a></li><li><a href="https://medium.com/dailyjs/react-is-slow-react-is-fast-optimizing-react-apps-in-practice-394176a11fba" target="_blank" rel="noopener">React is Slow, React is Fast: Optimizing React Apps in Practice - Daily JS</a></li></ol><h3 id="图形素材"><a href="#图形素材" class="headerlink" title="图形素材"></a>图形素材</h3><p><a href="https://github.com/liangzr/blog/blob/master/assets/optimizing-react-app-with-immutable-data.key" target="_blank" rel="noopener">optimizing-react-app-with-immutable-data.key</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/1970/01/01/hello-world/"/>
      <url>/1970/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
