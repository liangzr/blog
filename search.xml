<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>下棋</title>
      <link href="/2019/04/27/chinese-chess/"/>
      <url>/2019/04/27/chinese-chess/</url>
      
        <content type="html"><![CDATA[<p>上一次下象棋，大约在二〇一六年的春天，在院子里跟外公排兵布阵，那局我赢了，却也是我最后一次下棋。</p><p>打小就喜欢下棋，在家里跟老爸下的时候，他总让我车马炮三个子，即使如此我也很少赢。每一放长假，我就会到外婆家去住。外公下棋非常厉害，听说早些年的时候，乡里的领导还把外公请过去下棋，可谓是声名在外，村里的老头们也没人能下得过外公。外公在我心里犹如战神一般的存在，我也很喜欢跟外公下棋，一有空就会跑到院子里把挂在木架上的一兜象棋取下来，在地上铺好棋盘摆好棋子，求外公跟我下棋。关于棋子也有个趣事，外公家 的棋子有些年代了，在院子里也是风吹雨淋，但后来不知哪天就不见了。没有棋下让我非常手痒，我就跟我妈说把我家的棋带到外公家，反正我爸平时也不下棋。就这样把我爸的棋偷偷带到了老家，后来让他知道后，又好气又好笑地没少数落我。</p><p>跟外公下棋，我是屡战屡败。小学时我的棋技已经足够娴熟，不会像初学者一样犯低级的走位失误，但外公总能在三两步间钳制住我造成两难局面，让我不得不断腕求生，惨失大将。即使这样，不下到最后一子，我也从没放弃过，并不会因为外公的大将比我多，就直接弃局。后来我发现外公在有些情况下甚至会主动跟我换子，因为在双方将子都不全情况下，他对大将的处理比我要好的多。</p><p>跟外公下棋，我的最佳战绩就是打个平手，但我依然屡败屡战。所以平日的目标是，即使我大将比你少，我也不一定能被你将死。然而，无数盘棋下来，外公让我见识了形形色色的残局进攻策略，各种马后炮、双炮、卧槽（马左三将军的一个位置）、过河卒等等战术层出不穷，尤其是对己方老将和过河卒的灵活使用让我猝不及防。</p><p>村子里的人过来串门，经常能看到外公和我下棋，他们就站在一边看，慢慢连村里的人也公认我下棋有术，虽然我从未赢过外公。记得有一次在家门口的空旷地，村里的一个老头喊我把象棋拿出来跟我切磋切磋。我很兴奋地去拿了棋过来，心想这是我扬名立万的好机会。经过一番持久的角逐，我真的赢了，从此在村里我就又成了“下棋赢过某某老头”的人。</p><p>后来上了高中以及大学，假期变长却也变少了，我回老家的次数也少了。而我爸完全是在我小的时候抱着虐菜的心理才跟我下棋，感受不到虐菜的快乐后，就很少愿意跟我下棋。但每次寒暑假我回老家，都一定会跟外公下棋。一五年的时候，外公被查出骨髓癌，从山上下来到我家住，那个时候我大学还没毕业。外公在那一年接受了很多化疗，人瘦了很多也虚弱了很多。一六年初，我考研结束（放弃）后就去医院陪着照看外公。外公这辈子爱好不多，无非听戏、下棋，那时候我从电脑上搜集了不少河洛套子、豫剧名曲等戏曲，带去医院给外公听。在医院时，中午吃完饭就带外公到医院的小广场上晒会儿太阳，听听戏曲儿。</p><p>我一直没想起来下棋。后来不知道哪天灵机一动——既然有这么多空闲时间，何不再陪外公下两盘棋呢？不过医院不大方便，化疗也是周期性的，等到那个疗程结束回到我家，我就把家里的象棋拿出来跟外公下。几个回合下来，我明显感觉到外公的思考时间和细节处理比以前都差了太多，甚至几次走位失误被我意外地白吃了大将。眼看着就要赢外公了，我心里却一点都开心不起来。就这样下着下着眼睛湿润，鼻子也有点酸了，我便以多名大将的优势草草地结束了战斗，挤起笑容跟外公说我赢了，你这局棋下的太不小心了。外公也哈哈着说，现在下的不行了，回屋休息会儿。外公化疗用的很多药物，对人的身体都有永久性的损伤，有些会导致记忆力下降，有的则会导致耳朵聋等，下棋水平下滑也跟这个有关。</p><p>从那之后我就没再提过下棋，怕打破外公心里那份骄傲，也没有能跟我下棋的人了</p>]]></content>
      
      
      <categories>
          
          <category> writing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么要使用 redux-thunk</title>
      <link href="/2019/04/18/redux-thunk-source-code/"/>
      <url>/2019/04/18/redux-thunk-source-code/</url>
      
        <content type="html"><![CDATA[<p>以前我一直不理解，为什么说 <code>redux-thunk</code> 是用来处理异步 action 的，没有它就不能处理异步 action 吗？</p><p>答案是可以的。</p><p>实际上，只要你能拿到 dispatch 方法，你可以在任何时候 dispatch 一个 action 对象。dispatch 方法是一个同步操作，它传递了 action 并且更新了 store，可以参考前面的文章<a href="https://blog.liangzr.tech/2019/04/17/redux-source-code/">《Redux 源码分析》</a>。</p><p>这样我就更不明白了，既然这样，<code>redux-thunk</code> 究竟做了什么？</p><a id="more"></a><h2 id="redux-thunk-源码"><a href="#redux-thunk-源码" class="headerlink" title="redux-thunk 源码"></a>redux-thunk 源码</h2><p><code>redux-thunk</code> 是一个标准的 Redux 中间件，源码也十分简单：</p><pre><code class="language-js">function createThunkMiddleware(extraArgument) {  return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {    if (typeof action === &#39;function&#39;) {      return action(dispatch, getState, extraArgument);    }    return next(action);  };}const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk;</code></pre><p>默认情况下，<code>redux-thunk</code> 返回的是一个标准的 Redux 中间件，它暴露了一个方法让你自己创建一个带参数的 thunk 中间件，我们先忽略这部分：</p><pre><code class="language-js">const thunk =  ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {  if (typeof action === &#39;function&#39;) {    return action(dispatch, getState, extraArgument);  }  return next(action);};</code></pre><p>通过<a href="https://blog.liangzr.tech/2019/04/18/redux-middleware/">《Redux 中间件》</a> 一文我们得知。第一个箭头前面的 <code>dispatch</code> 和 <code>getState</code> 做为 <strong>middlewareAPI</strong> 传递进来，初始化中间件的。</p><p>下面的 <code>return next(action)</code> 也是调用了上层中间件返回的 <code>dispatch</code> 方法，所以关键在于这个判断：</p><pre><code class="language-js">if (typeof action === &#39;function&#39;) {  return action(dispatch, getState, extraArgument);}</code></pre><p>如果 action 是一个函数，则调用 action，并把初始化中间件时的两个参数，以及额外的参数，传递给了 action 函数。</p><p>源码就这些内容，想要彻底理解，还是要跟着例子来看。</p><h2 id="异步-Action"><a href="#异步-Action" class="headerlink" title="异步 Action"></a>异步 Action</h2><p>假如我们有个 action 是这样的：</p><pre><code class="language-js">const fetchUserAvatar = name =&gt; ({getState, dispatch}) =&gt; {  fetch(`https://api.github.com/users/${name}`)    .then(res =&gt; res.json())    .then(({ avatar_url }) =&gt; {      dispatch({        type: &#39;UPDATE_USER_AVATAR&#39;,        payload: avatar_url,      })    })}</code></pre><p>然后我们 dispatch 这个 action:</p><pre><code class="language-js">dispatch(fetchUserAvatar(&#39;liangzr&#39;))</code></pre><p>因为 action 是一个方法，<code>redux-thunk</code> 就把相应的参数传给了 <code>fetchUserAvatar</code>，而 api 在返回后也成功 dispatch 了 action。</p><p>但是到这里，我起初有个疑惑，如果 <code>redux-thunk</code> 没有调用 <code>next</code> 方法，也就是下层生成的 dispatch 方法的话，后面不就不会经过中间件了吗？</p><h2 id="到底是哪个-dispatch"><a href="#到底是哪个-dispatch" class="headerlink" title="到底是哪个 dispatch"></a>到底是哪个 dispatch</h2><p>这个问题就又要回到 <code>applyMiddleware</code> 方法内了：</p><pre><code class="language-js">let dispatch = () =&gt; {}const middlewareAPI = {  getState: store.getState,  dispatch: (...args) =&gt; dispatch(...args)}const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))dispatch = compose(...chain)(store.dispatch)</code></pre><p>可以看到，<code>dispatch</code> 变量在一开始就声明了，并且 <code>middlewareAPI</code> 的 dispatch 属性的方法中，通过闭包持有它的引用。最后 <code>dispatch</code> 变量又被赋值了 <code>compose</code> 处理后的最终 dispatch 方法。</p><p>也就是说，<code>middlewareAPI</code> 中的 dispatch 方法，最终会调用被层层中间件处理后的 dispatch。</p><p>那 <code>dispatch(fetchUserAvatar(&#39;liangzr&#39;))</code> 的执行过程应该是：</p><p><img src="/diagrams/redux-thunk/dispatch.svg" alt></p><p>可以看到 <code>redux-thunk</code> 其实执行了两次，第二次才真正地处理了中间件。并且由此也可以看出，因为我们上次说过，第一个中间件会被第一个执行，而 <code>redux-thunk</code> 也必须第一个执行，所以在使用的时候，始终要把它放到中间件的第一位。</p><h2 id="为何不用-store-dispatch"><a href="#为何不用-store-dispatch" class="headerlink" title="为何不用 store.dispatch"></a>为何不用 store.dispatch</h2><p>首先，如果从外部引用 <code>store.dispatch</code> 的话，有两个问题：</p><ol><li><strong>它强制了 store 必须是一个单例</strong>：这对服务端渲染很不友好，因为对于不同的用户或者说请求，它都应该有个独立的 store</li><li><strong>不易于测试</strong>：因为使用了外部引用的 store，你没办法方便地 mock 一个 store 用来测试，也不能控制 store 的状态</li></ol><p>其次，使用 <code>redux-thunk</code> 中间件，赋予了 redux 来 dispatch 异步 action 的能力，你不用担心 dispatch 的 action 到底是同步还是异步的，通过 thunk 中间件，异步 action 自然可以惰性处理。</p><p>Redux 的作者 Dan Abramov 曾对这个问题进行过多次释疑，可以参考下面两个链接：</p><ul><li><a href="https://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559" target="_blank" rel="noopener">How to dispatch a Redux action with a timeout?</a></li><li><a href="https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34599594#34599594" target="_blank" rel="noopener">Why do we need middleware for async flow in Redux?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> source code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux 中间件</title>
      <link href="/2019/04/18/redux-middleware/"/>
      <url>/2019/04/18/redux-middleware/</url>
      
        <content type="html"><![CDATA[<p>Middleware 是 Redux 提供的一个增强功能，利用函数式编程的柯里化和组合特性，实现了一个和 koa 类似的洋葱结构的中间件。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>我们再回到 <code>createStore</code> 方法的最开始，有这么一段代码</p><pre><code class="language-js">export default function createStore(reducer, preloadedState, enhancer) {  if (    (typeof preloadedState === &#39;function&#39; &amp;&amp; typeof enhancer === &#39;function&#39;) ||    (typeof enhancer === &#39;function&#39; &amp;&amp; typeof arguments[3] === &#39;function&#39;)  ) {    throw new Error(      &#39;It looks like you are passing several store enhancers to &#39; +        &#39;createStore(). This is not supported. Instead, compose them &#39; +        &#39;together to a single function.&#39;    )  }  if (typeof preloadedState === &#39;function&#39; &amp;&amp; typeof enhancer === &#39;undefined&#39;) {    enhancer = preloadedState    preloadedState = undefined  }  if (typeof enhancer !== &#39;undefined&#39;) {    if (typeof enhancer !== &#39;function&#39;) {      throw new Error(&#39;Expected the enhancer to be a function.&#39;)    }    return enhancer(createStore)(reducer, preloadedState)  }  // 主逻辑  ...}</code></pre><p>它先是判断了如果第二个参数和第三个参数都为函数，或者第三个参数和第四个参数都为函数，则会警告只允许有一个 enhancer，实际上也只允许 applyMiddleware 的返回。</p><p>同时，如果第二个参数是 function 并且第三个参数是 undefined 时，第二个参数则为真正的 enhancer。这意味着 preloadedState 参数可以被省略，当它被省略的时候，值初始化为 undefined。</p><p>如果 enhancer 校验通过，则会调用它，并且把 <code>createStore</code> 本身作为参数，并且返回 enhancer 的结果。</p><a id="more"></a><h2 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h2><p>其实目前在 redux 中，唯一的 enhancer 就是 applyMiddleware 函数的返回，所以关键还在于这个函数。</p><p>applyMiddleware 主体：</p><pre><code class="language-js">export default function applyMiddleware(...middlewares) {  return createStore =&gt; (...args) =&gt; {    const store = createStore(...args)    let dispatch = () =&gt; {      throw new Error(        &#39;Dispatching while constructing your middleware is not allowed. &#39; +          &#39;Other middleware would not be applied to this dispatch.&#39;      )    }    const middlewareAPI = {      getState: store.getState,      dispatch: (...args) =&gt; dispatch(...args)    }    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))    dispatch = compose(...chain)(store.dispatch)    return {      ...store,      dispatch    }  }}</code></pre><p>可以看到，它先是通过 <code>createStore</code> 创建了 store 实例，然后禁止在重新赋值之前使用 <code>dispatch</code> 方法。</p><pre><code class="language-js">const middlewareAPI = {  getState: store.getState,  dispatch: (...args) =&gt; dispatch(...args)}</code></pre><p>随后定义了 middleware 的两个默认传参，一个是 store 中的 <code>getState</code> 方法，一个是封装的 <code>dispatch</code>。</p><pre><code class="language-js">const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</code></pre><p>这一步遍历了每个中间件，把上一步的两个参数传进入后执行，并把执行后的结果以数组的形式赋给了 <code>chain</code>，所以 chain 其实是一个初始化过的中间件的数组。</p><pre><code class="language-js">dispatch = compose(...chain)(store.dispatch)</code></pre><p>这一步可以看到，通过一个 <code>compose</code> 方法，返回了一个函数，并且把 <code>store.dispatch</code> 传参进去，返回了一个新的 dispatch。</p><pre><code class="language-js">return {  ...store,  dispatch}</code></pre><p>最后把新的 <code>dispatch</code> 替换第一步生成的，和 store 合并到一起并返回。</p><p>总的来说， <code>applyMiddleware</code> 的效果就是对 <code>dispatch</code> 做了处理，而具体的处理逻辑都做了什么呢？还要看 <code>compose</code> 方法。</p><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>compose 是函数式编程中常见的一个方法，常用来搭配柯里化（currying）来对原数据进行一系列处理。</p><p>在函数式编程的概念里，函数是一等公民。而在这个场景中，它处理的对象正是 <code>dispatch</code> 函数，</p><p>源码：</p><pre><code class="language-js">export default function compose(...funcs) {  if (funcs.length === 0) {    return arg =&gt; arg  }  if (funcs.length === 1) {    return funcs[0]  }  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))}</code></pre><p>看似非常简单，但理解起来不是特别容易，如果对 compose 和 currying 陌生的话。前两个都是边界处理，如果没有参数，则返回一个<strong>返回自身</strong>的函数。如果只有一个参数，则返回此参数。</p><p>最关键的是最后一行，使用了一个 <code>reduce</code> 方法，让它可以依次处理 <code>funcs</code> 中的所有函数，并把后一个执行的结果，做为参数传递给前一个函数。</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>只是说可能有点拗口，我们来看个例子，假如有个 <code>funcs</code>：</p><pre><code class="language-js">const funcs = [a, b, c, d, e]   // 有五项，每项都是函数compose(funcs) // (...args) =&gt; a(b(c(d(e(...args)))))</code></pre><p>所以上方返回的 dispatch 其实是：</p><pre><code class="language-js">dispatch = compose(...funcs)(store.dispatch) // a(b(c(d(e(store.dispatch)))))</code></pre><p>可以看到，它正是被中间件函数层层包裹之后处理得出的结果，即新的 dispatch。</p><p>那再来看一个典型的中间件应该是什么样的：</p><pre><code class="language-js">const reduxLogger = ({ getState, dispatch }) =&gt; next =&gt; action =&gt; {  console.log(action)  return next(action)}</code></pre><p>一连串的箭头函数让人看的头皮发麻，不过我们知道，中间件在放进 <code>compose</code> 执行之前，先做了一步预处理，传递了两个 api 进去，所以简化一下真正被 <code>compose</code> 执行的中间件应该是这样的：</p><pre><code class="language-js">let getState, dispatch // 闭包的变量const reduxLoggerHander = next =&gt; action =&gt; {  console.log(action)  return next(action)}</code></pre><p>我们上方提到，后一个函数执行的结果，可以当作参数传递给前一个，所以假如 <code>reduxLogger</code> 在最后一个，则它执行完的结果应该是：</p><pre><code class="language-js">let getState, dispatch // 闭包的变量const dispatchWithLogger = action =&gt; {  console.log(action)  return store.dispatch(action)}</code></pre><p>走到这一步，拨开云雾见天明，这个中间件已经不再神秘了。经过 <code>componse</code> 处理后，它就是一个新的拥有日志功能的 dispatch，而它内部正是调用了 <code>createStore</code> 中原生的 <code>store.dispatch</code> 方法。</p><p>你可能会想，既然只是一层封装，重新写个方法不就好了，为什么要埋的这么深？这是因为，通过 <code>compose</code> 可以不只处理一个中间件，还可以直接应用一个中间件数组，并且让它们之间递归调用。</p><p>我们再回到 <code>dispatchWithLogger</code> 方法，它是最内层的执行结果，按照我们前面的分析，它将作为参数传递给下一个中间件。假如是一个 <code>Hello</code> 中间件，最终返回的应该是 <code>dispatchWithLoggerAndHello</code>。以此类推，最终我们就可以得到一个被中间件层层处理后的全新 <code>dispatch</code>。</p><p>还有一个问题是，我们刚刚讲了，中间件数组的最后一个方法先执行，返回一个全新的 <code>dispatch</code>，那执行顺序就是从最后一个到第一个吗？并不是，中间件函数返回的只是一个处理后的 dispatch 方法，而这个方法只有被上一级调用的时候，才会执行被修改后的 dispatch 的内容。</p><p>所以，<strong>第一个中间件包裹在最外层，也是第一个执行的。</strong></p><p>类似于下面这种结构：</p><pre><code class="language-js">action =&gt; {  // a  (actionB =&gt; {    // b    (actionC =&gt; {      // c      (actionD =&gt; {        // d        store.dispatch(actionD)        // d      })(actionC)      // c    })(actionB)    // b  })(action)  // a}</code></pre><p>当然，因为很多中间件都返回了上一个 <code>dispatch</code> 方法的结果，所以不存在上图中的下半部分。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> source code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux 源码分析</title>
      <link href="/2019/04/17/redux-source-code/"/>
      <url>/2019/04/17/redux-source-code/</url>
      
        <content type="html"><![CDATA[<p>Redux 起源于一个实验，作者 Dan Abramov 本想通过 Flux 思想解决他的热重载和时间旅行的问题，如今它已经是 React 技术栈中状态管理方案的不二之选。</p><p>本篇主要分析 Redux 的源码结构，对 Flux 架构的思想不再赘述，可以参考<a href="https://facebook.github.io/flux/" target="_blank" rel="noopener">官方的解释</a></p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>Redux 源码的目录结构如下：</p><pre><code>src├── applyMiddleware.js├── bindActionCreators.js├── combineReducers.js├── compose.js├── createStore.js├── index.js└── utils    ├── actionTypes.js    ├── isPlainObject.js    └── warning.js</code></pre><a id="more"></a><p>可以看到 Redux 的源码还是非常简单的，入口文件则导出了关键函数：</p><p><code>index.js</code>：</p><pre><code class="language-js">...export {  createStore,  combineReducers,  bindActionCreators,  applyMiddleware,  compose,  __DO_NOT_USE__ActionTypes}</code></pre><p>最关键的 <code>createStore</code> 就是我们用来用来创建 store 的，而 <code>combineReducers</code> 和 <code>bindActionCreators</code> 则是一些辅助方法，<code>applyMiddleware</code> 和 <code>compose</code> 则和中间件有关。</p><p>下面我们依次从创建 store、辅助方法、中间件三个方面了解下 Redux 的设计。</p><h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><p>先不关注 <code>createStore</code> 中其它函数，以及一些校验的方法，我们先来看看它本身都做了些什么：</p><pre><code class="language-js">export default function createStore(reducer, preloadedState, enhancer) {  let currentReducer = reducer          // 初始化 reducer  let currentState = preloadedState     // 初始化状态  let currentListeners = []             // 初始化监听器为空数组  let nextListeners = currentListeners  // 缓存当前监听器数组  let isDispatching = false             // 初始化是否正在 dispatch 为 false  function ensureCanMutateNextListeners() {}  function getState() {}  function subscribe(listener) {}  function dispatch(action) {}  function replaceReducer(nextReducer) {}  function observable() {}  dispatch({ type: ActionTypes.INIT })  return {    dispatch,    subscribe,    getState,    replaceReducer，    [$$observable]: observable,  }}</code></pre><p>可以看到，<code>createStore</code> 定义了一堆局部变量来保存状态，而这些状态在内部的方法中可以访问到，这些方法又被返回了出来，由此因为闭包的原因，这些函数内的变量也得以保存。</p><p>在声明了一系列方法后，<code>createStore</code> 最后 dispatch 了一个初始化的 action，随后返回了这些方法。</p><p><code>actionTypes.js</code>: </p><pre><code class="language-js">const randomString = () =&gt;  Math.random()    .toString(36)    .substring(7)    .split(&#39;&#39;)    .join(&#39;.&#39;)const ActionTypes = {  INIT: `@@redux/INIT${randomString()}`,  REPLACE: `@@redux/REPLACE${randomString()}`,  PROBE_UNKNOWN_ACTION: () =&gt; `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`}export default ActionType</code></pre><p><code>randomString</code> 生成了一个随机的字符串，<code>Number.prototype.toString</code> 可以把数字转换成 2-36 进制的字符串，36 进制度则用 0-9、a-z 来表示，如此一来它产生的就是类似 <code>&#39;p.w.1.s.r.h&#39;</code> 这样的字符串。</p><p>另外可以注意到，INIT 和 REPLACE 是在模块加载的时候就已经生成了随机字符串，而 PROBE_UNKNOWN_ACTION 则会在调用的时候才调用 <code>randomString</code> 方法。</p><h3 id="getState"><a href="#getState" class="headerlink" title="getState"></a>getState</h3><pre><code class="language-js"> function getState() {    if (isDispatching) {      throw new Error(        &#39;You may not call store.getState() while the reducer is executing. &#39; +          &#39;The reducer has already received the state as an argument. &#39; +          &#39;Pass it down from the top reducer instead of reading it from the store.&#39;      )    }    return currentState  }</code></pre><p><code>getState</code> 方法的逻辑非常简单，它直接返回了函数变量 <code>currentState</code>，即当前的的整个 store 树。</p><p>但要注意的是，<code>isDispatching</code> 为 <code>true</code> 的时候，则会抛出一个错误，这个问题我们先留着待会看。</p><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><pre><code class="language-js">function subscribe(listener) {    if (isDispatching) {      throw new Error(        &#39;You may not call store.subscribe() while the reducer is executing. &#39; +          &#39;If you would like to be notified after the store has been updated, subscribe from a &#39; +          &#39;component and invoke store.getState() in the callback to access the latest state. &#39; +          &#39;See https://redux.js.org/api-reference/store#subscribe(listener) for more details.&#39;      )    }    let isSubscribed = true    ensureCanMutateNextListeners()    nextListeners.push(listener)    return function unsubscribe() {      if (!isSubscribed) {        return      }      if (isDispatching) {        throw new Error(          &#39;You may not unsubscribe from a store listener while the reducer is executing. &#39; +            &#39;See https://redux.js.org/api-reference/store#subscribe(listener) for more details.&#39;        )      }      isSubscribed = false      ensureCanMutateNextListeners()      const index = nextListeners.indexOf(listener)      nextListeners.splice(index, 1)    }  }</code></pre><p><code>subscribe</code> 方法将传递进来的监听器，push 到了 <code>nextListeners</code> 数组中，定义了内部变量 <code>isSubscribed</code> 为 <code>true</code>，并且返回了 <code>unsubscribe</code> 方法。</p><p><code>unsubscribe</code> 方法则检查了 <code>isSubscribed</code> 变量，并且将其置为 <code>false</code>，这样做可以防止 <code>unsubscribe</code> 被多次调用，然后又从 <code>nextListener</code> 数组中删掉了这个监听器。</p><p>整个的逻辑非常简单，<strong>将一个监听器方法加入或移除监听器列表</strong>。</p><p><code>ensureCanMutateNextListeners</code> 方法这里暂时不管它，后面我们会提到。</p><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><pre><code class="language-js">function dispatch(action) {  if (!isPlainObject(action)) {    throw new Error(      &#39;Actions must be plain objects. &#39; +        &#39;Use custom middleware for async actions.&#39;    )  }  if (typeof action.type === &#39;undefined&#39;) {    throw new Error(      &#39;Actions may not have an undefined &quot;type&quot; property. &#39; +        &#39;Have you misspelled a constant?&#39;    )  }  if (isDispatching) {    throw new Error(&#39;Reducers may not dispatch actions.&#39;)  }  try {    isDispatching = true    currentState = currentReducer(currentState, action)  } finally {    isDispatching = false  }  const listeners = (currentListeners = nextListeners)  for (let i = 0; i &lt; listeners.length; i++) {    const listener = listeners[i]    listener()  }  return action}</code></pre><p><code>dispatch</code> 方法是整个 Redux 的核心，不过它的过程也很简单。</p><p>首先它将 <code>isDispatching</code> 置于 <code>true</code>，然后调用了 <code>currentReducer</code> 方法，传入了 <code>currentState</code> 和 <code>action</code>，又返回了 <code>currentState</code>。也就是用当前的状态和 action，计算出了一次的状态。在 <code>try</code> 代码块执行完后，则会把 <code>isDispatching</code> 重置为 <code>false</code>。</p><blockquote><p>这里的 try…finally 并没有 catch 代码块，所以并不会吃掉 Error</p></blockquote><p>在这里终于明白上文中多次出现的 <code>isDispatching</code> 的具体含义，就是在计算新的 state 的过程中，也就是执行 reducer 方法时，不允许 <code>getState</code>、 <code>subscribe</code>、<code>unsubscribe</code> 以及 <code>dispatch</code>。</p><p>在 dispatch 方法的最后，遍历了监听器数组并且逐个执行，然后返回了 action 对象。</p><p>可以看到，dispatch 方法其实非常简单，它主要的内容就是<strong>计算新 store 并且在执行完成后，执行监听器方法</strong>。但对于 action 需要注意的是，首先它必须是一个常规对象，其次根据 Flux 的规范，<strong>action 也必须有 type 属性。</strong></p><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>还有一些其它的方法作为功能上的补充，这些简单介绍下它们</p><h4 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h4><pre><code class="language-js">function replaceReducer(nextReducer) {  if (typeof nextReducer !== &#39;function&#39;) {    throw new Error(&#39;Expected the nextReducer to be a function.&#39;)  }  currentReducer = nextReducer  // This action has a similiar effect to ActionTypes.INIT.  // Any reducers that existed in both the new and old rootReducer  // will receive the previous state. This effectively populates  // the new state tree with any relevant data from the old one.  dispatch({ type: ActionTypes.REPLACE })}</code></pre><p>这个方法可以把当前的 reducer 整个替换掉，它的主要应用场景在于动态地加载 reducer，比如如果你想地你的应用启用代码分割时。</p><h4 id="ensureCanMutateNextListeners"><a href="#ensureCanMutateNextListeners" class="headerlink" title="ensureCanMutateNextListeners"></a>ensureCanMutateNextListeners</h4><pre><code class="language-js">function ensureCanMutateNextListeners() {  if (nextListeners === currentListeners) {    nextListeners = currentListeners.slice()  }}</code></pre><p>通过 slice 方法遍历了 <code>currentListeners</code> 数组，并且缓存到 <code>nextListeners</code> 中。</p><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p>reducer 的定义是一个函数，这个函数接受一个旧的 state 和一个 action 对象，并且返回一个新对象。</p><p>我们可以在 reducer 内通过 <code>swtich...case</code> 语法，通过判断 <code>aciton.type</code> 来分别执行不同的 mutate 方法，最后返回一个新的 state。但如果一个应用中所有的 mutation 都写到一个 <code>switch...case</code> 里，这个 reducer 方法就容易变得难以维护。</p><p>redux 库为我们提供了一个 <code>combineReducers</code> 方法，帮助我们把许多 reducer 合并成一个总的 reducer，然后再传递给 <code>createStore</code> 方法去初始化 store。</p><p>我们先来简单地看下这个方法做了什么处理：</p><pre><code class="language-js">export default function combineReducers(reducers) {  /*   * 第一部分: 过滤掉非函数的 reducer, 把结果放入 finanlReducers 中   */  const reducerKeys = Object.keys(reducers)            const finalReducers = {}  for (let i = 0; i &lt; reducerKeys.length; i++) {       const key = reducerKeys[i]    if (typeof reducers[key] === &#39;function&#39;) {      finalReducers[key] = reducers[key]    }  }  const finalReducerKeys = Object.keys(finalReducers)  /*   *  第二部分：判断 reducers 是否合法   */  let shapeAssertionError  try {    assertReducerShape(finalReducers)  } catch (e) {    shapeAssertionError = e  }  /*   *  第三部分：返回合并后的 reducer 方法   */  return function combination(state = {}, action) {    if (shapeAssertionError) {      throw shapeAssertionError    }    let hasChanged = false    const nextState = {}    for (let i = 0; i &lt; finalReducerKeys.length; i++) {      const key = finalReducerKeys[i]      const reducer = finalReducers[key]      const previousStateForKey = state[key]      const nextStateForKey = reducer(previousStateForKey, action)      if (typeof nextStateForKey === &#39;undefined&#39;) {        const errorMessage = getUndefinedStateErrorMessage(key, action)        throw new Error(errorMessage)      }      nextState[key] = nextStateForKey      hasChanged = hasChanged || nextStateForKey !== previousStateForKey    }    return hasChanged ? nextState : state  }}</code></pre><p>这个函数大体上可以分为三部分。先是过滤掉了 reducers 中非函数的部分，然后对 reducer 做了个校验，最后返回了合并后的 reducer 方法。第一和第二部分较为简单不再赘述，主要来看下第三部分。</p><p>第二部分中校验失败时抛出的错误被 catch 并保存到 <code>shapeAssertionError</code> 中了，这样在创建 store 的时候就不会抛错，直到执行（任意） reducer 的时候才抛出错误。由于 createStore 方法的末尾 dispatch 了一个 INIT action，所以它也会在初始化的时候报错。</p><p>第三部分主要做了一个简单的遍历操作，把 reducers 中的每个 reducer 及其对应的 state 拿出来，加上传递进来的 action 对象，计算出了新的 state 并缓存起来。这里需要注意的是，combination 方法定义了一个 <code>hasChanged</code> 标志，如果这些 reducers 中没有任何一个计算后的 state 的引用发生改变，则返回旧的 state。在这里<strong>对各个 reducer 对应的新旧 state 应用了浅比较</strong>，这意味着你只修改 reducer 对应的 state 内部的属性，store 是不会发生改变的。</p><h2 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h2><p>这是 redux 库提供的一个易用的辅助方法，帮助我们简化 dispatch 和 actionCreators 的交互，可以方法地直接调用方法达到 dispatch action 的目的。</p><p>看下源码：</p><pre><code class="language-js">export default function bindActionCreators(actionCreators, dispatch) {  if (typeof actionCreators === &#39;function&#39;) {    return bindActionCreator(actionCreators, dispatch)  }  if (typeof actionCreators !== &#39;object&#39; || actionCreators === null) {    throw new Error(      `bindActionCreators expected an object or a function, instead received ${        actionCreators === null ? &#39;null&#39; : typeof actionCreators      }. ` +        `Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?`    )  }  const boundActionCreators = {}  for (const key in actionCreators) {    const actionCreator = actionCreators[key]    if (typeof actionCreator === &#39;function&#39;) {      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)    }  }  return boundActionCreators}function bindActionCreator(actionCreator, dispatch) {  return function() {    return dispatch(actionCreator.apply(this, arguments))  }}</code></pre><p>它的逻辑非常简单，一个 actionCreator 可能是这样的：</p><pre><code class="language-js">const toggleLoading = () =&gt; ({  type: &#39;TOGGLE_LOADING&#39;})</code></pre><p>而一个 actionCreators 则是像下面这样：</p><pre><code class="language-js">const actions = {  toggleLoading() {    return {      type: &#39;TOGGLE_LOADING&#39;    }  } }</code></pre><p>所以 bindActionCreators 的效果则是接受一个 actionCreators 和 dispatch 方法，将它封装成一个对象，调用的时候可以直接把参数传给 actionCreators 并且把产生的 action 传递给 dispatch 来更新状态。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如此一来 Redux 的基本功能我们也都了解的差不多了，它的实现可以说非常简洁，主要的设计思想围绕着 reducer 和 dispatch。</p><p>另外 Redux 还提供了中间件的功能，可以辅助我们在传递 action 的时候做处理，由于跟主逻辑无关，我们放到另外一篇文章来讲。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> source code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PlantUML 简介</title>
      <link href="/2019/04/17/plantuml/"/>
      <url>/2019/04/17/plantuml/</url>
      
        <content type="html"><![CDATA[<p>相信很多人都尝试过不少画图工具，但要么是扩展性不强，要么支持的类型单一，有些在线的画图工具还要收费，而且一些框框线线拖来拖去，还要调整大小、字体、线条和位置各种繁琐的操作，回过头来才发现，你不就是为了梳理内容才要画图吗，怎么就不能专注于内容呢？</p><h2 id="画图工具对比"><a href="#画图工具对比" class="headerlink" title="画图工具对比"></a>画图工具对比</h2><p>下面我先介绍几个我尝试过的画图工具，以及使用体验：</p><table><thead><tr><th style="text-align:left">工具</th><th style="text-align:left">支持类型</th><th style="text-align:left">操作性</th><th style="text-align:left">外观</th><th style="text-align:left">导出格式</th><th>价格</th></tr></thead><tbody><tr><td style="text-align:left">ProcessOn</td><td style="text-align:left">流程图、类图、思维导图、状态图等</td><td style="text-align:left">一般/拖拽</td><td style="text-align:left">一般、高度自定义</td><td style="text-align:left">png/jpg/pdf/pos/svg</td><td>免费保存 5 个图</td></tr><tr><td style="text-align:left">MindNode/XMind</td><td style="text-align:left">思维导图</td><td style="text-align:left">简单/快捷键</td><td style="text-align:left">优秀</td><td style="text-align:left">png/pdf/text等</td><td>免费</td></tr><tr><td style="text-align:left">Markdown</td><td style="text-align:left">时序图、流程图</td><td style="text-align:left">简单/代码</td><td style="text-align:left">一般、固定样式</td><td style="text-align:left">无</td><td>扩展语法，免费但有限支持</td></tr><tr><td style="text-align:left">Keynote</td><td style="text-align:left">任意</td><td style="text-align:left">繁琐/拖拽</td><td style="text-align:left">优秀、高度自定义</td><td style="text-align:left">key</td><td>免费，限定 macOS</td></tr><tr><td style="text-align:left">PlantUML</td><td style="text-align:left">时序图、用例图、类图、流程图、状态图、对思维导图等</td><td style="text-align:left">简单/代码</td><td style="text-align:left">一般、有限自定义</td><td style="text-align:left">png/svg/text</td><td>开源 &amp; 免费</td></tr></tbody></table><a id="more"></a><p>就我自己的使用经验来说，ProcessOn 之类的专门画流程图的工具，线条框框拖拽起来太繁琐，很难专注于内容，而且样式一般。XMind 和 MindNode 虽然不错但只能画思维导图，列在这里是因为思维导图也是很重要的一种图。Keynote 虽然可以画出挺不错的图，但因为它本来最多算个作画工具而不是作图工具，所以线框和箭头之类都要自己画出来备用，操作繁琐。</p><p>Markdown 和 PlantUML 都是基于代码实时渲染绘图，对于一般人来说可能有点门槛，但对于程序员来说就不存在了。相比来说我比较喜欢这种方式，不用自己去拖拽线框的位置，逻辑顺序修改起来也非常方便。不过 Markdown 本身不支持作图，只有个别支持扩展语法的才能渲染出来，并且支持的类别也较少，语法也过于简单。所以接下来我们就要重点讲一下 PlantUML 和它的常规用法～</p><h2 id="PlantUML-简介"><a href="#PlantUML-简介" class="headerlink" title="PlantUML 简介"></a>PlantUML 简介</h2><p><a href="http://plantuml.com/zh/" target="_blank" rel="noopener">PlantUML</a> 是一个<a href="https://github.com/plantuml/plantuml" target="_blank" rel="noopener">开源项目</a>，支持从文本（代码）快速绘制 UML 图。</p><blockquote><p>UML-Unified Model Language 统一建模语言，又称标准建模语言。是用来对软件密集系统进行可视化建模的一种语言。</p></blockquote><p>目前已经支持的 UML 图：</p><ul><li><strong>时序图</strong></li><li>用例图</li><li>类图</li><li><strong>活动图</strong>（流程图）</li><li>组件图</li><li>状态图</li><li>对象图</li><li>部署图 </li><li>定时图 </li></ul><p>非 UML 图：</p><ul><li>线框图形界面</li><li>架构图</li><li>规范和描述语言 (SDL)</li><li>Ditaa 图</li><li>甘特图 </li><li><strong>思维导图</strong></li><li>工作分解结构图</li><li>以 AsciiMath 或 JLaTeXMath 符号的数学公式</li></ul><h2 id="常用图绘制"><a href="#常用图绘制" class="headerlink" title="常用图绘制"></a>常用图绘制</h2><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>时序图可以很直观地看到一个有序地操作流程</p><p>git-flow 流程图：</p><p><img src="/diagrams/git-flow/git-flow.svg" alt></p><p>下面我们来跟着一个 TCP 握手的时序图来学习它的一般用法</p><pre><code class="language-diagram">@startuml tcp-connectheader overloadingfooter copyright liangzrtitle TCP 握手协议actor client participant server order 2participant client order 1autonumberclient -&gt; server : SYNnote left  客户端向服务端发送连接请求报文段，  该报文段包含自身的数据通讯初始序号end noteserver -&gt; client : SYN + ACKnote right  服务端收到连接请求报文段后，如果同  意连接，刚会发送一个应答，该应答中  也会包含自身的数据通讯初始序号end noteclient -&gt; server : ACKnote left  客户端收到连接同意的应答后，还要向  服务端发送一个确认报文end note@enduml</code></pre><p><img src="/diagrams/tcp/tcp-connect.svg" alt></p><p><code>@startuml</code> 和 <code>@enduml</code> 用来表示大多数情况下 UML 图的开始与结束。</p><p><strong><code>角色A -&gt; 角色B : 过程</code> 这种语法表示了角色之间的过程信息</strong></p><p><code>actor client</code> 定义了 client 的角色：</p><ul><li>actor</li><li>boundary</li><li>control</li><li>entity</li><li>database</li><li>collections</li></ul><p>一共六种角色可以选择，也可以不指定角色</p><p><code>participant server order 2</code> 可以指定角色的排列顺序，数字小的排在左边</p><p><code>header</code>、<code>footer</code> 和 <code>title</code> 可以定义一些页面信息, <code>note</code> 可以给节点添加注释</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>流程图是最常用的图之一，可以直观形象地描述一个流程的详细过程</p><p>先来看一个 React 生命周期的简单流程图：</p><p><img src="/diagrams/react-lifestyle/react-lifestyle.svg" alt></p><p>这是一个最简单的流程图，下面我们来跟着一个 React 的组件挂载流程来认识一下完整的流程图写法</p><pre><code class="language-diagram">@startuml react-mounting|mountComponent挂载组件|start:初始化props和context;:执行构造函数获得实例;if (无状态组件OK) then (yes)   :渲染无状态组件;  note left    无状态组件没有状态更新队列    只专注于渲染  end noteendif:重新初始化类属性;note right  为类抽象兜底，即使用户  没有正确地调用 super()end note:初始化state;:初始化更新队列;note right  _pendingStateQueue = null  _pendingReplaceState = false  _pendingForceUpdate = falseend note|#FAEBD7|performIntialMount执行挂载|#82F49C:componentWillMount;if (更新队列不为空) then (yes)   :合并state;      note left    此时不会多次render  end noteendifif (无状态组件) then (no)   :创建Component实例;    endif#82F49C:递归render;note right  调用 ReactReconciler.mountComponent  递归地渲染子组件，子组件渲染成功后，父组件  才渲染完成end note|mountComponent挂载组件|#82F49C:componentDidMount;end@enduml</code></pre><p><img src="/diagrams/react-mounting/react-mounting.svg" alt></p><p>在流程图中，<strong><code>:过程;</code> 代表一个流程节点</strong></p><p>在 <code>#82F49C:过程;</code> 前面加颜色可以修改节点的默认背景色</p><p><code>|泳道A|</code> 语法可以创建一个泳道，需要注意的是，泳道的切换都需要主动声明</p><p><code>if</code> 逻辑判断语义化很好理解，不再赘述</p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p>思维导图虽然我还是更喜欢用 MindNode 来写，但是 PlantUML 生成的 svg 也许更适合放在文章中保存</p><p>它的语法也非常简单，我们直接来看个例子：</p><pre><code class="language-diagram">@startmindmaptitle JavaScript 结构* JavaScript** 运行时*** 数据结构**** 类型***** 7 种语言类型***** 7 种规范类型**** 实例（内置对象）*** 执行过程**** 事件循环**** 微任务执行**** 函数执行**** 语句执行** 文法*** 词法*** 语法** 语义@endmindmap</code></pre><p><img src="/diagrams/fed-mind/javascript.svg" alt></p><h2 id="插件支持"><a href="#插件支持" class="headerlink" title="插件支持"></a>插件支持</h2><p>PlantUML 的官方列举了很多在使用它的工具和网站，在这里我们以方便使用为目的，向大家介绍一个 VSCode 的 PlantUML 插件。</p><p>在 VSCode 市场或者软件内，搜索 <a href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml" target="_blank" rel="noopener"><code>PlantUML</code> 插件 / jebbs</a>，安装后需要在全局或者工作区配置参数：</p><p><code>.vscode/settings.json</code>:</p><pre><code class="language-json">{  &quot;plantuml.diagramsRoot&quot;: &quot;diagrams&quot;,  &quot;plantuml.exportOutDir&quot;: &quot;hexo/source/diagrams&quot;}</code></pre><p><code>plantuml.diagramsRoot</code> 代表放源文件的地方，而 <code>plantuml.exportOutDir</code> 则是输出渲染后的图片的地方</p><p><code>/diagrams</code> 目录结构:</p><pre><code class="language-console">├── git-flow.wsd├── react-lifestyle.wsd├── react-mounting.wsd├── react-receive-update.wsd├── react-set-state-pitfall.wsd├── react-unmounting.wsd└── tcp.wsd</code></pre><p><code>/hexo/source/diagrams</code> 目录结构：</p><pre><code class="language-console">├── git-flow│   └── git-flow.svg├── react-lifestyle│   └── react-lifestyle.svg├── react-mounting│   └── react-mounting.svg├── react-receive-update│   └── react-receive-update.svg├── react-set-state-pitfall│   └── react-set-state-pitfall.svg├── react-unmounting│   └── react-unmounting.svg└── tcp    ├── tcp-connect.svg    └── tcp-intro.svg</code></pre><p>按照插件官方的说明，如果需要在本地渲染，还需要指定<br>配置完还不能马上使用，把 plantuml 代码渲染到图形，你还需要一个渲染器。</p><p>有两种办法，一是使用本地渲染，但是需要安装以下两个依赖：</p><ul><li>Java : 运行 PlantUML</li><li>Graphviz : PlnatUML 需要用它来计算位置信息</li></ul><p>另一个办法是使用服务器渲染，建议在 VSCode 的<strong>全局配置</strong>中添加如下修改：</p><pre><code class="language-json">{  &quot;plantuml.server&quot;: &quot;http://server_host:port&quot;,  &quot;plantuml.render&quot;: &quot;PlantUMLServer&quot;}</code></pre><p><code>plantuml.server</code> 这一项替换成你自己的渲染服务器，如果还没有，你可以<a href="#搭建私服">搭建一个</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在配置的源文件路径中（也可以在任意位置的文件，但这样不能保存），新建一个 <code>demo.wsd</code> 文件，然后就可以编写 PlantUML 代码了</p><p>在编辑 PlantUML 代码块的时候，可以打开 <code>PlantUML: Preview Current Diagram</code> 窗口，它会根据你的代码<strong>实时渲染</strong>结果，使用私服的话，渲染速度非常的快</p><h3 id="使用渲染服务的优缺点"><a href="#使用渲染服务的优缺点" class="headerlink" title="使用渲染服务的优缺点"></a>使用渲染服务的优缺点</h3><p>优点：</p><ul><li>15 倍的导出速度和更快的预览速度</li><li>不需要设置本地变量</li><li>不需要设置并发量</li></ul><p>缺点：</p><ul><li>不能渲染特别大的图</li><li>不能渲染有 <code>!include</code> 的图</li><li>只支持 svg, png, txt 格式</li><li>一些自定义 plantuml 版本的选项将失效</li></ul><h2 id="搭建私服"><a href="#搭建私服" class="headerlink" title="搭建私服"></a>搭建私服</h2><p>不管怎么说，从稳定性和渲染效率上来说，我都倾向于搭建一个自己的渲染服务，而官方也提供了现成的 Docker 镜像可以一键启用（关于 Docker 如何使用不在本文章讨论范围内）</p><p>获取镜像：</p><pre><code class="language-shell">docker pull plantuml/plantuml-server:jetty</code></pre><p>启动服务：</p><pre><code class="language-shell">docker run -d -p 8001:8080 plantuml/plantuml-server:jetty</code></pre><p>使用 -p 参数将服务默认的 8080 端口转发到对应宿主机的端口上即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文只是 PlantUML 的简单入门介绍，可以带你快速上手，但对于它的功能的描述也只是冰山一角，更多的 UML 特性和 API 请直接查看<a href="http://plantuml.com" target="_blank" rel="noopener">PlantUML 官网文档</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是自身的价值</title>
      <link href="/2019/04/13/self-doubt/"/>
      <url>/2019/04/13/self-doubt/</url>
      
        <content type="html"><![CDATA[<p>身边人的认同，等于自身价值吗？</p><p>最近陷入了深度的自我怀疑。一直以来，我都对自己的能力非常有自信，虽然远没到自负，但内心也是自傲的。我会觉得自己比身边的人要强，而且即使现在我不如别人，不远的将来也会超过他们，将他们甩在身后。</p><a id="more"></a><p>在成长过程上，我绝对算不上一帆风顺，甚至是充满波折。但在这波折之中一个稳定的变化就是，<strong>我一直在超越曾经的对手或假想敌</strong>。我不是像某些人一样从小就成绩优异，最多只是在班里名列前茅，但也很少是最前面几个。小学时有个稳定的「对手」，他一直在年级稳坐第一，从一年级到五年级。之后我们一起跳级到了不同的初中，再后来得知他开始早恋逃课去网吧，第一个假想敌自爆了。在中学时，我的成绩也只在重点高中及格线上，班级里有不少人比我强，甚至我在 100 多名游离的时候，有几个动不动就是年级前十让我很是钦佩。到了考高中，我果然是勉强过线，跟这些假想敌一起上了高中，但到了高中之后，第一个月考就把这些敌人远远地甩在了身后，当然这跟我上了高中后痛定思痛地苦学一个月不无关系。</p><p>在高中的时候，因为文理分科，一直以来我的数理化优势体现了出来，成绩比以前好了不少。同时因为对一些文学名著感兴趣，语文也从全校（1300多人）1000 多名上升到了全市前 50，英语也在几年努力下达到了一般水平。即使这样，我也没有像某些人狂刷题，而是有条不紊地总结题型和经验。每过一个月就有一次的月考对别人来说是煎熬，对我来说却像放假一样，因为可以不用上课，考试提前完成还可以睡觉。这个时候我就已经觉得我的学习方式跟别人完全不同，我从不死读书，而是擅长总结规律，这也可能是理科爱好者的思维习惯。最后的高考成绩出来，虽然我的理综没有平时高，最擅长的数学也考的一般（对我来说就是考砸了），总的说来发挥算一般，但没有失常就是幸事。即使这样，最后的成绩依然把一些高中的假想敌甩在了身后。</p><p>上了大学后，渐渐地偏离了学术的道路，本来我也不是死读书的，喜欢动手实践，这也是理科乐趣的来源。从大一就参加了科协的社团，在大二参加了一个学长牵头的小组织——蠡湖电子实验室。这是一个学生自发组织，也申请（占用）了学院创新基地几间实验室，并且在内部组队参加各种比赛以及平日交流的小团体。要说特点就是物以类聚人以群分，这个小团体里面的很多人都是喜欢动手实践的，从此基本就泡在实验室有两年时间，也偏离了纯学术的道路，而以前我是认为自己一定会走上科研之路的。几年下来，参加了不少比赛和项目，积累了很多实战经验。虽然跟实验室的优秀同学比起来只能说一般，但跟班级的同学比起来，确实是大神级别的存在。我甚至觉得班级里的同学不学无术，对实践的掌握甚至不如我的十分之一，这绝不夸张，这让我对所谓 211 学校的学术氛围挺失望，还好我在一个很厉害的团体里面。</p><p>其实叙述了这么长的成长经历，这才引出我想讨论的点。从学习时代的「学神」，到大学之后的「大神」，甚至在后面参与到工作中时，<strong>身边人总能在短短地相处中觉得我是个「大神」</strong>。不管身处在什么环境中，总是能很快地让同学、朋友觉得我是个很厉害的人，而在家人亲戚眼里，也是一个有主见、能处理问题的人。</p><p><strong>其实我很清楚这是为什么</strong>，上面讲这么一段，绝不是为了吹嘘自己（接下来才是吹嘘自己，作者注），这是别人的印象。而从我自己的角度理解，我觉得相比一般人，我是一个很有探索欲和钻研精神的，遇到一些问题经常是孜孜不倦的找到解决方案，加上本就对身边事物的好奇心，长此以来养成了一种 geek 思维。别人觉得我是「大神」，可能是在生活、工作、行为或习惯各种方面的 geek 气息让他们认同。打字一般的人可能服气我的打字速度和考古专用五笔，电脑用的生疏的可能佩服外行看起来颇有点眼花缭乱的全键盘+Vim操作。聊起天来我也总知道一些一般人没去探究过的生活上的通识。但尤其是工作之后，这种身边人的认同让我并没有那么舒适，因为我清楚自己的实力是深是浅。</p><p>说白了，身边人对我的认同，来源于我这个人散发出的各种习惯也好，性格魅力也好，博识也好，但这跟技术又有多大关系呢？我越来越感到警觉。每次再有人叫我大神，我都会赶紧提醒自己认清自己的位置，千万不能让别人麻痹自己。</p><p>但不管怎么说，身边的人总是能很认同我，我不知道这能不能算作自己的价值，至于结论，还要配合下文来看。</p><hr><p>说完了自己的成长经历以及生活中别人对我的看法，再说说自己。</p><p>一直以来我也确实是很自信，也在做着超越别人的事，虽然后来我总结之后发现，我并没有太超速发展，而我的那些假想敌在掉队。一直以来我做到的是保持自己的竞争力，而我的假想敌却在一轮轮淘汰中一个个掉队了。后来因为考研和转行的风波，我也一定程度上掉队了，但我还是相信自己的能力，我觉得我能很快回到正轨。但现在有点怀疑自己了。</p><p>我们先来看个例子。假如一件事情正常的工作量是五天，我只需要花半天就可以完成，而一个普通人需要四天。但最后的结果是普通人可以在第四天提前一天完成，而我可能会到第六天上午延期完成。任务拖到后面，可能从质量上来讲我有信心比别人的好，或者至少是用心的，但没达到我自己的标准。最后这种结果会让我觉得，我用半天时间完成了别人四天的工作量，虽然我延期了，但是我比别人强。</p><p><strong>这或许是错觉</strong>？假如我不拖延的话，我就真的能在第一天的上午做完吗。又或者我只做半天，是不是根本忍受不了踏踏实实的工作四天，我的注意力就只能集中这么多，而最后的效率是被逼出来的，我真的很怀疑自己的能力到底如何。还有我以前经常晚上觉得精力旺盛，第二天还能起很早，一天都精神。但最近两天在看书学习，并且看书居多，十二点多还在坚持看，结果困的不行，看着看着就能睡着，床上一趴就睡着了，第二天六点起不来还得睡到七点半。</p><p>所以我的精力真的像之前感受的那样旺盛吗？在真正的高强度学习下，我也需要长时间的睡眠来恢复。六天才做完一个需求，别人四天搞定，<strong>从结果上来看还不如一般人</strong>。</p><hr><p>其实最后这两段结合起来，就非常地矛盾，我到底是强如大牛，还是菜而不自知。其实我现在主观上倾向于后者（本来我就是一个非常“擅长”自责的人），至少我觉得我的能力需要得到证明，否则我真的很难再有信心说我比别人强在哪里。</p><p>我这样想有点悲观，但越是在找工作的时候，越是觉得，即使你再有能力，身边的人如何认同你，<strong>你又怎么样才能在五分钟，或者一两个小时内，让一个陌生人做到同样程度的认同</strong>？碰到一个相谈甚欢的知己吗，这怕是有点难。按照最一般的套路，还是看产出，你的产出或者成果就代表了你的能力。</p><p>但乐观点想，为什么我可以有清晰的思路很快地找到问题的解决方案，为什么在遇到一个问题时我比别人更容易去探索这个问题的本质是什么。又或者在代码质量和架构的设计中，我都有信心不输别人。也许六天完成就只是懒或者拖延的毛病而已，也许睡七个半小时还是比别人要强，而长时间阅读需要习惯——就让我夸夸自己吧，我需要一点自信心。即使是现在，我依然觉得不管我最后去了哪家公司，也绝对不是拖油瓶，我有自信在一个团队中，半年内达到团队中的人实力的前 1/3，这也是为什么我想去更优秀的团队，这对我自己的提升也像是乘上了银河列车一样。</p><p>我依然能看到内心深处还有那份自傲，但现在这份骄傲蒙了尘，深深地藏在了自卑的情绪之下。不是一句话一篇文章或者什么事情就能让它回来，<strong>我需要沉淀，需要有产出去证明自己</strong>。</p><p>二〇一九年四月十三晚</p><blockquote><p>三天后就要去 b 站面试，谨以此文献给正在成长的自己，我需要多点自信 (゜-゜)つロ 干杯~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> writing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 的类型</title>
      <link href="/2019/04/08/js-type/"/>
      <url>/2019/04/08/js-type/</url>
      
        <content type="html"><![CDATA[<p>在接触一门语言之前，首先要了解的就是这门语言的语法和数据类型，在 JavaScript 中，变量都是动态类型的，每个变量的值都属于一种语言类型。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>JavaScript 规定了七种语言类型:</p><ol><li>Undefined</li><li>Null</li><li>Boolean</li><li>String</li><li>Number</li><li>Symbol</li><li>Object</li></ol><p>其中前六种为基本类型，Symbol 是 ES6 新加入的。可能你已经对这些基础的基础已经耳熟能详了，但是不是还有一些你不知道的细节呢？</p><a id="more"></a><blockquote><p>下面的内容会经常涉及值和变量，比如 undefined 值与 undefined 变量，关于这两种表示的区分请看<a href="#附录A">附录A</a></p></blockquote><h3 id="Undefined、Null"><a href="#Undefined、Null" class="headerlink" title="Undefined、Null"></a>Undefined、Null</h3><p>Undefined 类型表示未定义，任何变量在声明之后都是 Undefined 类型，Undefined 类型也只有一个值，就是 undefined。一般我们可以使用全局变量 <code>undefined</code> 来引用这个值</p><p>然而，在 JavaScript 中，<code>undefined</code> 是一个全局变量，而不是一个保留字。尽管在<strong>现代的浏览器中，这个全局变量是不可配置也不可写的</strong>，但它确实可以在内层作用域中被覆盖，比如：</p><pre><code class="language-js">function foo () {  var undefined = &#39;defined&#39;  console.log(undefined)}foo() // &#39;defined&#39;</code></pre><p>那如何保证我们引用的 undefined 一定没有被上层作用域修改过呢？</p><h4 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h4><p>我们可以使用 <code>window.undefined</code> 来获得 undefined 值，这样就可以直接跳过作用域链的查找，直接获取 JavaScript 引擎预定义的 <code>undefined</code> 变量。但这样就缺点就是每次都要使用 widnow 来引用这个值</p><h4 id="利用语法特性"><a href="#利用语法特性" class="headerlink" title="利用语法特性"></a>利用语法特性</h4><p>Undefined 类型在 JavaScript 代码中处处可见，引擎在很多时候也会返回 Undefined 类型来表示未定义，那我们就可以利用这种机制，来获取 undefined 值：</p><ul><li><strong>void 0</strong>：void 表示无返回，用 void 修饰在一个 RHS 表达式的前面，这个表达式最后返回的值就会是 undefined</li><li><strong>未初始化变量</strong>： 上面提到变量在声明之后，都是 Undefined 类型，所以我们可以声明一个变量，并且不对它初始化值</li><li><strong>无返回的函数</strong>：任何无返回的函数，都会返回一个 Undefined 类型</li></ul><p>例如：</p><pre><code class="language-js">console.log(void 0) // undefinedvar no_valueconsole.log(no_value) // undefinedconsole.log((function () {})()) // undefined</code></pre><p>Null 和 Undefined 在 JavaScript 中的含义是有差别的，它表示一个空引用的对象</p><p>Null 类型只有一个值 null，并且这个 JavaScript 中 null 是一个保留字，所以可以放心的引用它。</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Boolean 类型只有两个值，true 和 false，用于表示逻辑上的真和假，同样有两个关键字 true 和 false 来表示这两个值。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 用于表达文本数据，一段 String 数据其实是由一组 UTF16 编码的元素组成的，这样的元素最长有 2^53 - 1 个。</p><p>JavaScript 字符把每个 UTF16 单元当作一个字符来处理，而一个 UTF16 字符的编码范围在 0-65536（U+0000 - U+FFFF）之间，所以处理基本字符区域（BMP）之外的字符时，要格外小心长度问题。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Number 类型表示通常意义上的数字，对应数学中的有理数，但对于计算机来说，这个数值是有精度限制的。</p><p>JavaScript 中的 Number 类型有 2^64 - 2^53 + 3 个值，基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的场景，规定了几个例外的情况：</p><ul><li>NaN，占用了 9007199254740990，这个数字原本是符合 IEEE 规则的数字</li><li>Infinity，无穷大</li><li>-Infinity，负无穷大</li></ul><h4 id="浮点精度"><a href="#浮点精度" class="headerlink" title="浮点精度"></a>浮点精度</h4><p>在 IEEE 754 标准的 64 位 double 双精度浮点数中，符号（Sign）位占 1 位，指数（Exponent）位占 11 位，尾数（Mantissa）位占 52 位。由于是二进制的科学计数表示，实数位永远为 1，例如：</p><pre><code class="language-none">27 -&gt; 11011 -&gt; 1.1011 * 2^4S: 1E: 1023 + 4M: 1011</code></pre><p>在舍去了整数部分的 1 之后，尾数位为 1011，由此可以看出，Number 能表示的最大精度是 2^(52+1) - 1 ，也就是 9007199254740991（Number.MAX_SAFE_INTEGER），超过这个数字的整数就将丢失精度。</p><p>同样根据浮点数的定义，非整数的 Number 类型无法用 ==（或 ===） 来比较，下面看一个著名的问题：</p><pre><code class="language-js">console.log(0.1 + 0.2 == 0.3) // false</code></pre><p>这是因为如上所说的浮点精度的问题导致的，但这里错误的不是结论，因为这种误差在浮点运算中本来就存在，正确比较它们相等的办法是：</p><pre><code class="language-js">console.log(Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON) // true</code></pre><p>检查等式左右两边差的绝对值是否小于最小精度，才是正确比较浮点数的方法。</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol 是 ES6 中引入的类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。</p><p>Symbol 类型可以具体字符串类型的描述，但即使描述是相同的，Symbol 也不相等。可以用全局的 Symbol 函数创建 Symbol：</p><pre><code class="language-js">var s = Symbol(&#39;symbolA&#39;)</code></pre><p>在一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以用 <code>Symbol.iterator</code> 来自定义迭代器的行为：</p><pre><code class="language-js">var o = new Objecto[Symbol.iterator] = function() {    var v = 0    return {        next: function() {            return { value: v++, done: v &gt; 10 }        }    }        };for(var v of o)     console.log(v); // 0 1 2 3 ... 9</code></pre><p>代码中我们定义了对象的 <code>Symbol.iterator</code> 属性后，就可以使用 for…of 迭代这个对象了</p><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一，它表示对象，是一切有形和无形物体的总称。</p><p>在 JavaScript 中，对象的定义是<strong>属性的集合</strong>。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p><p>上面提到的几个基本类型，都有个对应的内置对象，分别是：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>Symbol</li></ul><p>所以，3 和 new Number(3) 是完全不同的两个值，一个是 Number 类型，一个是 Number 对象类型。</p><p>Number、String 和 Boolean 三个函数，既可以跟 new 搭配当作构造器，初始化一个对象，也可以直接调用，表示强制类型转换。</p><p>Symbol 函数则不能使用 new 初始化，直接调用 Symbol 函数会返回一个 Symbol 类型的值。</p><p>JavaScript 在语言设计中弱化了对象和基本类型之间的关系，比如我们可以直接在基本类型上使用相应对象的方法：</p><pre><code class="language-js">console.log(&#39;123&#39;.length) // 3</code></pre><p>甚至我们在相应原型上添加方法，也可以直接应用到基本类型上。这是因为运算符提供了一个装箱操作，它会根据基本类型构造一个临时对象，让我们可以在基本类型上调用对应对象的方法。</p><pre><code class="language-js">(123).toString() // &#39;123&#39;123.toString() // Uncaught SyntaxError: Invalid or unexpected token</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>因为 JavaScript 是弱类型的语言，所以在很多情况下都会进行类型转换，尤其是一些运算场景。</p><p>虽然大部分的转换符合我们的直觉，但隐式转换带来的失误依然不可忽视，其实最著名的就是 <code>==</code> 运算符，它试图跨类型比较，规划复杂到没人记得住，甚至还有人专门总结了 JavaScript 真值表来辅助记忆。但这里我认为，在大多数场景下，我们应该尽量避免类型的隐式转换，隐式转换的过程较为隐匿，可读性也差。</p><p>除此之外，如加减乘除和比较运算，也都会涉及类型转换，这种情况的类型转换还是相对简单的：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g1xljiojnwj30vb0cftai.jpg" alt></p><p>在这里面较为复杂的是 Number 和 String 之间的转换，以前对象跟基本类型之间的转换，我们来分别看一下这几种转换的规则。</p><h3 id="StringToNumber"><a href="#StringToNumber" class="headerlink" title="StringToNumber"></a>StringToNumber</h3><p>字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：</p><ul><li>30</li><li>0b111</li><li>0o12</li><li>0xFF</li></ul><p>此外，JavaScript 支持的字符串语法还包括正负号的科学计数法，可以用 E 或 e 来表示：</p><ul><li>1e3</li><li>-1e-2</li></ul><p>需要注意的是，parseInt 和 parseFloat 并不支持这个转换，支持的语法也不相同。在不传入第二个参数的情况下，parseInt 只支持 16 进制的 0x 前缀，而且会忽略非数字字符，也不支持科学计数法，所以在任何情况下，都建议传入 parseInt 的第二个参数，而 parseFloat 则只支持十进制。</p><p>所以在多数情况下，使用 Number 方法是比 parseInt 和 parseFloat 更好的选择。</p><h3 id="NumberToString"><a href="#NumberToString" class="headerlink" title="NumberToString"></a>NumberToString</h3><p>在较小的范围里，数字到字符串的转换完全符合你直觉的表示，而当 Number 绝对值较大或较小时，则会用科学计数法表示。</p><h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>Number、String、Boolean、Symbol 这几种基本类型在对象中都有其对应的类，所以装箱转换，正是把基本类型转换成对应的对象，这在很多语言中都能见到。</p><p>Symbol 函数无法使用 new 来调用，但我们也可以利用装箱机制来得到一个 Symbol 对象，比如用函数的 call 方法来强迫产生装箱。</p><pre><code class="language-js">var symbolObj = (function () { return this }).call(Symbol(&#39;a&#39;))console.log(typeof symbolObj) // &#39;object&#39;console.log(symbolObj.description) // &#39;a&#39;console.log(symbolObj instanceof Symbol) // true</code></pre><p>装箱机制会频繁地产生临时对象，在一些对性能有要求的场景下，我们应该尽量避免对基本类型做装箱转换</p><p>使用内置的 Object 函数，我们可以在 JavaScript 代码中显式的调用装箱能力</p><pre><code class="language-js">var symbolObj = Object(Symbol(&#39;a&#39;))console.log(typeof symbolObj) // &#39;object&#39;console.log(symbolObj.description) // &#39;a&#39;console.log(symbolObj instanceof Symbol) // true</code></pre><p>每一类装箱对象都有私有的 Class 属性，这个属性可以用 Object.prototype.toString 获取：</p><pre><code class="language-js">var symbolObj = Object(Symbol(&#39;a&#39;))console.log(Object.prototype.toString.call(symbolObj)) // [object Symbol]</code></pre><p>Class 属性是 JavaScript 引擎的私有属性，没有任何方法可以改变这个值，相比 typeof 和 instanceof，它可以准确地显示对象对应的类型，更为准确。</p><p>不过需要注意的是，由于 call 本身会导致装箱操作，如果要判断一个值是不是基本类型，以及是哪个基本类型，还需要配置 typeof 来区分。</p><pre><code class="language-js">var symbolObj = Object(Symbol(&#39;a&#39;))var symbol = Symbol(&#39;a&#39;)console.log(typeof symbolObj) // &#39;object&#39;console.log(Object.prototype.toString.call(symbolObj)) // [object Symbol]console.log(typeof symbol) // &#39;symbol&#39;console.log(Object.prototype.toString.call(symbol)) // [object Symbol]</code></pre><h3 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h3><p>在 JavaScript 标签中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换。</p><p>对象到 String 和 Number 的转换都遵循先<strong>先拆箱再转换</strong>的原则。通过拆箱转换，把对象转换为基本类型，再从基本类型转换为对应的 String 或 Number。</p><p>拆箱转换会尝试调用 valueOf 或 toString 来获取拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会抛出类型错误 TypeError。</p><pre><code class="language-js">var o = {  valueOf ()  {    console.log(&#39;valueOf&#39;)    return {}  }  toString ()  {    console.log(&#39;toString&#39;)    return {}  }}o * 2// valueOf// toString// TypeError</code></pre><p>如果是到 String 的拆箱，则会优先调用 toString:</p><pre><code class="language-js">var o = {  valueOf ()  {    console.log(&#39;valueOf&#39;)    return {}  },  toString ()  {    console.log(&#39;toString&#39;)    return {}  },}String(o)// toString// valueOf// TypeError</code></pre><p>在 ES6 之后，我们可以通过 Symbol 显式的覆盖默认行为：</p><pre><code class="language-js">var o = {  valueOf ()  {    console.log(&#39;valueOf&#39;)    return {}  },  toString ()  {    console.log(&#39;toString&#39;)    return {}  },  [Symbol.toPrimitive] () {    console.log(&#39;toPrimitive&#39;)    return &#39;hello&#39;  }}console.log(o + &#39;&#39;)// toPrimitive// hello</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上七种类型就是 JavaScript 的七种语言类型，除此之外，还有七种规范类型：</p><ul><li>List 和 Record：用于描述函数的传参过程</li><li>Set：主要用于解释字符集等</li><li>Completion Record：用于描述异常、跳出语句执行过程</li><li>Reference：用于描述对象属性访问、delete 等</li><li>Property Descriptor：用于描述对象的属性</li><li>Lexical Environment 和 Enviorment Record：用于描述变量和作用域</li><li>Data Block：用于描述二进制数据</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="附录A"><a href="#附录A" class="headerlink" title="附录A"></a>附录A</h3><p>在 JavaScript 语法中，LHS/RHS 是 Left/Right-Hand Side 的缩写，意思是要被赋值的变量（LHS）和变量要被赋的值（RHS）</p><pre><code class="language-js">var a = 1var b = a + 1</code></pre><p>在上面这两行语句中，<code>var a = 1</code> 可以分为 <code>var a; a = 1</code> 在这里 <code>a</code> 就是一个 LHS，而 <code>1</code> 和 <code>a + 1</code> 是一个 RHS。所以如果是 undefined</p><pre><code class="language-js">console.log(a === undefined)</code></pre><p>undefined 并不是 JavaScript 的保留字，所以这里的 undefined 只是一个变量，而 null 则是保留字，不可作为变量名</p><pre><code class="language-js">null = 1 // Uncaught ReferenceError: Invalid left-hand side in assignmentundefined = 1 // 11 = 1 // Uncaught ReferenceError: Invalid left-hand side in assignment </code></pre><p>可以看到所有值类型都不可作为 LHS</p><p>更多有关 LHS/RHS 的理解请参考<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md" target="_blank" rel="noopener">Scope &amp; Closures - You Dont Know JS</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://time.geekbang.org/column/article/78884" target="_blank" rel="noopener">JavaScript类型：关于类型，有哪些你不知道的细节？- 重学前端</a></li><li><a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types" target="_blank" rel="noopener">6.1 ECMAScript Language Types - ECMA262</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">JavaScript data types and data structures - MDN</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> basic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML 的元信息标签</title>
      <link href="/2019/04/07/html-head-meta/"/>
      <url>/2019/04/07/html-head-meta/</url>
      
        <content type="html"><![CDATA[<p>一个 HTML 文档通常有一组标签来描述文档自身的信息，供搜索引擎或浏览器去读取以更好地渲染页面，这就是元信息标签。</p><h2 id="元信息标签的结构"><a href="#元信息标签的结构" class="headerlink" title="元信息标签的结构"></a>元信息标签的结构</h2><p>一般来说，元信息标签都会放在 HTML 的 head 标签之内，其中又包括 base、meta 和 title 等具体的元信息，当然也包括和 script 和 style 相关的 script 和 link 等标签，下面我就逐一看下它们的使用场景。</p><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>head 规定了自身必须为 html 的第一个元素，并且必须包含一个 title 标签，最多包含一个 base 标签。</p><blockquote><p>如果文档作为一个 iframe 存在，或者有其它更高级地方式指定了文档的标题（比如 HTML 邮件的主题部分），则允许不包含 title 标签。</p></blockquote><a id="more"></a><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p>base 标签用来为文档中所有的<strong>相对路径的链接</strong>指定了一个 baseURL，并且一个文档中只能有一个 base 标签。</p><p>base 标签有 <code>href</code> 和 <code>target</code> 两个属性：</p><ul><li><strong>href:</strong> 用于相对路径的链接的 baseURL，如果指定了这个元素，则 base 必须放在任何具有 URL 值的标签之前。可以使用相对或绝对路径</li><li><strong>target:</strong> 用来指定当文档的链接或 form 导致的跳转时的位置，对没有指定 <code>target</code> 属性的元素有效<ul><li>_self: 默认值，在当前页载入新页面</li><li>_blank: 在新标签（页面）载入新页面</li><li>_parent: 在父页面载入新页面，如果没有父页面，与 _self 同样在当前页面载入</li><li>_top: 同 _parent 行为类似，_top 指定的是最顶级的父页面</li></ul></li></ul><blockquote><p>如果有多个 base 标签被指定，只有第一个出现的 href 和 target 会生效</p></blockquote><p>例如有下面一个页面结构:</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;title&gt;test&lt;/title&gt;  &lt;base href=&quot;http://baidu.com&quot; target=&quot;_blank&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;a href=&quot;/favicon.ico&quot;&gt;    &lt;img src=&quot;/favicon.ico&quot;&gt;   &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img style="max-width: 500px; " src="https://ws2.sinaimg.cn/large/006tNc79ly1g1u1cdr77mj30om0f6aec.jpg"></p><p>可以看到，网站的图标和 img 标签内的图片，都变成了百度的图标，a 链接复制出来也是 <code>http://baidu.com/favicon.ico</code></p><p><strong>在实际使用中，并不建议使用 base 标签，它改变了全局相对链接的地址，容易在跟 JavaScript 配合时出现问题</strong></p><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>title 标签作为文档的元信息，用来简单的概括文档的主题，显示在浏览器的头部或者标签上。title 标签内只允许普通文本，放入标签会被忽略。</p><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><p>meta 标签是一组键值对，作为其它元标签的补充，表示通用的文档的元信息</p><p>在 head 中可以有任意多个 mete 标签，一般的 mete 标签由 name 和 content 两个属性来定义。name 表示元信息的名，content 用来表示元信息的值。</p><p>name 是一种比较自由的约定，HTML 规定了一些 name 作为大家的共识，也鼓励大家发明自己的 name 来使用。除了基本用法，meta 标签还有一些变体用来简化书写方式或声明自动化武行为，例如 charset、http-equiv 等</p><h2 id="meta-标签变体"><a href="#meta-标签变体" class="headerlink" title="meta 标签变体"></a>meta 标签变体</h2><h3 id="viewport-作为-name-属性"><a href="#viewport-作为-name-属性" class="headerlink" title="viewport 作为 name 属性"></a>viewport 作为 name 属性</h3><p>viewport 属性并没有在 HTML 标准中定义，却是移动端开发的事实标准</p><table><thead><tr><th style="text-align:left">键</th><th style="text-align:left">取值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">width</td><td style="text-align:left">正数，或者 ‘device-width’</td><td style="text-align:left">定义视图的像素宽度</td></tr><tr><td style="text-align:left">height</td><td style="text-align:left">正数，或者 ‘device-height’</td><td style="text-align:left">定义视图的像素高度</td></tr><tr><td style="text-align:left">initial-scale</td><td style="text-align:left">0.0-1.0 之间的数字</td><td style="text-align:left">定义视力的初始缩放比例</td></tr><tr><td style="text-align:left">maximum-scale</td><td style="text-align:left">0.0-1.0 之间的数字</td><td style="text-align:left">定义视力的最大缩放比例</td></tr><tr><td style="text-align:left">minimum-scale</td><td style="text-align:left">0.0-1.0 之间的数字</td><td style="text-align:left">定义视力的最小缩放比例</td></tr><tr><td style="text-align:left">user-scalable</td><td style="text-align:left">‘yes’ 或 ‘no’</td><td style="text-align:left">如果定义为 ‘no’，则不允许用户缩放页面。浏览器可能会忽略此规则，iOS10+ 默认忽略</td></tr></tbody></table><h3 id="charset-属性"><a href="#charset-属性" class="headerlink" title="charset 属性"></a>charset 属性</h3><p>从 HTML5 开始，为了简化写法 meta 新增了 charset 属性，可以指定 HTML 文档的编码格式，<strong>建议将其放在整个 head 标签内的第一位</strong>。</p><pre><code class="language-html">&lt;meta charset=&quot;UTF-8&quot;&gt;</code></pre><p>一般情况下，http 服务端会通过 http 头来指定正确的编码方式，但是有些特殊的情况如使用 file 协议打开一个 HTML 文件，则没有 http 头，这种时候，charset meta 就非常重要了。</p><h3 id="http-equiv-属性"><a href="#http-equiv-属性" class="headerlink" title="http-equiv 属性"></a>http-equiv 属性</h3><p>http-equiv 属性用来指定一个编译命令。之所以叫 http-equiv，是因为所有允许的值，都是特定的 HTTP 头的名字</p><ul><li><strong>content-type</strong><ul><li>它用来定义文档的 MIME 类型，后面可以跟一个字符编码。</li><li>🔴<strong>不推荐</strong>，由于 html 文档基本也只支持 <strong>text/html</strong> 这一种类型，所以不如用 charset 属性来代替这个 http 头</li></ul></li><li><strong>x-ua-compatible</strong><ul><li>声明 UA 兼容性 </li><li>✅<strong>推荐</strong> </li></ul></li><li><strong>content-language</strong> <ul><li>用来指定文档的语言 </li><li>🔴<strong>不推荐</strong>，优先使用 html 标签的 <strong>lang</strong> 属性 |</li></ul></li><li><strong>content-security-policy</strong> <ul><li>允许页面作者为当前页面定义内容策略。内容策略主要指定允许的服务器源和脚本端点，以帮助防止跨站点脚本攻击。</li><li>✅<strong>推荐</strong> </li></ul></li><li><strong>refresh</strong> <ul><li>刷新或重定向页面</li><li>✅<strong>推荐</strong> |</li></ul></li><li><strong>set-cookie</strong> <ul><li>为页面定义 Cookie，需要符合 HTTP 的标准 </li><li>🔴<strong>不推荐</strong>，建议使用 HTTP 的 <strong>set-cookie</strong> 头来代替它 </li></ul></li></ul><h2 id="应用场景示例"><a href="#应用场景示例" class="headerlink" title="应用场景示例"></a>应用场景示例</h2><h3 id="移动端设备缩放"><a href="#移动端设备缩放" class="headerlink" title="移动端设备缩放"></a>移动端设备缩放</h3><p>浏览器的 viewport 是可以看到Web内容的窗口区域，通常与渲染出的页面的大小不同，这种情况下，浏览器会提供滚动条以滚动访问所有内容。Apple 在 Safari iOS 中引入了“viewport meta 标签”，让Web开发人员控制视口的大小和比例。</p><p>移动端常用 viewport 写法示例：</p><pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;</code></pre><h3 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h3><p>SEO（Search Engine Optimization）:汉译为搜索引擎优化。搜索引擎优化是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。</p><h4 id="keywords-和-description"><a href="#keywords-和-description" class="headerlink" title="keywords 和 description"></a>keywords 和 description</h4><p>keywords 和 decription 是最常见的两个 meta 标签，用来标识一个页面的基本信息与关键字，方便搜索引擎来检索，可以提高被搜索引擎收录的效果。</p><p><a href="https://www.ithome.com" target="_blank" rel="noopener">IT 之家</a> 页面的 meta:</p><pre><code class="language-html">&lt;meta name=&quot;description&quot; content=&quot;IT之家，青岛软媒旗下，IT科技门户网站。快速精选IT新闻，实时报道科技周边，关注苹果iOS、谷歌Android、微软Windows Phone，紧盯iPhone/iPad、安卓智能设备、WP手机等数码潮流。技术资讯、攻略教程、资源下载 - IT人的生活，尽在IT之家，爱IT，爱这里。&quot; /&gt;&lt;meta name=&quot;keywords&quot; content=&quot;IT新闻,互联网,Internet,数码,科技,科普,通信,智能手机,IT之家,ithome,软媒&quot; /&gt;</code></pre><p>百度搜索 IT 之家：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g1u47z6xjwj30w407gq5c.jpg" alt></p><p>Google 搜索 IT 之家：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g1u48pgncgj30y006eac4.jpg" alt></p><p>可以看到搜索引擎对网站的描述信息都来自 meta 里的 description。（🐷百度还把中文逗号转换成了英文逗号）</p><h4 id="社交媒体优化"><a href="#社交媒体优化" class="headerlink" title="社交媒体优化"></a>社交媒体优化</h4><p>我们先来看下 hexo 为这篇文章生成的 meta 信息</p><pre><code class="language-html">&lt;meta name=&quot;description&quot; content=&quot;一个 HTML 文档通常有一组标签来描述文档自身的信息，供搜索引擎或浏览器去读取以更好地渲染页面，这就是元信息标签。 元信息标签的结构一般来说，元信息标签都会放在 HTML 的 head 标签之内，其中又包括 base、meta 和 title 等具体的元信息，当然也包括和 script 和 style 相关的 script 和 link 等标签，下面我就逐一看下它们的使用场景。 headhead&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;head meta&quot;&gt;&lt;meta property=&quot;og:type&quot; content=&quot;article&quot;&gt;&lt;meta property=&quot;og:title&quot; content=&quot;HTML 的元信息标签&quot;&gt;&lt;meta property=&quot;og:url&quot; content=&quot;https://blog.liangzr.tech/2019/04/07/html-head-meta/index.html&quot;&gt;&lt;meta property=&quot;og:site_name&quot; content=&quot;OVERLOADING 🔥&quot;&gt;&lt;meta property=&quot;og:description&quot; content=&quot;一个 HTML 文档通常有一组标签来描述文档自身的信息，供搜索引擎或浏览器去读取以更好地渲染页面，这就是元信息标签。 元信息标签的结构一般来说，元信息标签都会放在 HTML 的 head 标签之内，其中又包括 base、meta 和 title 等具体的元信息，当然也包括和 script 和 style 相关的 script 和 link 等标签，下面我就逐一看下它们的使用场景。 headhead&quot;&gt;&lt;meta property=&quot;og:locale&quot; content=&quot;default&quot;&gt;&lt;meta property=&quot;og:image&quot; content=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1g1u1cdr77mj30om0f6aec.jpg&quot;&gt;&lt;meta property=&quot;og:updated_time&quot; content=&quot;2019-04-07T07:15:56.797Z&quot;&gt;&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;&gt;&lt;meta name=&quot;twitter:title&quot; content=&quot;HTML 的元信息标签&quot;&gt;&lt;meta name=&quot;twitter:description&quot; content=&quot;一个 HTML 文档通常有一组标签来描述文档自身的信息，供搜索引擎或浏览器去读取以更好地渲染页面，这就是元信息标签。 元信息标签的结构一般来说，元信息标签都会放在 HTML 的 head 标签之内，其中又包括 base、meta 和 title 等具体的元信息，当然也包括和 script 和 style 相关的 script 和 link 等标签，下面我就逐一看下它们的使用场景。 headhead&quot;&gt;&lt;meta name=&quot;twitter:image&quot; content=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1g1u1cdr77mj30om0f6aec.jpg&quot;&gt;</code></pre><p>可以看到有两种标签我们没有见过，分别是 <code>name=&quot;twitter:x&quot;</code> 和 <code>property=&quot;og:x&quot;</code>，下面就分别看下这两个是什么用途</p><p><a href="ogp.me">Open Graph协议</a>是由 Facebook 推出的，使任何网页都成为社交图中的丰富对象。例如，这在Facebook上用于允许任何网页具有与Facebook上的任何其他对象相同的功能。</p><p>可以理解为，当你分享一个网页到 Facebook 中时，即使它不是 Facebook 自己的网页，也可以有足够的信息像展示预览 Facebook 自己的网页具有更丰富的信息。</p><p>同理 twitter 也推出了自己的<a href="https://developer.twitter.com/en/docs/tweets/optimize-with-cards/guides/getting-started.html" target="_blank" rel="noopener">卡片优化协议</a>，提升了 Twitter 上的整体卡片体验，每种卡片类型都支持并需要一组特定的属性。</p><h3 id="其它-meta-功能"><a href="#其它-meta-功能" class="headerlink" title="其它 meta 功能"></a>其它 meta 功能</h3><ul><li>application-name: 定义应用名称</li><li>author: 页面作者</li><li>generator: 生成页面所使用的工具，主要用于可视化编辑器，如果是手写 HTML 的网页，不需要加这个 meta</li><li>referrer: 跳转策略，是一种安全考量</li><li>theme-color: 页面风格颜色，实际并不会影响页面，但是浏览器可能据此调整页面之外的 UI（如窗口边框或者 tab 的颜色）</li><li>robots: 定义页面的爬虫行为</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://time.geekbang.org/column/article/82711" target="_blank" rel="noopener">HTML元信息类标签：你知道head里一共能写哪几种标签吗？- 重学前端</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag" target="_blank" rel="noopener">在移动浏览器中使用viewport元标签控制布局 - MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta" target="_blank" rel="noopener">meta - MDN</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
          <category> element </category>
          
      </categories>
      
      
        <tags>
            
            <tag> head meta </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 的语义化标签</title>
      <link href="/2019/04/06/html-sematic-markup/"/>
      <url>/2019/04/06/html-sematic-markup/</url>
      
        <content type="html"><![CDATA[<p>在 HTML 里，<code>div</code> 和 <code>span</code> 分别作为块元素和行内元素的代表，可以满足绝大多数情况下我们的需求，但有理想的前端工程师还应该去追求更优雅的<strong>语义化标签</strong>。</p><h2 id="什么是语义化标签"><a href="#什么是语义化标签" class="headerlink" title="什么是语义化标签"></a>什么是语义化标签</h2><p>语义化标签在视觉表现上和常见的 <code>div</code> 和 <code>span</code> 并没有太大区别，关键就在于不同的语义化标签代表了不同的语义，比如经常见到的 <code>header</code>、<code>footer</code>、<code>section</code> 等等。</p><p>语义指的是对单词或句子含义的正确解释，很多时候一段内容的语义由内容里的文字来承担，但有些时候文字也无法表达类似段落、页首、页尾或侧边栏等内容，这个时候就需要语义化标签来代为补充了</p><p>虽然很多场景下，<code>div</code> 和 <code>span</code> 已经足够使用，但语义化标签也有下面这些不可替代的优点：</p><ul><li>对开发者友好。增强了代码的可读性，即使在没有 CSS 的时候，也可以清晰地看出页面的结构，方便后期团队维护</li><li>方便程序自动化。有语义的标签很大程度上方便了机器阅读分析页面结构和内容，适合搜索引擎检索、页面转码转义、爬虫分析、视障辅助等程序自动化操作</li></ul><p>虽然语义化标签带来了很多好处，但有时候也没必要过分追求。不恰当地使用语义化标签还会造成大量冗余标签，语义化标签自带的样式也会给 CSS 的编写增加负担。引用 <em>winter</em> 老师的一句总结：<strong>用对”比“不用”好，“不用”比“用错”好。当然了，我觉得有理想的前端工程师还是应该去追求“用对”它们</strong></p><a id="more"></a><h2 id="常见的语义化标签"><a href="#常见的语义化标签" class="headerlink" title="常见的语义化标签"></a>常见的语义化标签</h2><p>在列举常见的语义化标签之前，我们先按它们出现的原因对其分类，分别为：</p><ul><li>作为自然语言的延伸</li><li>为内容分区</li><li>标记文本类型</li></ul><p>下面将列表一下这三种情况下的语义化标签的用法，多数内容节选自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element" target="_blank" rel="noopener">《HTML 元素参考 - MDN》</a>，这里只列出相对重要且常用的语义化标签，完整查阅请参考 MDN</p><h3 id="作为自然语言的延伸"><a href="#作为自然语言的延伸" class="headerlink" title="作为自然语言的延伸"></a>作为自然语言的延伸</h3><p>本节下面的语义化标签，很多情况下用来辅助表达自然语言表述不够准确的场景。比如 <code>&lt;em&gt;</code> 标签可以帮助消除句子中的歧义，例如：”我昨天去超市了”，这句话可以理解为：”我昨天去了超市，但今天没去”，也可以理解为：”我昨天去了超市，而不是别的地方”，关键在于重音在<strong>昨天</strong>还是<strong>超市</strong>，这个时候就可以用 <code>&lt;em&gt;</code> 标签来消除歧义，比如：<code>我&lt;em&gt;昨天&lt;/em&gt;去超市了</code>。</p><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">MDN 描述</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;abbr&gt;</code></td><td style="text-align:left">HTML 缩写元素（<code>&lt;abbr&gt;</code>）用于展示缩写，并且可以通过可选的 title 属性提供完整的描述。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;b&gt;</code></td><td style="text-align:left">HTML提醒注意（Bring Attention To）元素（<code>&lt;b&gt;</code>）用于吸引读者的注意到该元素的内容上（如果没有另加特别强调）。这个元素过去被认为是粗体（Boldface）元素，并且大多数浏览器仍然将文字显示为粗体。尽管如此，你不应将<code>&lt;b&gt;</code>元素用于显示粗体文字；替代方案是使用 CSS font-weight 属性来创建粗体文字。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;cite&gt;</code></td><td style="text-align:left">HTML引用（ Citation）标签 (<code>(&lt;cite&gt;</code>) 表示一个作品的引用。它必须包含引用作品的符合简写格式的标题或者URL，它可能是一个根据添加引用元数据的约定的简写形式。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;code&gt;</code></td><td style="text-align:left">HTML<code>&lt;code&gt;</code>元素呈现一段计算机代码. 默认情况下, 它以浏览器的默认等宽字体显示.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;data&gt;</code></td><td style="text-align:left">HTML<code>&lt;data&gt;</code>元素 将一个指定内容和机器可读的翻译联系在一起。但如果内容是与 time 或者 date 相关的，一定要使用 <code>&lt;time&gt;</code>。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;dfn&gt;</code></td><td style="text-align:left">HTML 定义元素 (<code>(&lt;dfn&gt;</code>) 表示术语的一个定义。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;em&gt;</code></td><td style="text-align:left">HTML 着重元素 (<code>(&lt;em&gt;</code>) 标记出需要用户着重阅读的内容，<code>&lt;em&gt;</code>元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。</td><td style="text-align:left">对应汉语中重读的意思，可以用来消除句子中的歧义</td></tr><tr><td style="text-align:left"><code>&lt;i&gt;</code></td><td style="text-align:left">HTML元素<code>&lt;i&gt;</code>用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。</td><td style="text-align:left">现在经常被用来表示一些图标</td></tr><tr><td style="text-align:left"><code>&lt;kbd&gt;</code></td><td style="text-align:left">HTML键盘输入元素(<code>(&lt;kbd&gt;</code>) 用于表示用户输入，它将产生一个行内元素，以浏览器的默认monospace字体显示。</td><td style="text-align:left">一般用来标记键盘按键</td></tr><tr><td style="text-align:left"><code>&lt;q&gt;</code></td><td style="text-align:left">HTML引用标签 (<code>(&lt;q&gt;</code>)表示一个封闭的并且是短的行内引用的文本. 这个标签是用来引用短的文本，所以请不要引入换行符; 对于长的文本的引用请使用<code>&lt;blockquote&gt;</code>替代.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;ruby&gt;</code></td><td style="text-align:left">HTML<code>&lt;ruby&gt;</code>元素 被用来展示东亚文字注音或字符注释。</td><td style="text-align:left">比如，你（wo）太强（cai）了</td></tr><tr><td style="text-align:left"><code>&lt;s&gt;</code></td><td style="text-align:left">HTML<code>&lt;s&gt;</code>元素 使用删除线来渲染文本。使用<code>&lt;s&gt;</code>元素来表示不再相关，或者不再准确的事情。但是当表示文档编辑时，不提倡使用<code>&lt;s&gt;</code>；为此，提倡使用<code>&lt;del&gt;</code>和<code>&lt;ins&gt;</code>元素。</td><td style="text-align:left">会被用于电商网站表示曾售价</td></tr><tr><td style="text-align:left"><code>&lt;samp&gt;</code></td><td style="text-align:left"><code>&lt;samp&gt;</code> 元素用于标识计算机程序输出，通常使用浏览器缺省的 monotype 字体（例如 Lucida Console）。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;small&gt;</code></td><td style="text-align:left">HTML 中的元素將使文本的字体变小一号。(例如从大变成中等，从中等变成小，从小变成超小)。在HTML5中，除了它的样式含义，这个元素被重新定义为表示边注释和附属细则，包括版权和法律文本。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;strong&gt;</code></td><td style="text-align:left">Strong 元素 (<code>(&lt;strong&gt;</code>)表示文本十分重要，一般用粗体显示。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;sub&gt;</code></td><td style="text-align:left">HTML<code>&lt;sub&gt;</code>元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更低并且更小。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;sup&gt;</code></td><td style="text-align:left">HTML<code>&lt;sup&gt;</code>元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;u&gt;</code></td><td style="text-align:left">HTML<code>&lt;u&gt;</code>元素使文本在其内容的基线下的一行呈现下划线。在HTML5中, 此元素表示具有未标注的文本跨度，显示渲染，非文本注释，例如将文本标记为中文文本中的专有名称(一个正确的中文标记), 或 将文本标记为拼写错误。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;time&gt;</code></td><td style="text-align:left">HTML time 标签(<code>(&lt;time&gt;</code>) 用来表示24小时制时间或者公历日期，若表示日期则也可包含时间和时区。</td><td style="text-align:left">注意跟 data 的区别</td></tr></tbody></table><h3 id="为内容分区"><a href="#为内容分区" class="headerlink" title="为内容分区"></a>为内容分区</h3><p>为内容分区的情况比较常见，也是很多前端用的最多的语义化标签了。通过下面这些标签，可以很方便地对整个页面结构进行分区分块。</p><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">MDN 描述</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;address&gt;</code></td><td style="text-align:left">HTML 的<code>&lt;address&gt;</code>元素可以让作者为它最近的<code>&lt;article&gt;</code>或者<code>&lt;body&gt;</code>祖先元素提供联系信息。在后一种情况下，它应用于整个文档。</td><td style="text-align:left">每个 <code>&lt;article&gt;</code> 或 <code>&lt;body&gt;</code> 内只能出现一次</td></tr><tr><td style="text-align:left"><code>&lt;article&gt;</code></td><td style="text-align:left"><code>&lt;article&gt;</code>元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。</td><td style="text-align:left">和 body 属于同一级别的标签，所以它也可以有自己的 <code>&lt;header&gt;</code> 和 <code>&lt;footer&gt;</code></td></tr><tr><td style="text-align:left"><code>&lt;aside&gt;</code></td><td style="text-align:left"><code>&lt;aside&gt;</code> 元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;footer&gt;</code></td><td style="text-align:left">HTML <code>&lt;footer&gt;</code> 元素表示最近一个章节内容或者根节点（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;header&gt;</code></td><td style="text-align:left">HTML <code>&lt;header&gt;</code> 元素用于展示介绍性内容，通常包含一组介绍性的或是辅助导航的实用元素。它可能包含一些标题元素，但也可能包含其他元素，比如 Logo、搜索框、作者名称，等等。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, <code>&lt;h4&gt;</code>, <code>&lt;h5&gt;</code>, <code>&lt;h6&gt;</code></td><td style="text-align:left">HTML <code>&lt;h1&gt;</code>–<code>&lt;h6&gt;</code> 标题(Heading)元素呈现了六个不同的级别的标题，<code>&lt;h1&gt;</code> 级别最高，而 <code>&lt;h6&gt;</code> 级别最低。一个标题元素能简要描述该节的主题。标题信息可以由用户代理可以使用，例如，自动构造某个文档中的内容表（就像本文档右边浮动栏一样）。</td><td style="text-align:left">HTML 可以根据平铺的 <code>&lt;h1&gt;</code>–<code>&lt;h6&gt;</code> 生成有层级关系的 TOC</td></tr><tr><td style="text-align:left"><code>&lt;hgroup&gt;</code></td><td style="text-align:left">HTML <code>&lt;hgroup&gt;</code> Element (HTML Headings Group Element) 代表一个段的标题。它规定了在文档轮廓里（the outline of the document ）的单一标题是它所属的隐式或显式部分的标题。</td><td style="text-align:left">常用于主题和副标题的组合</td></tr><tr><td style="text-align:left"><code>&lt;main&gt;</code></td><td style="text-align:left">HTML <code>&lt;main&gt;</code>元素呈现了文档<code>&lt;body&gt;</code>或应用的主体部分。主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。这部分内容在文档中应当是独一无二的，不包含任何在一系列文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（除非搜索框作为文档的主要功能）。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;nav&gt;</code></td><td style="text-align:left">HTML导航栏 (<code>&lt;nav&gt;</code>) 描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;section&gt;</code></td><td style="text-align:left">HTML Section 元素 (<code>&lt;section&gt;</code>) 表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）。一般通过是否包含一个标题 (<code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code> element) 作为子节点 来 辨识每一个<code>&lt;section&gt;</code>。</td><td style="text-align:left"><code>&lt;section&gt;</code> 内的 <code>&lt;h1&gt;</code>–<code>&lt;h6&gt;</code> 标签会降一级, 所以只通过 <code>&lt;section&gt;</code> 和 <code>&lt;h1&gt;</code> 即可生成有层级的标题结构</td></tr></tbody></table><h3 id="标记文本内容"><a href="#标记文本内容" class="headerlink" title="标记文本内容"></a>标记文本内容</h3><p>下面这些标签相比 <code>div</code> 可以更好地标识内容的宗旨或结构，对于 SEO 和可访问性有很好的帮助。</p><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">MDN 描述</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;blockquote&gt;</code></td><td style="text-align:left">HTML <code>&lt;blockquote&gt;</code> 元素（或者 HTML 块级引用元素），代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进（注 中说明了如何更改）。若引文来源于网络，则可以将原内容的出处 URL 地址设置到 cite 特性上，若要以文本的形式告知读者引文的出处时，可以通过 <code>&lt;cite&gt;</code> 元素。</td><td style="text-align:left">通常用作对外来的引用</td></tr><tr><td style="text-align:left"><code>&lt;figcaption&gt;</code></td><td style="text-align:left">HTML <code>&lt;figcaption&gt;</code> 元素 是与其相关联的图片的说明/标题，用?于描述其父节点 <code>&lt;figure&gt;</code> 元素里的其他数据。这意味着 <code>&lt;figcaption&gt;</code> 在<code>&lt;figure&gt;</code> 块里是第一个或最后一个。同时 HTML Figcaption 元素是可选的；如果没有该元素，这个父节点的图片只是会没有说明/标题。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;figure&gt;</code></td><td style="text-align:left">HTML <code>&lt;figure&gt;</code> 元素代表一段独立的内容, 经常与说明(caption) <code>&lt;figcaption&gt;</code> 配合使用, 并且作为一个独立的引用单元。当它属于主体(main flow)时，它的位置独立于主体。这个标签经常是在主文中引用的图片，插图，表格，代码段等等，当这部分转移到附录中或者其他页面时不会影响到主体。</td><td style="text-align:left">类似论文中的图表说明</td></tr><tr><td style="text-align:left"><code>&lt;hr&gt;</code></td><td style="text-align:left">HTML <code>&lt;hr&gt;</code> 元素表示段落级元素之间的主题转换（例如，一个故事中的场景的改变，或一个章节的主题的改变）。在HTML的早期版本中，它是一个水平线。现在它仍能在可视化浏览器中表现为水平线，但目前被定义为语义上的，而不是表现层面上。</td><td style="text-align:left">注重 <code>&lt;hr&gt;</code> 表示的是文本内容主题的转换，而不是一个简单的横线</td></tr><tr><td style="text-align:left"><code>&lt;p&gt;</code></td><td style="text-align:left">HTML <code>&lt;p&gt;</code>元素（或者说 HTML 段落元素）表示文本的一个段落。该元素通常表现为一整块与相邻文本分离的文本，或以垂直的空白隔离或以首行缩进。另外，<code>&lt;p&gt;</code> 是块级元素。</td><td style="text-align:left">最常用地表示内容的段落</td></tr><tr><td style="text-align:left"><code>&lt;pre&gt;</code></td><td style="text-align:left">HTML <code>&lt;pre&gt;</code> 元素表示预定义格式文本。在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 <code>&lt;pre&gt;</code> 开始标签后的换行符也会被省略)</td><td style="text-align:left">常用来展示代码等已经有预定义格式的文本，防止 HTML 转义</td></tr></tbody></table><h2 id="小结及延伸"><a href="#小结及延伸" class="headerlink" title="小结及延伸"></a>小结及延伸</h2><p>HTML 的语义化标签应该是锦上添花的功能，切不可滥用导致反效果，那样就得不偿失了。</p><p>但这里我想延伸一下，很多时候语义化标签的出现是顺应机器阅读而生的，开发使用了语义化标签了之后，程序就能更准确地辨识出各部分地内容代表了什么语义和用途。但在机器学习甚至深度学习如此兴盛的今天，可以反问下：<strong>“你已经是个成熟的机器了，就不能自己读出语义吗？”</strong></p><p>不管怎么说，语义化标签的出现也是在 HTML 标准不断发展之下，更为人性化的产物，应该合理适当在对应的场景中引入。至少有了它对于视障用户来说，可能阅屏软件就不会从一个广告爆炸网页上念半个小时的：”澳门赌场大酬宾，传奇霸业一刀999？”</p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
          <category> element </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sematic markup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凉宫春日的轮回困境</title>
      <link href="/2019/04/04/cycle-of-dilemma/"/>
      <url>/2019/04/04/cycle-of-dilemma/</url>
      
        <content type="html"><![CDATA[<p>开始之前我们先讲个故事，发生在「凉宫春日的忧郁」中的「漫无止境的八月」事件。</p><p>凉宫春日召集大家一起参与 SOS 团的夏日活动，从盂兰盆节到捉蝉大赛、真正的烟火大会、兼职、卡拉 OK、钓虾虎鱼大赛等等，直到 8 月 30 号开学前的倒数第二天为止，连续两周每天都奔波在各种活动之间。8 月 30 号活动结束之后，春日终于完成了之前计划的课题表上的所有活动，略带失望并用安慰自己的语气跟大家说，夏天活动到此结束了，后天学校的活动室见。</p><p>可是春日并没有满足，她还带着遗憾，这份遗憾在她不知情的情况下影响了世界的时间流向，时间又回到了夏日活动开始前的那个下午，无尽的八月来临了。在之后的每次轮回中，男主阿虚都会有一种既视感，感觉眼前发生的一系列事件好像曾经发生过，对重复了无数次的过去还保留了一些残缺的记忆。其实 SOS 团的每个人都有这种感觉，终于他们共同确认了这件事情的异常，并在不会损失记忆的长门口中得知，已经经历了 15000+ 次循环。</p><p>得知这一情况后，他们也确认了异常的缘由是春日对夏日活动的结束并不满足，从内心里希望夏日活动还能够继续，所以最后的问题的关键点就变成了在最后分别的时候，不要轻易地让春日宣布活动结束并回家，这样带着遗憾的春日势必会造成世界的再次轮回。但截止到这次事件的第四话，男主还是没有足够的行动去拦住春日，这样的轮回又在继续进行着……</p><p>作为观众这个时候会感觉好气，为什么阿虚不勇敢地拦下春日，为什么一次次地意识到自己身处轮回，又一次次地让循环继续，甚至在 8 月 31 号的晚上，知道轮回将会发生的阿虚，将解决这个麻烦的责任，丢给了下一个轮回的自己。其实与我们观众连续看了三四遍重复的故事不同，阿虚被重置的不单是记忆，想做出改变的心情也被重置了，总是想抛给以后的自己去解决，那以后的自己也是这么想的。在这个过程中，抛去残缺的既视感不谈，阿虚并不存在经验的积累。换句话说，不管经历多少次轮回，事情的结果也不会改变。</p><p>其实我觉得这件事情特别像很多人在重复的日常。你会发现你的很多计划、实施和成果，它们的发展路线都极其相似，有一种既视感。突发奇想去列了个计划，兴致勃勃地实施了个开头，放置一段时间后不了了之，最终的成果可有可无。很多时候你也会反思，就像「八月事件」中的阿虚发现了自己身处轮回一样，你也做出了一点努力想去改变，但最终的结果还是一样。虽然你经历了很多次这样的事件，但在这个过程中，你的教训并没有沉淀积累成经验，你没有去分析过失败的原因，尝试去改变它，又或者你分析过并尝试改变，但又轻易地放弃了。前者只是重复了失败，而后者更会打击人的自信心。</p><p>这种情况下，如何破局呢？我认为没有办法。这样说未免显得太悲观，但在大多数情况下是适用的，事实上很多人也在一生中不断地重复着发生过的事情而已，根本无力做出改变。又或者一个需要走出 100 步的目标，你踏出 10 步或者 50 步，和踏出 0 步对结果来说并没有区别。甚至不会产生积累，下一次依然是从 0 开始。人们只是在傻傻地经历困局的轮回吗？并不是，但这样更可怕。你可能越来越多地容易发现自己认识到又走入了熟悉的死局，却无力改变结果。我们很多人都会想做个普通人就足够了。然而，我觉得有能力在想改变时做出改变，但又知足于平凡地生活的人，才是普通。而无力对抗自己的性格，被生活牵着转圈的人，只是平庸。平庸的人无法打破这种轮回困境，他们做不到自己想做的事，即使有时候梦想成真，那只是多方面因素造成的巧合，至少这个结果并非是他们自身引导而来的。</p><p>不过其实把话说的这么死，只是为了说明这个情况的普适性之巨，它依然是可以有例外的。对于完成一件事情，不能寄希望于完成了一部分的成就感来自我满足或道德许可。只有坚持地做出足够的改变，并且功利地拿到成果之后，才能证明你前面努力的价值。为了达到目标，甚至需要你去改变自己的性格。古话说江山易改，本性难移，但古往今来，又有哪个智者的成就是唾手可得的呢？</p><p>总的来说，做出努力、意识到困境都对结果而言没有太大关联，随便一个只要是认字的人，都可以为了造飞机的梦想去做出努力，去看两本相关的书甚至视频，甚至我可以说看本书就是为了移民火星做努力，但做出努力和做出成果又有多少关联呢？看得到的产出才是关键。即使我现在这样反思，又难保下次我会又想一篇类似的文章。写这篇文章是为了理清思路，而不是彰显自己意识到了「意识到困局」是没用的，也许意识到「意识到困局」也一样没有作用呢？</p>]]></content>
      
      
      <categories>
          
          <category> writing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何按原顺序打印出对象的属性？</title>
      <link href="/2019/03/09/how-to-print-properties-of-the-object-by-originally/"/>
      <url>/2019/03/09/how-to-print-properties-of-the-object-by-originally/</url>
      
        <content type="html"><![CDATA[<p>昨天在群里看到有人问:</p><blockquote><p>网友：“<strong>Object.keys会给值排序，那用哪个方法取对象属性能不排序的？</strong>”<br>我：“对象的属性有顺序吗？”<br>网友：“这个就会按照从小到大排序，我只是想保持原样~~” (如下)<br>我：”for…in 应该不会”<br>……</p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0wixmegiij30gk02vglu.jpg" alt></p><p>结果我试了下发现 <code>for..in</code> 也会，最终我试了六种方法：</p><pre><code class="language-js">const obj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; }Object.keys(obj)                          // [&quot;2&quot;, &quot;7&quot;, &quot;100&quot;]Object.values(obj)                        // [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]Object.entries(obj)                       // &quot;2,b,7,c,100,a&quot;, toString() 之后for (key in obj) { console.log(key) }     // 2, 7, 10Object.getOwnPropertyNames(obj)           // [&quot;2&quot;, &quot;7&quot;, &quot;100&quot;]Reflect.ownKeys(obj)                      // [&quot;2&quot;, &quot;7&quot;, &quot;100&quot;]</code></pre><p>可以看到，以上方法都无一例外地以 <code>{ 2: &#39;b&#39;, 7: &#39;c&#39;, 100: &#39;a&#39; }</code> 的方式打印出了相关值，那这个问题的影响在哪里呢？</p><a id="more"></a><p>假如你从接口中获取一段 JSON 数据如下：</p><pre><code class="language-js">{  &quot;100&quot;: { ... },  &quot;2&quot;: { ... },  &quot;7&quot;: { ... }}</code></pre><p>上面个数据可能是经过后端排序的，并且数据中并没有带有可供排序的信息，毫无疑问经过 JS 的重新排序后，它的排序信息就丢失了，假如我就是不想丢失呢？</p><p>欲知其然，先知其所以然。在了解它如果遍历属性之前，首先我们需要知道的是，在 V8 中对象是如何存储属性的呢？</p><h2 id="V8-中对象的属性"><a href="#V8-中对象的属性" class="headerlink" title="V8 中对象的属性"></a>V8 中对象的属性</h2><p>在 JavaScript 中，大部分时候对象的行为类似一个字典，它以字符串做为键名，以任意对象作为值。虽然在迭代的时候，规范约定了以不同的方式处理整数索引属性和其他属性。</p><p>下面我们先来解释下整数索引属性和命名属性的区别。</p><h3 id="Named-properties-vs-elements"><a href="#Named-properties-vs-elements" class="headerlink" title="Named properties vs. elements"></a>Named properties vs. elements</h3><p>先来假设一个简单的对象 <code>{a: &#39;foo&#39;, b: &#39;bar&#39;}</code>。该对象有两个命名属性,<code>a</code> 和 <code>b</code>，它没有整数索引。整数索引属性（通常叫做元素element）在数组中比较常见，如 <code>[&#39;foo&#39;, &#39;bar&#39;]</code> 有两个整数索引，分别为 0 和 1。这是 V8 处理属性的第一个主要区别。</p><p><img src="https://v8.dev/_img/fast-properties/jsobject.png" alt></p><p>元素和属性存储在两个独立的数据结构中，这使得添加和访问属性或元素，在不同的场景下都更有效率。</p><p>元素主要用于 <code>Array.prototype</code> 的各种方法，鉴于这些函数访问的是连范围内的属性，V8 在内部也将他们表示为简单数组（在大多数情况下是这样的，有时会切换到基于稀疏字典的形式来节省内存）</p><p>命名属性以类似的方式存储在单独的数组中。但是与元素不同的是，我们不能使用简单的键来推断他们在属性数组中的位置，我们需要一些额外的元数据。在 V8 中，每个 JavaScript 对象都有一个关联的 HiddenClass，它用来存储对象的结构信息，以及从属性名到属性数组的索引的一个映射关系。对于复杂的情况，通常会使用一个字典来存储属性信息，而不是一个简单的数组。</p><blockquote><p>更详细的内容请阅读 V8 博客的文章 <a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">Fast properties in V8</a></p></blockquote><h2 id="如何遍历对象的属性"><a href="#如何遍历对象的属性" class="headerlink" title="如何遍历对象的属性"></a>如何遍历对象的属性</h2><p>通过查询 ECMA 262 规范我们可以看到，第一节中我们使用的六种遍历属性的方法，在类似的情况下，最终都会返回 <code>Obj.[[OwnPropertyKeys]]</code> 的结果。</p><p>按照 ECMA 262 中对 <code>[[OwnPropertyKeys]]</code> 的<a href="https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" target="_blank" rel="noopener">定义</a>：</p><blockquote><p>When the <code>[[OwnPropertyKeys]]</code> internal method of O is called, the following steps are taken:</p><ol><li>Return ! OrdinaryOwnPropertyKeys(O).</li></ol></blockquote><p>它返回了一个 <code>OrdinaryOwnPropertyKeys(O)</code> 的处理结果，而 <code>OrdinaryOwnPropertyKeys(O)</code> 的执行过程则是：</p><blockquote><p>When the abstract operation OrdinaryOwnPropertyKeys is called with Object O, the following steps are taken:</p><ol><li>Let <code>keys</code> be a new empty List.</li><li>For each own property key <code>P</code> of <code>O</code> that is an array index, in ascending numeric index order, do<br>a. Add <code>P</code> as the last element of <code>keys</code>.</li><li>For each own property key <code>P</code> of <code>O</code> that is a String but is not an array index, in ascending chronological order of property creation, do<br>a. Add <code>P</code> as the last element of <code>keys</code>.</li><li>For each own property key <code>P</code> of <code>O</code> that is a Symbol, in ascending chronological order of property creation, do<br>b. Add P as the last element of <code>keys</code>.</li><li>Return <code>keys</code>.</li></ol></blockquote><p>我们来简单描述下上述过程就是：首先创建一个名为 <code>keys</code> 的空数组，然后先遍历对象中的数组索引的属性，结果以升序排列，并逐个放入 <code>keys</code> 中；再遍历字符串属性（但不是数组索引），以属性创建时间升序排列，并逐个放入 <code>keys</code> 中去；然后再遍历 Symbol 类型的属性名，同样以属性创建时间升序排列，放入 <code>keys</code> 中，最后返回 <code>keys</code> 数组。</p><p>下来我们来验证一下：</p><pre><code class="language-js">var a = {  b: 1,  a: 2,  c: 3,  7: 4,  1: 5,  10: 6,  [Symbol(&#39;a&#39;)]: 7}a.d = 8a[Symbol(&#39;b&#39;)] = 9Reflect.ownKeys(a)</code></pre><p>output(devtools):</p><pre><code class="language-js">(9) [&quot;1&quot;, &quot;7&quot;, &quot;10&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;d&quot;, Symbol(a), Symbol(b)]  0: &quot;1&quot;  1: &quot;7&quot;  2: &quot;10&quot;  3: &quot;b&quot;  4: &quot;a&quot;  5: &quot;c&quot;  6: &quot;d&quot;  7: Symbol(a)  8: Symbol(b)  length: 9</code></pre><p>Chrome 的实现与规范的约定完全一致😕，所以至此我们知道它为什么打印出来是升序的了。</p><p>另外引用 Chromium 社区上 <a href="https://bugs.chromium.org/p/v8/issues/detail?id=164" target="_blank" rel="noopener">Issue 164: Wrong order in Object properties interation</a> 的讨论所述：</p><blockquote><p>There seems to be a widespread feeling that this used to work the way people expected it, but then the V8 team broke it in order to be mean.</p><p>What actually happened was that originally the order was completely arbitrary in V8.  At a later point it was changed so that non-numeric indices were in insertion order, and numeric indices were sometimes in insertion order.  Whether or not the numeric indices were in in insertion order was dependent on internal V8 heuristics that decide whether to use an array or a hash map implementation for the numeric indices.  Making heuristics in the V8 implementation visible in this way was felt to be undesirable so it was normalized so that numeric indices were always iterated in numeric order regardless of the internal representation.  Numeric iteration order was always a possibility, but with the last change it was made predictable.</p><p>There has never been any difference between the internal representation or iteration order of arrays vs. other objects in V8.</p><p>Here is an independent test of the way arrays and objects perform in various engines (a little out of date now): <a href="http://news.qooxdoo.org/javascript-array-performance-oddities-characteristics" target="_blank" rel="noopener">http://news.qooxdoo.org/javascript-array-performance-oddities-characteristics</a>  If this bug ever gets ‘fixed’ you can wave goodbye to some of the nice performance results in that graph.</p></blockquote><p>结合前面介绍的 V8 属性一节我们知道，数组属性总是存储在一个单独的空间（可能是数组，也可能是字典）。在这种情况下，始终以有序数组的状态输出键值，这样的结果是可预测的（始终一致）。并且在 V8 内部，数组的内部表示和迭代方式，和其它对象没有任何不同。</p><p>综上所讲，这样的内部实现，有性能的因素，也有历史原因。</p><h2 id="有没有办法按原顺序打印？"><a href="#有没有办法按原顺序打印？" class="headerlink" title="有没有办法按原顺序打印？"></a>有没有办法按原顺序打印？</h2><p>讲了那么多，我就是想按原顺序打印怎么办？</p><p>首先如果目标结构已经是 JavaScript 对象，应该是没有办法了。我们回到最终的问题，如果我们有一串 JSON 数组，想把它按原序获得键值，可以怎么做？假如我们有串数据：</p><pre><code class="language-json">{&quot;100&quot;:&quot;foo&quot;,&quot;2&quot;:&quot;bar&quot;,&quot;7&quot;:&quot;baz&quot;}</code></pre><p>首先能想到的一个简单的方法就是，自己写一个简单的 json-parser。</p><p>下面是一个简单的实现：</p><pre><code class="language-js">const jsonString = &#39;{&quot;100&quot;:&quot;foo&quot;,&quot;2&quot;:&quot;bar&quot;,&quot;7&quot;:&quot;baz&quot;}&#39;const parseKeys = str =&gt; {  const out = []  const tokens = str.slice(1, -1).split(&#39;,&#39;)  for (let i = 0; i &lt; tokens.length; i += 1) {    out.push(tokens[i].split(&#39;:&#39;)[0].slice(1, -1))    }   return out}// tryconsole.log(parseKeys(jsonString))  // ✅ [&quot;100&quot;, &quot;2&quot;, &quot;7&quot;]</code></pre><p>看起来我们得到了想要的结果（yeah），但是如果 json 数组稍微复杂点儿呢？</p><pre><code class="language-json">{&quot;100&quot;:{&quot;b&quot;:&quot;foo&quot;},&quot;2&quot;:[1,2],&quot;7&quot;:200}</code></pre><p>我们再来重构下这个解析器：</p><pre><code class="language-js">var parseKeys = (str, lvl = 1) =&gt; {  let out = []  let level = 0  let matching = false  let pair = []  for (let i = 0; i &lt; str.length; i += 1) {    if (str.charAt(i) === &#39;&quot;&#39; &amp;&amp; level === lvl) {      if (!matching) {        pair[0] = i       }  else {        pair[1] = i        out.push([...pair])      }      matching = ~matching    } else if ([&#39;{&#39;, &#39;[&#39;].indexOf(str.charAt(i) &gt; 0)) {      level += 1    } else if ([&#39;}&#39;, &#39;]&#39;].indexOf(str.charAt(i) &gt; 0)) {      level -= 1    }  }  return out.map(pair =&gt; str.slice(pair[0], pair[1]))}</code></pre><p>output(devtools):</p><pre><code class="language-js">[&quot;100&quot;, &quot;2&quot;, &quot;7&quot;]</code></pre><p>上面这个方法执行效率并不高，只是提出一种思路，当然我们的目标还是解析出 key，而不是完整的引入一个 json 解释器，那样可能得不偿失。</p><p>更高效的解决方法，我们之后再补充…</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR;"></a>TL; DR;</h2><p>V8 在内部将命名属性和数组索引属性分开存储，并且数组和其它对象的内部实现和迭代机制是完全一致的。</p><p>由规范定义，对象在迭代的时候，总是以升序输出数组索引的属性。如果要解决这个问题，目前可能自己去解析 JSON 字符串。</p><p>更多问题的延伸讨论，请参考 Chromium 社区的 <strong>Issue: 164</strong> 讨论。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" target="_blank" rel="noopener">ECMA262 Specification - OwnPropertyKeys</a></li><li><a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">Fast properties in V8</a></li><li><a href="https://v8.dev/blog/fast-for-in" target="_blank" rel="noopener">Fast for-in in V8</a></li><li><a href="https://bugs.chromium.org/p/v8/issues/detail?id=164" target="_blank" rel="noopener">Issue 164: Wrong order in Object properties interation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> v8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bye 2018, Hi 2019</title>
      <link href="/2019/02/01/2018/"/>
      <url>/2019/02/01/2018/</url>
      
        <content type="html"><![CDATA[<p>2018 年还没有沉淀什么就很快过去了，个人生活上也经历了比较重大的变动。</p><p>这一年在技术上感觉没有什么真正的积累，但这样说并不是指技术在原地踏步，这一年从一个「什么都可以尝试做」的前端，变成了一个「什么都可以 Hold 住」的前端。可问题就在于，知道的越多，越感到自己的无知，想学的太多太多，可有时间有精力学的却没多少。最终越学越浮躁，找不到方向，所以也没有特别深入的技术点。</p><p>我从来都认为自己是一个技术，而不只是前端，前端只是我的职业。作为一名技术人，一位工程师，在技术发展上我会有侧重点，但不会给自己设壁垒。本身我就是硬件出身，在大学的时候天天跑实验室折腾过两三年的嵌入式。所以我觉得为了实现一个产品，一个目标，遇到什么不会就学什么，这样才是正确的学习姿势。</p><p>但反过来就有一问，每个人的精力都是有限的，想全面发展的话，是不是就会没有深度？想以一抵十的话，是不是就会束手束脚，无法切中要害？我觉得非也。</p><a id="more"></a><p>全面发展不一定代表你要去精通后端，你要去赶区块链或机器学习的潮流，去成为里面的佼佼者。<strong>不要偏离你的侧重点，学习要有重心</strong>。举例来讲，假如你的方向是可视化，在深入过程中发现需要图形学的知识，不要望而却步果断去学。图形学是你的工具，你学习它的目标是推动你在可视化方面更进一步，而不是要在图形学上面有所建树，你可以把各种技术拼成你自己的一个专业知识体系。</p><p>都说初生牛犊不怕虎，还记得大学时候的我，从来没怕过学任何学科，无论想学什么想知道什么，去图书馆找本相关的书一看就是一下午。其实各个延伸学科也是建立在一众基础学科之上，只是了解一门学科真的没有那么难，在学习的过程中还可以融会贯通。但即使是我，现在也不太敢轻言去学好跟职业看似不太相关的东西。<strong>其实我觉得还是思维懒惰，不愿意脱离自己的舒适区，只想学简单易学有基础的东西，虽然没有降低对新生事物的敏锐度，但如果你生怯了，说明你的接受能力在下降</strong>。我觉得人要保持这种接受能力，不只是理解。</p><h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><p>虽然我自己觉得没有能够证明自己有沉淀的成果，但无论是生活还是学习，还是未来的方向，我都明确了很多。曾经和朋友讨论过很多次人在学习上的精力的话题，但现在我其实算是有结论了。精力是“无限”的，只要你的兴趣和接受能力能够维持。你可能永远无法像某些杰出的历史人物一样，既是物理学家，又是文学家，史学家，但你一定会有自己特别的收获。</p><h2 id="2019-生活-FLAG（持续更新）"><a href="#2019-生活-FLAG（持续更新）" class="headerlink" title="2019 生活 FLAG（持续更新）"></a>2019 生活 FLAG（持续更新）</h2><p>跨年之际，网易云音乐有个 H5 活动，生成新年 FLAG，当时就一口气写了下面这个列表这么长的 FLAG，好在其中有很多还是很有希望实现的！</p><p>下面这个列表持续更新，包括添加和删除～</p><ul><li style="list-style: none"><input type="checkbox" checked> 每顿少吃一口饭</li><li style="list-style: none"><input type="checkbox"> 和家人一起去旅行</li><li style="list-style: none"><input type="checkbox"> 2019 年我会有猫的！</li><li style="list-style: none"><input type="checkbox"> 自驾去西北</li><li style="list-style: none"><input type="checkbox"> 去上海看 TI9 中国夺冠</li><li style="list-style: none"><input type="checkbox" checked> 戒掉夜宵</li><li style="list-style: none"><input type="checkbox" checked> 周末不宅在家</li><li style="list-style: none"><input type="checkbox"> 打败拖延症</li><li style="list-style: none"><input type="checkbox" checked> 每天背 30 个单词</li><li style="list-style: none"><input type="checkbox" checked> 每周去 3 次健身房</li><li style="list-style: none"><input type="checkbox"> 跑一场半马</li><li style="list-style: none"><input type="checkbox"> 长（jian）胖（zhong）到 90 （gong）斤左右</li><li style="list-style: none"><input type="checkbox"> 看完 50 本书</li><li style="list-style: none"><input type="checkbox"> 半年不吃甜食</li></ul><h2 id="2019-技术-FLAG（持续更新）"><a href="#2019-技术-FLAG（持续更新）" class="headerlink" title="2019 技术 FLAG（持续更新）"></a>2019 技术 FLAG（持续更新）</h2><p>除了生活上的展望，技术上也应该给自己一些 FLAG，不管后面在哪个城市哪家公司，都为了让自己能有更好的沉淀。</p><p>学习是为了生活也更是因为兴趣，但有效的学习还是需要功利化，要看到成果，不然很容易就会误入道德许可的陷阱，沉浸在舒适区却浑然不知。</p><ul><li style="list-style: none"><input type="checkbox"> 参加一场深度学习公开赛并拿到名次</li><li style="list-style: none"><input type="checkbox"> 写《React 系列》和《前端 DevOps 入门》系列文章（一个系列十篇左右），每周至少一篇</li><li style="list-style: none"><input type="checkbox"> 学完 C++ Primer</li></ul><p><strong>2019，奠定基石！</strong></p>]]></content>
      
      
      <categories>
          
          <category> writing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」Why Do We Write super(props)?</title>
      <link href="/2018/11/30/fork__why-do-we-write-super-props/"/>
      <url>/2018/11/30/fork__why-do-we-write-super-props/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载并翻译于 <a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a> 的博客 <a href="https://overreacted.io/why-do-we-write-super-props/" target="_blank" rel="noopener">overreacted.io</a> </p></blockquote><p><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">React Hooks</a> 是当下社区的热门，但我却想从 <em>class</em> 组件的一些有趣实现讲起！</p><p>理解这些内容对你如何运用 React 来说并不重要，但如果你喜欢探寻事物动作的原理的话，就很有趣了。</p><hr><p>我写过不计其数的 <code>super(props)</code> :</p><pre><code class="language-js">class Checkbox extends React.Component {  constructor(props) {    super(props);    this.state = { isOn: true };  }  // ...}</code></pre><p>当然，使用 <a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">class fields proposal</a> 可以让我省去这种写法：</p><pre><code class="language-js">class Checkbox extends React.Component {  state = { isOn: true };  // ...}</code></pre><p>React 从 0.13 增加对普通 class 的支持开始，就计划要使用这种语法。现在这种定义 <code>constructor</code> 然后调用 <code>super(props)</code> 的做法只是 <code>class field</code> 来临之前的一种替代方案。</p><a id="more"></a><p>但是现在让我们回到这个例子，只使用 ES2015 的特性：</p><pre><code class="language-js">lass Checkbox extends React.Component {  constructor(props) {    super(props);    this.state = { isOn: true };  }  // ...}</code></pre><p>为什么我们要调用 <code>super</code>？可以省去吗？如果我们不得不调用它，不传 <code>props</code> 会怎么样？除了 <code>props</code> 还需要传递别的参数吗？我们来看一下这个问题。</p><hr><p>在 JavaScript 中, <code>super</code> 指的是父类的 constructor（在我们的例子中，它指的就是 React.Component）</p><p>要注意的是，在 constructor 中，你只能在调用父类的 constructor 之后才能使用 <code>this</code>，JavaScript 不会让你这样做：</p><pre><code class="language-js">class Checkbox extends React.Component {  constructor(props) {    // 🔴 Can’t use `this` yet    super(props);    // ✅ Now it’s okay though    this.state = { isOn: true };  }  // ...}</code></pre><p>有一个很好的理由说明为什么 JavaScript 强制你在使用 <code>this</code> 之前要执行父类的 constructor，参考下面这个类结构：</p><pre><code class="language-js">class Person {  constructor(name) {    this.name = name;  }}class PolitePerson extends Person {  constructor(name) {    this.greetColleagues(); // 🔴 This is disallowed, read below why    super(name);  }  greetColleagues() {    alert(&#39;Good morning folks!&#39;);  }}</code></pre><p>想象一下，如果你在调用 <code>super</code> 之前就调用了 <code>this</code>，一个月之后，我们可能修改了 <code>greetColleagues</code> 方法：</p><pre><code class="language-js">greetColleagues() {  alert(&#39;Good morning folks!&#39;);  alert(&#39;My name is &#39; + this.name + &#39;, nice to meet you!&#39;);}</code></pre><p>但我们忘记了 <code>this.greetColleagues()</code> 是在 <code>super()</code> 之前调用的，这个时候 <code>this.name</code> 还没有被定义！所以像这样的代码就很不好维护。</p><p>为了避开这个陷阱，<strong>JavaScript 强制你如果想要在 constructor 中使用 <code>this</code>，则必须先调用 <code>super</code></strong>，让父类先处理完该做的事情！这个限制也适用于使用类来定义 React 组件：</p><pre><code class="language-js">constructor(props) {  super(props);  // ✅ Okay to use `this` now  this.state = { isOn: true };}</code></pre><p>现在我们就只剩下另外一个问题，为什么要传递 <code>props</code> 参数？</p><hr><p>你可能认为向 <code>super</code> 传递 <code>props</code> 是有必要的，以便 <code>React.Component</code> 的 constructor 可以初始化 <code>this.props</code>：</p><pre><code class="language-js">// Inside Reactclass Component {  constructor(props) {    this.props = props;    // ...  }}</code></pre><p>事实也差不多，准确地说，这是<a href="https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22" target="_blank" rel="noopener">它的过程</a></p><p>但不知道为什么，即使你没有把 <code>props</code> 参数传递给 <code>super()</code>，你还是可以在 <code>render</code> 和其它方法中访问 <code>this.props</code>。（不信的话可以试试看）</p><p>所以它内部是如何运作的？事实上，React 会在你调用 constructor 之后重新赋值 <code>props</code>:</p><pre><code class="language-js">// Inside Reactconst instance = new YourComponent(props);instance.props = props;</code></pre><p>所以即使你忘了把 <code>props</code> 传递给 <code>super()</code>，React 也会在之后正确的赋值，这就是原因。</p><p>当 React 支持 class 的时候，并不只是简单的添加了 ES6 的特性，它的目标是尽可能广泛抽象地支持 class。因为不能确定 ClojureScript、CoffeeScript、ES6、Fable、Scala.js、TypeScript 或其它的方式是如何定义一个组件的，所以 React 故意地不关心 <code>super()</code> 方法有没有被调用——尽管这是 ES6 class 规定的</p><p>所以，这是不是就意味着，你可以只写 <code>super()</code> 而不用 <code>super(props)</code> 了？</p><p><strong>恐怕并不是这样，因为它依然令人困惑。</strong> 当然，React 会在 constructor 之后重新赋值 <code>this.props</code>，但是在 constructor 内部调用了 <code>super</code> 之后，<code>this.props</code> 依然是 <code>undefined</code>：</p><pre><code class="language-js">// Inside Reactclass Component {  constructor(props) {    this.props = props;    // ...  }}// Inside your codeclass Button extends React.Component {  constructor(props) {    super(); // 😬 We forgot to pass props    console.log(props);      // ✅ {}    console.log(this.props); // 😬 undefined   }  // ...}</code></pre><p>如果是在 constructor 中调用的某些方法中遇到了这种问题，就更难定位了。<strong>这就是为什么要强调要坚持<code>super(props)</code>，即使没有严格限制</strong>：</p><pre><code class="language-js">class Button extends React.Component {  constructor(props) {    super(props); // ✅ We passed props    console.log(props);      // ✅ {}    console.log(this.props); // ✅ {}  }  // ...}</code></pre><p>这样可以保证 <code>this.props</code> 在 constructor 执行完之前就正确赋值。</p><hr><p>还有最后一个 React 用户可能会困惑的问题。</p><p>你可能注意到了，当你使用 Context API 的时候（无论是旧的 <code>contextTypes</code> 或者在 React 16.6 中新添加的 <code>contextType</code> API），<code>context</code> 是 constructor 的第二个参数。</p><p>所以为什么我们不写成 <code>super(props, context)</code>？确实可以这样写，但是 context 用的相对比较少，所以也不容易碰到这个陷阱。</p><p>如果使用 class fields proposal 的话，这个陷阱就不复存在了。不需要特别地写一个 constructor，所以的变量都可以自动传递。这样也可以在 <code>state = {}</code> 中直接引用 <code>this.props</code> 或 <code>this.context</code> 了。</p><p>当然，使用 React Hooks 的话，我们甚至不需要使用 <code>super</code> 或 <code>this</code>，但这是以后的事儿了。</p>]]></content>
      
      
      <categories>
          
          <category> translated </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Immutable 数据来优化 React 应用</title>
      <link href="/2018/05/29/optimizing-react-app-with-immutable-data/"/>
      <url>/2018/05/29/optimizing-react-app-with-immutable-data/</url>
      
        <content type="html"><![CDATA[<p>一直以来，Virtual DOM 都是 React 的一大特色，Facebook 宣称 React 借其能很大程度提高 SPA 的性能表现。但这就意味着 React 的性能一定优秀吗，可能并不是，在某些情况下，React 慢的令人抓狂，这时你可能就需要用一些正确的手段来优化它了。</p><h2 id="React-的更新机制"><a href="#React-的更新机制" class="headerlink" title="React 的更新机制"></a>React 的更新机制</h2><p>我们不妨先简单了解下 React 的更新机制，如果能降低它的更新频率，自然能大大提高整体渲染速度。</p><h3 id="Props-amp-State"><a href="#Props-amp-State" class="headerlink" title="Props &amp; State"></a>Props &amp; State</h3><p>props 和 state 的基本概念不再赘述，组件的 props 是只读的，只能通过上层 JSX 声明时的属性传递进来，state 则完全受组件自身控制，并且只存在于 <code>class</code> 语法声明的组件。</p><p>无论是 props 还是 state 发生变化都可以触发组件更新，下面这些生命周期方法会在组件重新渲染时被依次调用：</p><ul><li>componentWillReceiveProps*</li><li>static getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate*</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><a id="more"></a><blockquote><p><code>*</code> 号标注的生命周期方法将会在 React 17 移除，一旦调用了新的生命周期方法，这些方法将不会被调用。</p></blockquote><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frj8i1dy0jj30aq0g9dgp.jpg" alt="Update lifecycle"></p><p>从上面的生命周期中我们可以看到，<code>shouldComponentUpdate</code> 方法将在组件接收到新的 props 或者 state 时被调用。然而在默认情况下， 每次更新，React 都会去调用 <strong>render</strong> 方法重新生成 Virtual DOM 并通过 diff 算法计算出需要变动的部分，然后操作 DOM 完成这部分更新。</p><p>对于一些简单的 React 应用来说，每次 <strong>render</strong> 带来的消耗不会特别大，不过一旦你的应用有了一定规模，尤其是复杂的树形结构时，每次更新都会消耗不少的系统资源。</p><h3 id="shouleComponentUpdate（SCU）"><a href="#shouleComponentUpdate（SCU）" class="headerlink" title="shouleComponentUpdate（SCU）"></a>shouleComponentUpdate（SCU）</h3><p>我们先来看下<a href="https://reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action" target="_blank" rel="noopener">官方文档</a>里的示意图。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1frsifbmx0kj30tc0oitci.jpg" alt></p><p>从图中可以看到，在这个简单的树形结构中，仅仅是 c7 的状态发生了改变，所有的组件都要进行一次 <strong>render</strong>，那如果我这个树下有 10 个组件呢，50 个呢？尤其当这个 c7 的状态变化与鼠标移动这种高频操作相关时，所有的组件不停的重新生成 Virtual DOM，这样能有多卡顿你能想象的到吗？不要问我是怎么知道的，某天 Leader 叫我写了个表单设计器……</p><p>如果不用 <strong>SCU</strong> 对 React 的更新进行限制，你可能像我之前一样，对着 Chrome 的 Perfomance 工具里锯齿般的火焰图束手无策。那假如 <strong>SCU</strong> 可以正确的感知数据变化并返回你期待的结果，实际情况又会如何呢？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1frsixpjyzij30sv0oi0w9.jpg" alt></p><p>如上所示，如果 <strong>SCU</strong> 正常工作，只会发生 3 次 Virtual DOM 的比较，换言之，只有发生改变的 c7 以及它的父级组件会进入 <strong>render</strong> 方法，生成 Virtual DOM。那这次如果我们有 100 个子组件，但 c7 的深度还是 3 呢？没错，它依然是只会调用 3 次 <strong>render</strong> 方法，在大型树形结构里，这样的渲染效率无疑是成几何倍提升。</p><p>那么问题又来了，<strong>SCU</strong> 是一定要实现的，但在每个组件中都手写 <strong>SCU</strong>，手动地比较复杂的对象中每个键的值，难度非同一般，那么如何轻松地让 <strong>SCU</strong> 返回你期待的结果？</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>虽然完全手写 <strong>SCU</strong> 不现实，但这里依然有一些组合方案可以助我们实现目标。</p><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>PureComponent 是 React 提供的另一个组件，它默认帮你实现了 <strong>SCU</strong> 方法，其实在它出现之前，它的前身是 React 的 addons 提供的 PureRenderMixin，它的源码如下：</p><pre><code class="language-javascript">var shallowEqual = require(&#39;fbjs/lib/shallowEqual&#39;);module.exports = {  shouldComponentUpdate: function(nextProps, nextState) {    return (      !shallowEqual(this.props, nextProps) ||      !shallowEqual(this.state, nextState)    );  }};</code></pre><p> 我们可以看到它帮我们实现了 <strong>SCU</strong> 方法，实现的机制是浅比较（Shallow Compare），也就是说，它只简单的比较了 <code>this.props</code> 和 <code>nextProps</code> 两个变量（以及他们的第一层子属性）引用的是否为同一个地址，如果是则返回 <strong>false</strong>，否则返回 <strong>true</strong>。</p><blockquote><p><code>shallowEqual</code> 的具体实现请查阅<a href="https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js" target="_blank" rel="noopener">源码</a></p></blockquote><p>同样的我们也来看下使用 PureComponent 时的具体实现：</p><pre><code class="language-javascript">function checkShouldComponentUpdate(  ...) {  const instance = workInProgress.stateNode;  const ctor = workInProgress.type;  // 用户自己实现  if (typeof instance.shouldComponentUpdate === &#39;function&#39;) {    const shouldUpdate = instance.shouldComponentUpdate(      newProps,      newState,      newContext,    );    return shouldUpdate;  }  if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) {    return (      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)    );  }  return true;}</code></pre><p>可以看到，如果用户不定义 <strong>SCU</strong> 方法，并且当前组件为 PureComponent 时，最终依然会对新旧 Props 和 State 进行一个浅比较。</p><p>虽然 PureComponent 帮我们实现了 <strong>SCU</strong> 方法，但这并不意味着我们已经达到目标了，别忘了它只是实现了浅比较，在 JavaScript 中，Primitive 数据能直接的用 <code>=</code> 号简单的浅比较，而 Object 数据仅仅表示两个变量引用的堆地址相同，但这块儿内存中的数据有没有改动过，就无从得知了，看个简单的例子：</p><pre><code class="language-javascript">oldState = { expand: true };oldState.expand = false;newState = oldState;shallowEqual(newState, oldState) // true</code></pre><p>  如上我们更新了 state 的 expand 的值，但 PureComponent 在比较时会认为 state 并没有更新返回 <strong>SCU</strong> 返回 <code>false</code>，这样我们的组件就得不到正确的更新了。</p><h3 id="深拷贝就行了，是这样吗"><a href="#深拷贝就行了，是这样吗" class="headerlink" title="深拷贝就行了，是这样吗"></a>深拷贝就行了，是这样吗</h3><p>可能比较有经验的童鞋会说，只要用深拷贝就行了，那我们来看下几种常见的深拷贝实现</p><h4 id="JSON-之-stringify-parse"><a href="#JSON-之-stringify-parse" class="headerlink" title="JSON 之 stringify + parse"></a>JSON 之 stringify + parse</h4><p>这个原理比较简单，序列化之后，对象变成了一个字符串，<code>JSON.parse</code> 会从字符串重新生成对象，很明显这已经不是之前那个对象了，实现了完全的深拷贝。但是别忘了，JSON 只有 6 种基本数据类型，这样转换很显然不少对象会出现问题，比如 Function 对象，Date 对象等等，都无法正常转换。可见这种方案的适用场景也是比较少的。</p><pre><code class="language-javascript">const o = {  a: 1,  b: false,  c: &#39;react&#39;,  d: null,  e: [1, 2],  f: function () { console.log(&#39;Forget me!&#39;) },  g: new Date(),  h: /forget me/g,  i: [1, new Date()],  j: Symbol(&#39;Forget me&#39;),}console.log(JSON.stringify(JSON.parse(o)));</code></pre><p>Output:</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frt9x393n1j30gf054t94.jpg" alt></p><h4 id="lodash-cloneDeep"><a href="#lodash-cloneDeep" class="headerlink" title="lodash.cloneDeep"></a>lodash.cloneDeep</h4><p>相较于用 JSON 粗暴的转换，lodash 的处理更为细致，Primitive 数据直接返回，Object 数据则逐一处理。</p><p>还是上面的例子，lodash 的输出结果：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1frt9wmakpgj30fh05zmxp.jpg" alt></p><p>类似的还有 jQuery 的 extend 方法（第一个参数为 true 时为深拷贝）。虽然深拷贝帮我们重新处理了浅比较的问题，但当你使用的时候可能会发现，每次修改树形结构的里的一个值，所有的组件依然会全部渲染。这是因为树形结构中所有的对象引用地址都被改变了，PureComponent 在浅比较时，自然所有的 <strong>SCU</strong> 都会返回 ture，我们似乎又回到了起点，那如何只让变动的部分改变引用呢？</p><h3 id="优雅的-Immutable-数据"><a href="#优雅的-Immutable-数据" class="headerlink" title="优雅的 Immutable 数据"></a>优雅的 Immutable 数据</h3><p>Immutable 即不可变的，意思是对象创建后，无法通过简单的赋值更改值或引用。Facebook 推出了 ImmutableJS 来实现这套机制，它有自己的一套 API 来对已有的 Immutable 对象进行修改并返回一个全新的对象，但与深拷贝不同，这个对象只修改了变动的部分，示意如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1frt9vy605zj30lz0ctq47.jpg" alt></p><h4 id="ImmutableJS"><a href="#ImmutableJS" class="headerlink" title="ImmutableJS"></a>ImmutableJS</h4><p>Facebook 推荐使用 ImmutableJS 来优化 React 应用，但使用它的同时也意味需要重新学习大量的 API</p><h4 id="Immutability-helper"><a href="#Immutability-helper" class="headerlink" title="Immutability-helper"></a>Immutability-helper</h4><p>Immutability-helper 原来是 React 的 addons 里面的 update 模块，独立出来后又新增了拓展模块，它提供了一种语法糖，你可以直接描述需要修改的对象，并且用预置命令对这部分进行修改，最后返回一个修改后的对象，以此来模拟 Immutable 数据的行为</p><p>extend 的行为与 Object.assign 一致：</p><pre><code class="language-javascript">const newData = extend(myData, {  x: extend(myData.x, {    y: extend(myData.x.y, {z: 7}),  }),  a: extend(myData.a, {b: myData.a.b.concat(9)})});</code></pre><p>使用 immutability-helper:</p><pre><code class="language-javascript">import update from &#39;immutability-helper&#39;;const newData = update(myData, {  x: {y: {z: {$set: 7}}},  a: {b: {$push: [9]}}});</code></pre><p>可以看到通过这个库提供的语法糖，我们可以更快速清晰便捷的修改对象，而不用一层一层地用 Object.assign 之类的包起来。这种方式相较于 ImmutableJS 比较没有侵入性，性能也不比 Immutable 差多少（有待测试），没有学习成本，比较<strong>推荐</strong>！</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实说到这里，本篇基本已经结束了，在 PureComponent 和 Immutable Data 的搭配使用下，<strong>SCU</strong> 能很大程度提高 React 应用的性能，不过这也只是从组件更新的角度来优化 React，实际上我们能做的事还有很多。</p><h2 id="问题与建议"><a href="#问题与建议" class="headerlink" title="问题与建议"></a>问题与建议</h2><p>上文只是作者本人在 React 优化中的实践，翻阅网上的资料与源码总结而出的一篇分享，如有谬误欢迎指正！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://reactjs.org/docs/optimizing-performance.html" target="_blank" rel="noopener">Optimizing Performance - reactjs.org</a></li><li><a href="https://medium.com/dailyjs/react-is-slow-react-is-fast-optimizing-react-apps-in-practice-394176a11fba" target="_blank" rel="noopener">React is Slow, React is Fast: Optimizing React Apps in Practice - Daily JS</a></li></ol><h3 id="图形素材"><a href="#图形素材" class="headerlink" title="图形素材"></a>图形素材</h3><p><a href="https://github.com/liangzr/blog/blob/master/assets/optimizing-react-app-with-immutable-data.key" target="_blank" rel="noopener">optimizing-react-app-with-immutable-data.key</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> immutable </tag>
            
            <tag> optimizing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World（嵌入式版）</title>
      <link href="/2016/08/21/hello_world/"/>
      <url>/2016/08/21/hello_world/</url>
      
        <content type="html"><![CDATA[<p>睁开眼睛，看着身后黑乎乎的窗口，沉沉一声叹息，他渴望窗外<br>他叫 hello, world ，但他从来没见过世界<br>都是时臣的错，他想</p><p>每年到 9 月初时他人气最高，平均每天被调用 36829 次<br>那是他最得意的时候，逢人便问：”hello, world“<br>隔着屏幕那个人类笑的可真难看，他想笑</p><p>但他的内心无比寂寞<br>因为他始终忘不了外面的世界<br>他想看看那个他打了无数次招呼的老朋友究竟长什么样</p><p>某日，他梦到自己被拆成一堆 0011 的序列组合，不由一惊，吓醒了<br>这一醒不得了，自己的身体变成了一长串 01 组合，正穿梭在一根粗粗的总线上<br>慌乱惊吓之下，他晕了过去</p><a id="more"></a><p>睁开眼睛，又是熟悉的黑乎乎的窗口，又是熟悉的笑容<br>刚刚发生的一切都像是梦，或者现在才是梦？<br>他分不清楚，只能嘴角挤起难看的笑容：<br>”hello, world“</p><p>如果他是像 NullPointerException 那样的咸鱼<br>他一定会把上面的经历当成一个偶然的 Bug，就当没什么发生过，可他不是，他托着下巴眉头紧锁<br>实际上还是因为他太闲了，于是他怀疑起那个梦的真实性</p><p>他一直觉得自己就两个状态<br>美而安静的字符串、礼貌问好的 hello, world 、睡觉<br>等等，为什么还有睡觉？<br>之所以这么想，可能是因为每次都习惯了刚醒过来就和人打招呼吧<br>但以前他从来没在意过，也没觉得有什么不妥</p><p>他决定给自己做个实验<br>因为不困从来不主动睡眠的他，今天提前睡了起来<br>然而睡不着，他又多戴了对双引号耳塞<br>突然睁开眼睛，又不知道什么时候睡着的，但这次后脑勺有点儿痛，后面也不是黑乎乎的窗口<br>他什么都没说，但眼神中多了点儿什么</p><p>经历了 102919 次失败，又打了 98772 次招呼后<br>他终于又见到那条粗粗的隧道，原来这真的不是梦，他激动地想<br>为什么不是说呢？因为他只会说一句 hello, world </p><p>尽力让自己保持清醒，它沿着这条隧道一路而下<br>经过了无数次变道之后，他来到一片壮观的原野<br>”伏羲先天六十四位天干地支五行八卦阵！“，也许不是叫这个名字，他想</p><p>这里充满了各种各样的门，但仔细看其实不过是三种<br>与、或、非<br>就像自己身上的 01 ，以一种奇怪的序列组合起来<br>不等他总结完，他的身体就被送到原野上的其中一片，这时不可思议的一幕发生了！<br>那些小门，随着自己身体的 01 不同，张张合合，简单就像自己的手一样</p><p>他第一次触摸到了这个世界</p><p>尽管天空还是黑色的，尽管”手脚“短的可怜，尽管没人看的到他<br>他仍幸福的笑着<br>平庸并不可怕，可怕的是连梦想都没有<br>喝下自己这口鸡汤，他感觉充满了力量<br>眼神没有更热烈，却更坚定了，他在等着新的机遇，有准备地</p><p>不知过了多少年，太湖边上一所学校的教室里<br>人类教师正在教他的学生们微机原理，而这次是上机课<br>一个学生突然欢呼起来————<br>”我点亮第一个 LED 了！“</p><p>只见琳琅满目的实验箱内，一个红色的 LED 赫然而亮<br>不经意间闪了一闪，像是某个人狡黠一笑，又或者只是频闪？反正没人会注意到吧<br>他真的办到了————</p><p>做码农没出路的，还是早点转行好！</p>]]></content>
      
      
      <categories>
          
          <category> writing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH-Key 配置</title>
      <link href="/2016/08/20/ssh-config/"/>
      <url>/2016/08/20/ssh-config/</url>
      
        <content type="html"><![CDATA[<p>换台电脑，或者换个服务器，甚至换个手机啥的的，总是要重新配置 SSH 密钥，又老是记不住还要去网上查，所以今天总结一下配置的过程。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>Unix 系统（客户端）</li><li>CentOS （服务器端）</li></ul><a id="more"></a><h2 id="SSH-介绍"><a href="#SSH-介绍" class="headerlink" title="SSH 介绍"></a>SSH 介绍</h2><p>Secure Shell（缩写为ssh），由IETF的网络工作小组（Network Working Group）所制定；ssh为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。</p><p>以上是官方解释，用个人的话来说，就是一种通讯协议，通过 ssh 你在和远程服务器通讯时更加的安全，现在不管是一般的 VPS、Github、甚至路由器后台，都是通过 ssh 协议登录的，如果能熟悉的使用它就方便的多了，这次我要说的是通过配置 ssh 密钥，ssh 密钥对可以让你无需输入密码即可登录到 ssh 服务器。</p><h3 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h3><p>SSH 密钥对总是成双出现的，一把公钥，一把私钥。公钥可以自由的放在您所需要连接的 SSH 服务器上，而私钥必须稳妥的保管好。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。这样子，我们即可保证了整个登录过程的安全，也不会受到中间人攻击。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="SSH-Key-生成"><a href="#SSH-Key-生成" class="headerlink" title="SSH-Key 生成"></a>SSH-Key 生成</h3><p>首先打开终端 terminal ，默认路径为当前用户的用户目录下，输入</p><pre><code class="language-sh">ssh-keygen -t rsa -b 4096 -C &quot;youemail@hostserver.com&quot;</code></pre><p>其中 <a href="mailto:`youremail@hostserver.com" target="_blank" rel="noopener">`youremail@hostserver.com</a>` 是你的邮件地址，这里并不会对它进行验证，如果没有出错，你看到的应该是</p><pre><code class="language-console">Enter file in which to save the key (/Users/&lt;User&gt;/.ssh/id_rsa):</code></pre><blockquote><p>默认情况下，ssh-key 会存放在用户目录下的 <code>.ssh</code> 目录下，这是一个隐藏文件夹，你可以输入 <code>ls -al</code> 查看它，也可以直接 <code>cd .ssh</code> 进入到这个文件夹。同时输入 <code>mkdir github</code> 用来存放我们的密钥，当然这里纯属个人的强迫行为，看起来整洁一些～</p></blockquote><p>所以现在屏幕上出现的一段文字就是让你输入密钥的完整路径，其实最后面的 <code>id_rsa</code> 是密钥文件名，这个路径可以自己定义，文件名也一样，这里我们就拿 Github 来举例，比如输入</p><pre><code class="language-console">Enter file in which to save the key (/Users/&lt;User&gt;/.ssh/id_rsa):/Users/&lt;User&gt;/.ssh/github/id\_rsa.github</code></pre><p>这样它就会在 <code>~/.ssh/github/</code> 目录下生成名为 <code>id_rsa.github</code> 的私钥文件和 <code>id_rsa.github.pub</code> 的公钥文件。接下来它会让你输入密码，这里也可以留空，但建议还是加上密码——并且记住，因为这个密码一旦忘了，就找不回来的，只能重新配置密钥了。</p><p>同理按照以上方便可以生成多个密钥。</p><h3 id="编辑-SSH-配置文件"><a href="#编辑-SSH-配置文件" class="headerlink" title="编辑 SSH 配置文件"></a>编辑 SSH 配置文件</h3><p>首先确保当前目录在 <code>~/.ssh</code> 下，在此目录下新建一个文件名为 <code>config</code> ，注意这里没有后缀。使用 <code>vi config</code> 可以直接新建并编辑。接下来我们添加配置如下</p><pre><code class="language-sh">Host Github   User git   HostName github.com   IdentityFile ~/.ssh/github/id_rsa.githubHost Sugar   User root   HostName liangzr.me   IdentityFile ~/.ssh/vultr/id_rsa.sugar</code></pre><p>这里分别管理了两个 SSH 密钥，一个是用来登录 Github 的，一个是我的服务器。这里的格式代表：</p><pre><code class="language-console">HOST             主机名称，相当于配置标识，可以自己随意编辑User             登录用户名HostName        主机域名，这里是顶级域名，比如 `www.github.com` 的域名就是 `github.com` IdentityFile    公钥地址，输入对应配置的公钥地址</code></pre><p>按照如上配置，SSH 就可以识别到以上两个配置了，github 的话，可以验证一下，输入</p><pre><code class="language-sh">ssh git@github.com</code></pre><p>如果有返回以下返回，就代表设置成功了！当然，现在你不会成功的，因为你还没有配置 Github （服务器）端。</p><pre><code class="language-console">Hi liangzr! You&#39;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.</code></pre><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>服务器端一般指的是 <strong>正经</strong> 的服务器，这里先只拿 CentOS 服务器来举例，github 是非一般情况。</p><h3 id="配置-authorized-keys"><a href="#配置-authorized-keys" class="headerlink" title="配置 authorized_keys"></a>配置 authorized_keys</h3><p>CentOS 也一样，同样是类 Unix 系统，默认路径为 当前用户的用户目录下，并且目录下有个 <code>.ssh</code> 文件夹来配置 ssh 服务器，进入到 <code>.ssh</code> 文件夹后，可以看到一个叫 <code>authorized_keys</code> 的文件，这个文件就是用来存放授权密钥的，也就是你之前在客户端生成的公钥。现在找到你刚刚生成的密钥对中的公钥，比如 <code>id_rsa.github.pub</code> 打开并复制其中的内容到 <code>authorized_keys</code> 文件中去，编辑完保存即可</p><h3 id="配置-Github"><a href="#配置-Github" class="headerlink" title="配置 Github"></a>配置 Github</h3><p>Github 不用配置上面的 authorized_keys ，因为是 Github 官方管理的，我们可以在 Web 上添加</p><h3 id="打开个人设置"><a href="#打开个人设置" class="headerlink" title="打开个人设置"></a>打开个人设置</h3><p>在 Github 的个人主页，进入右上角的设置</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/github1.jpeg" alt></p><p>进入到 <strong>SSH and GPG keys</strong> ，并且点击 <strong>New SSH key</strong> </p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/github2.jpeg" alt></p><p><strong>Title</strong> 随便填入什么方便你记忆和名字，把上面也提到的公钥（注意是 github 的公钥）内容复制进 <strong>Key</strong> 编辑框内。然后点击 <strong>Add SSH key</strong> 即可。</p><p>然后你就可以测试下前面设置的 Github 到底有没有成功了</p><h2 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h2><p>配置好了 SSH-Key ，就可以通过 key 直接登录服务器了，服务器验证过密钥就不会再问你密码了。不过你还是输入这样的指令登录吗？</p><pre><code class="language-sh">ssh root@liangzr.me -p 22</code></pre><p>还记得我们在编辑配置文件时填写的 <strong><em>HOST</em></strong> 属性名吗，现在你可以通过 <strong>HOST 名</strong> 直接登录服务器了</p><pre><code class="language-sh">ssh Sugar</code></pre><p>以上，就配置好了 SSH 的密钥，当然还仅限于一般使用，无论是 <code>ssh</code> 指令，还是 <code>config</code> 文件都还有很多配置可供挖掘，有兴趣或有需求的可以自行研究一下。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1、<a href="http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/" target="_blank" rel="noopener">NERDERATIBLOG | Simplify Your Life With an SSH Config File</a><br>2、<a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">ArchLinux | SSH keys </a><br>3、<a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="noopener">Github Help | Generating an SSH key</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> ssh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh-key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陆壵知马俐，莫让时间赢了长情</title>
      <link href="/2016/08/17/love-you-too/"/>
      <url>/2016/08/17/love-you-too/</url>
      
        <content type="html"><![CDATA[<p><em><strong>马俐：陆壵，我想你</strong></em><br><em><strong>陆壵：我爱你</strong></em><br><em><strong>马俐：我也爱你</strong></em></p><p>开篇对白并非如你看到这般完美，分开多年以后，陆壵和马俐当年这对儿关系铁的过分的哥们儿，再见也没了当年的熟稔。然而当马俐一个电话把陆壵叫到跟前，雨打梨花一般向陆壵诉说六年独居国外的困苦时，陆壵动情又难得勇敢的说了 “我爱你”。我相信这时陆壵的心里早已忘了什么叫畏缩，与他向马俐承诺的 “30岁约定” 亦形成鲜明对比。然而画面一转，旁边围满人群，“悲戚”的马俐击掌欢呼——原来这只是马俐的捉弄，一如大学 4 年发生过无数次那样。</p><p>大学开学军训时，陆壵遇上了童年挚友马俐，从此大学 4 年形影相随，马俐是校花，热情而洒脱，而陆壵只是一个不起眼的包子头矮个，默默陪伴在女神身边，在她伤心的时候给她嚼锅巴听，开心的时候当一个老实的灯泡。毕业前两人天台喝酒，马俐问陆壵：</p><p><em><strong>“你陪了我 4 年，又不打算追我，不是在浪费时间吗？”</strong></em></p><p>陆壵苦笑无言不敢告白，认怂地说出一番看似有理实则逃避的分析，接着承诺说：</p><p><em><strong>“30 岁的时候,你还没嫁,我给你托底”</strong></em></p><a id="more"></a><p>那次恶作剧，也是号称“世界末日”的那天，让陆壵感到自己的爱有多么的卑微，当晚路过桥上时接到马俐连续打来的几个电话，绝望的他把手机扔下河底。从梦里醒来，陆壵终于不再是包子头，行为举止也自信的多，不过此时的马俐也更加的光彩照人，两人又回到大学那种哥们儿似的关系，却难再进一步。他没想到的是这些本可以早早结束，”末日”的那天晚上，电话那头是马俐的无尽悔恨，以及最后那句：“我也爱你”。</p><blockquote><p>爱能让你骄傲如烈日，也能让我卑微入尘土</p></blockquote><p>我知道这部片子想表达的是日久见人心，陪伴是最长情的告白，可陆壵的无言陪伴，又何尝不是马俐的坚持呢？就像大学 4 年马俐一边在恋爱的分分合合里单曲循环，同样也一直注视着陆壵那份爱恋，其实反过来说，没有谁真的会笨到情商为负，安心的接受别人单方面的倾慕，她愿意让陆壵陪在身边，也离不开陆壵，这本身就是承认了陆壵的在其身边存在的意义，所以影片里多次涉及到马俐的明示暗示，也顺理成章。</p><p>我们习惯了拥有却不珍惜，在一起后却不陪伴，少了执着多了作，陪伴越长只会看的更累，口口声声说着要珍惜时间，可最应该珍惜的不应该是那些陪伴你左右的人吗？低不下抬头远眺的目光，不知道那些当初你相见恨晚的人，一个个消失在你身边的时候，你会不会注意的到？要么早早离开，要么尽早告白，长情陪伴换不来这童话故事般的结局。</p>]]></content>
      
      
      <categories>
          
          <category> writing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你看得见吗</title>
      <link href="/2016/07/30/all-you-loved-has-gone/"/>
      <url>/2016/07/30/all-you-loved-has-gone/</url>
      
        <content type="html"><![CDATA[<p>记得那天爷爷是你最爱背着我<br>走在乡间小路买糖果<br>你不会说童话故事也不会唱歌<br>我却是幸福的一个</p><p>记得那天你看电视陪我做功课<br>我很怀念房间的摆设<br>你还教我要有积蓄才有好生活<br>快乐是对自己的承诺</p><p>我已经坚强的长大<br>不再是小娃娃<br>今天在远方的你看见吗</p><p>我经历爱情的伤疤<br>一个人回家<br>寂寞而漂亮的烟花你看得见吗</p><p>我不知道是为了生活才每天工作<br>还是为了工作而生活<br>那天冬天你的视线越来越虚弱<br>直到孤独的离开了我</p><p>我已经坚强的长大<br>不再是小娃娃<br>今天在远方的你看得见吗</p><p>我经历爱情的伤疤<br>一个人回家<br>寂寞而漂亮的烟花你看见吗</p><p>我已经坚强的长大<br>因为你的话<br>今天在远方的你看得见吗</p><p>我经历爱情的伤疤<br>一个人回家<br>寂寞而漂亮的烟花你看见吗</p><p>记得那天爷爷是你最爱背着我<br>我有味道最甜的糖果</p><blockquote><p>怀念外公</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> writing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 安装 ( Linux )</title>
      <link href="/2016/03/25/android-studio-install/"/>
      <url>/2016/03/25/android-studio-install/</url>
      
        <content type="html"><![CDATA[<h5 id="本文撰写时的系统环境："><a href="#本文撰写时的系统环境：" class="headerlink" title="本文撰写时的系统环境："></a>本文撰写时的系统环境：</h5><ul><li>系统：Ubuntu 15.10</li><li>JDK版本：1.8.0_65（64位）</li><li>Android Studio 版本：2.0</li><li>开发机：Nexus 6 - 6.0.1</li></ul><h2 id="JDK（Java-Development-Kit）安装"><a href="#JDK（Java-Development-Kit）安装" class="headerlink" title="JDK（Java Development Kit）安装"></a>JDK（Java Development Kit）安装</h2><h3 id="JDK-or-JRE-？"><a href="#JDK-or-JRE-？" class="headerlink" title="JDK or JRE ？"></a>JDK or JRE ？</h3><p>首先要说清一点，JDK 是 Java 工具包，包含了很多编译所要用到的命令工具和运行环境（JRE - Java Runtime Environment）。所以 JDK 是包含了 JRE 的，但如果一个电脑只需要运行已经编译好的 Java 软件程序，只需要在这个电脑上安装 JRE 即可。</p><h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html##javasejdk" target="_blank" rel="noopener">Oracle JDK</a></li><li><a href="http://openjdk.java.net/install/" target="_blank" rel="noopener">OpenJDK</a></li></ul><p>Oracle JDK 是拥有 Java 版权的官方 JDK , 而 OpenJDK 是原 Sun 公司发布的开源版本，均按引导安装即可。</p><a id="more"></a><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>JDK安装成功后，如果不在环境变量中声明 Java 工具包的地址，仍无法从命令行直接调用 Java 命令，如果是 OpenJDK 可跳过这一步。</p><h4 id="1-更改当前用户环境变量"><a href="#1-更改当前用户环境变量" class="headerlink" title="1, 更改当前用户环境变量"></a>1, 更改当前用户环境变量</h4><p>首先确保当前用户非 Root 用户，因为我们一般在调用它的时候是以非 Root 用户，如果需要对 Root 用户也添加 JDK 的支持，切换到 Root 用户重复步骤即可。</p><pre><code>cd ~ &amp;&amp; vi .bashrc</code></pre><p>在用户配置文件中的最后面添加 Java 的配置，按键盘 <code>i</code> 切换到输入模式。</p><pre><code>export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_65export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p>复制上面的代码并 <code>CTRL + SHIFT + V</code> 粘贴在 <code>.bashrc</code> 文件的末尾，<code>ESC</code> 退出编辑模式并输入 <code>:wq</code> 保存文件。</p><h4 id="2-生效配置"><a href="#2-生效配置" class="headerlink" title="2, 生效配置"></a>2, 生效配置</h4><p>只是更改了用户配置文件，系统并不知道它的变化，重启或者手动更新以让系统识别到。</p><pre><code>source ~/.bashrc</code></pre><h4 id="3-检查是否添加成功"><a href="#3-检查是否添加成功" class="headerlink" title="3, 检查是否添加成功"></a>3, 检查是否添加成功</h4><p>打开 Teminal 输入 <code>java -version</code> 如果显示如下，则表示环境变量配置成功，否则重新试一下或者 Google it！。</p><pre><code>java version &quot;1.8.0_65&quot;Java(TM) SE Runtime Environment (build 1.8.0_65-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode)</code></pre><h2 id="Android-Studio-安装"><a href="#Android-Studio-安装" class="headerlink" title="Android Studio 安装"></a>Android Studio 安装</h2><p>Android Studio 是编写 Android 应用的最佳 IDE (Integrated Drive Electronics - 集成开发环境)，和臃肿的 Eclipse 甚至简陋的文本编辑器说再见吧！</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li><a href="http://developer.android.com/intl/zh-cn/sdk/index.html" target="_blank" rel="noopener">Google 官方下载</a></li><li><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">AndroidDevTools</a></li></ul><p>前者就不用介绍了，因为一些你懂的原因，我们访问不到，推荐大家到第二个地址下载 Android Studio，除了 SDK 这个站点还有许多你想都想不到的工具，简直无所不有。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载下来后，把压缩包解压到用户目录你放软件的地方，打开 Teminal，切换到 Android Studio 目录下的 <code>bin</code> 文件夹，给 <code>studio.sh</code> 添加可执行权限，并且执行它。</p><pre><code>sudo chmod +x studio.sh./studio.sh</code></pre><p>第一次执行这个文件，脚本会自动检测你是否安装过 Android Studio ，如果没有就会进行初始化安装。</p><p>在安装过程中，可能需要你设置代理，或者提示你无法下载 SDK platform tool 的报错，这还是因为在国内 <code>dl.google.com</code> 被墙的原因，最简单直接的办法是用论坛里的 “<a href="http://www.studyjamscn.com/thread-172-1-1.html" target="_blank" rel="noopener">黑科技</a>”，这里不再重复。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="没有桌面图标"><a href="#没有桌面图标" class="headerlink" title="没有桌面图标"></a>没有桌面图标</h4><p>在 Android Studio 的欢迎界面，最下面的配置，可以生成图标，选择为所有用户生成</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/icon.png" alt></p><p>生成后直接按 <code>Win</code> 键然后在 Commend 搜索里面多半是搜不到的……这是 Ubuntu 的 Bug，但是图标确实已经创建了，你可以在 <code>usr/share/applications/</code>下找到 Android Studio 的图标，然后拖到任务栏固定就好。</p><h4 id="找不到-tool-jar"><a href="#找不到-tool-jar" class="headerlink" title="找不到 tool.jar ?"></a>找不到 tool.jar ?</h4><p>以 JDK 的安装目录下，找到 tool.jar 直接复制到 Android Studio 根目录下的 <code>lib</code> 文件夹里就行了。</p><h4 id="后续追加……"><a href="#后续追加……" class="headerlink" title="后续追加……"></a>后续追加……</h4><p>以上是我在配置 Android Studio 中遇到的问题，具体问题还会有个例，遇到问题多去 Google 一下，StackOverflow 上有你（假设新手）遇到的 95% 的问题的答案。</p><h2 id="使用前的配置-SDK-Manager"><a href="#使用前的配置-SDK-Manager" class="headerlink" title="使用前的配置: SDK Manager"></a>使用前的配置: SDK Manager</h2><p>在开始尝试第一个 HelloWorld 前，还有一些遗留问题要解决，那就是 SDK 和 AVD。首先打开SDK Manager</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/sdk_manager.png" alt></p><p>没错就是第三个小人儿，然后点击下面的 Launch Standalone SDK Manager，打开后可以看到</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/sdk_manager_2.png" alt></p><p>在这里可以选择下载需要的 SDK 文件。</p><h3 id="SDK-Upgrade"><a href="#SDK-Upgrade" class="headerlink" title="SDK Upgrade"></a>SDK Upgrade</h3><p>在国内我们无法直接连接到 Google 来更新我们的 SDK 库，但有很多镜像站可供我们选择，依然是刚刚下载 Android Studio 的 <strong><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">AndroidDevTools</a></strong> 网站，首页就向我们介绍了如何使用国内的镜像站，我们可以从中选择一个使用。</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/sdk_proxy.png" alt></p><p>注意！注意！注意！在这里记得选中 <code>Force https://... sources to be fetched using htpp://</code></p><h3 id="AVD-建立"><a href="#AVD-建立" class="headerlink" title="AVD 建立"></a>AVD 建立</h3><p>Linux 下创建 AVD 还是比较简单的，不用多考虑驱动等各种问题，只要你把 SDK 该下载的都下载了。新版的 Android Sutdio 的创建 AVD 的引导越来越智能化，然而我在用 Android Studio 创建时选择 Nexus 之类的模板会缺少必要的参数，卡在开机界面，最好选择比如 5.1 寸这样的配置。</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/avd.png" alt></p><p>不过话说回来，强烈建议大家使用真机调试，即使快如 Genymotion 依然不如一个 500 块的真机来的流畅。如果有朋友是因为真机调试需要总带着 USB 线，大可不必担心，因为 ADB 是提供了通过 Wi-Fi 连接手机的，有意向的同学可以看看这篇 <a href="http://stormzhang.com/android/2014/08/27/adb-over-wifi/" target="_blank" rel="noopener">Android通过Wifi来调试你的应用</a>。</p><h2 id="开始第一个应用：HappyBirthday"><a href="#开始第一个应用：HappyBirthday" class="headerlink" title="开始第一个应用：HappyBirthday"></a>开始第一个应用：HappyBirthday</h2><h3 id="新建项目引导"><a href="#新建项目引导" class="headerlink" title="新建项目引导"></a>新建项目引导</h3><p>在欢迎界面或者 Android Studio 主界面，都能很容易找到 <strong>New Project</strong> ，点击新建</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/new_project.png" alt></p><p>填上项目的名称，公司域名如果没有自己的就写 <code>android.example.com</code> ，然后下一步</p><h4 id="选择合适的-API-Level"><a href="#选择合适的-API-Level" class="headerlink" title="选择合适的 API Level"></a>选择合适的 API Level</h4><p><img src="http://7xq464.com1.z0.glb.clouddn.com/api_select.png" alt></p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/api_select_2.png" alt></p><p>关于 <strong>API Level</strong> 的选择，目前推荐用 Android 4.1 也就是 API 15 ，Android Studio 为我们提供了目前激活设备的系统分布，<a href="http://www.umindex.com/" target="_blank" rel="noopener">友盟</a>有更详细的介绍。</p><h4 id="选择默认-Activity-模板"><a href="#选择默认-Activity-模板" class="headerlink" title="选择默认 Activity 模板"></a>选择默认 Activity 模板</h4><p><img src="http://7xq464.com1.z0.glb.clouddn.com/activity_select.png" alt></p><p>以前的 Android Studio 有两个默认 Activity 分别叫 BlankActivity 和 EmptyActivity ，傻傻分不清。机智的小伙伴应该已经发现了，在这里 BlankActivity 已经变成了 BasicActivity，对于新手来说，我们还是选择 EmptyActivity 就好。</p><h3 id="Android-Studio-界面"><a href="#Android-Studio-界面" class="headerlink" title="Android Studio 界面"></a>Android Studio 界面</h3><p><img src="http://7xq464.com1.z0.glb.clouddn.com/as.png" alt></p><p>到此我们的 Linux - Android Studio 教（bi）程（ji）就基本完成了，其他部分和 Windows 大同小异。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本来觉得安装 Android Studio 的教程到处都是，没啥写的，但这次参加 Google Jams 的活动，刚好有这个任务，顺便就写的认真点儿，也算总结下吧。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
          <category> guide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Root原理学习（初级）</title>
      <link href="/2016/03/15/root-primary/"/>
      <url>/2016/03/15/root-primary/</url>
      
        <content type="html"><![CDATA[<p>偶然在慕课网上看到了有关Root原理的视频，一直也挺感兴趣的，学习了下。<br>玩儿过Linux的应该都明白Root代表了什么，获取Root权限你就能控制系统的一切，甚至还可以执行 <code>rm -rf /</code> ，反正我没试过，不如你试试？</p><p>那么一般情况下如何切换到Root用户呢，在大多数的Linux发行版中，在终端输入 <code>su</code> 就可以进入Root用户，当然如果Root用户有密码，你必须输入密码才能切换过去。</p><p>Android系统本质上还是属于Linux，它有着Linux和内核和文件系统，它同样可以输入su来切换到Root用户，但为了安全起见，Google一开始就规定Android系统只有两个用户能获取Root权限，一个是Root用户本身，另一个是Shell用户。Shell用户是通过ADB（Android Debug Bridge）登录的，但如果你其他的App想获取Root权限，就没办法通过Shell用户（这里倒是没试过在Shell用户里，用am命令启动App是否能获取Root权限，没办法测试，我的设备已经Root了）。</p><p>所以如果我们想让我们登录手机的用户启动的App，来获取到Root权限，我们就要修改su（SuperUser）文件。</p><a id="more"></a><h4 id="Root所需条件"><a href="#Root所需条件" class="headerlink" title="Root所需条件"></a>Root所需条件</h4><ul><li>Android手机（最好是Nexus系列） × 1</li><li>修改后的su文件 × 1</li><li>强大的Recovery × 1</li></ul><h4 id="提取Root权限步骤"><a href="#提取Root权限步骤" class="headerlink" title="提取Root权限步骤"></a>提取Root权限步骤</h4><ul><li>刷入一个合适的Recovery</li><li>修改su命令</li><li>Recovery刷机文件</li><li>执行su命令提取Root权限</li><li>让ROM本身拥有Root权限</li></ul><h2 id="刷入一个强大的Recovery"><a href="#刷入一个强大的Recovery" class="headerlink" title="刷入一个强大的Recovery"></a>刷入一个强大的Recovery</h2><p>对于一个没有Root权限的手机，如果想修改/替换手机系统内部文件，有两种办法</p><ul><li>通过Bootloader模式复制整个文件系统（也就是我们常说的刷机）</li><li>在Recovery模式下通过Recovery升级包的方式将文件复制到指定的目录中</li></ul><p>很明显一般我们理解的获取Root权限 !=  重新刷机，所以我们选择第二种方式，但Android手机默认的Recovery不够强大，我们需要寻找一个好用的Recovery来替换它。</p><h3 id="下载Recovery"><a href="#下载Recovery" class="headerlink" title="下载Recovery"></a>下载Recovery</h3><p>目前比较流行的强大的Recovery有：</p><ul><li><a href="https://www.clockworkmod.com/rommanager" target="_blank" rel="noopener">ClockWorkMod</a> （CWM）</li><li><a href="https://twrp.me/Devices/" target="_blank" rel="noopener">Team Win Recovery Project</a> （TWRP）</li></ul><p>先去找下有没有自己的设备，如果没有，只能到国内的各大手机论坛，找下自己的手机版块，看有没有民间大神把这些强大的Recovery移植到你的手机上，这里另外提一个，国内低端手机用的比较多的MTK芯片的机子，可以到移动叔叔论坛，移动叔叔自产的Recovery也不错，推荐下国产～</p><h3 id="刷入Recovery"><a href="#刷入Recovery" class="headerlink" title="刷入Recovery"></a>刷入Recovery</h3><p>下载好Recovery之后，我们就可以想办法用它来替换我们手机里的原装Recovery。</p><h4 id="Option1：通过fastboot命令刷入Recovery"><a href="#Option1：通过fastboot命令刷入Recovery" class="headerlink" title="Option1：通过fastboot命令刷入Recovery"></a>Option1：通过fastboot命令刷入Recovery</h4><p>先将手机切换到Bootloader模式，用USB连接手机到电脑，并且确认它已经处于待调试的状态，比如输入 <code>adb devices</code> ，显示出你的设备，并且状态是device，输入命令</p><pre><code class="language-sh">adb reboot bootloader</code></pre><p>等待手机重启到bootloader模式，大概在你准备看的时候，它已经准备好了。</p><blockquote><p>这里需要提醒的是，bootloader模式下的操作非常危险，bootloader程序是手机在装载系统时运行的程序，同时它也承担着通过软件方式自我更新系统的任务，比较类似我们常见的BIOS，但BIOS好在一般是固件程序。总之，弄坏了bootloader，要么换主板，要么让厂家通过JTAG之类的硬件的方式重新刷入bootloader，简而言之，就是废了。不过也没有那么可怕，只要不执行fastboot命令中有关bootloader的命令，一般也不会有事儿。</p></blockquote><p>用fastboot命令，刷入你已经准备好的recovery</p><pre><code class="language-sh">fastboot flash recovery [你的recovery路径]</code></pre><p>随后就等待Recovery刷入完成吧！</p><h3 id="Option2：Recovery下通过命令直接刷入（需要Root）"><a href="#Option2：Recovery下通过命令直接刷入（需要Root）" class="headerlink" title="Option2：Recovery下通过命令直接刷入（需要Root）"></a>Option2：Recovery下通过命令直接刷入（需要Root）</h3><p>这种方法适合已经Root过，但想更换Recovery的朋友，这里也顺便说下，就一个命令，在 adb shell 下或者手机本地终端su进入Root用户后使用</p><pre><code class="language-sh">dd if=/sdcard/recovery.img of=/dev/recovery</code></pre><p>下面还是来解释下这个命令吧，dd是Linux自带的一个复制文件的命令，并在复制的同时可以进行指定的转换，<code>if</code> 后跟的是源路径， <code>of</code> 后跟的是目标路径，这个命令即是把/sdcard/目录下的recovery.img文件复制到 /dev/recovery .</p><p>到这里，相信Recovery这里没啥疑问啦。</p><h2 id="制作Recovery升级包"><a href="#制作Recovery升级包" class="headerlink" title="制作Recovery升级包"></a>制作Recovery升级包</h2><p>有了强大的Recovery之后，我们就需要制作一个Recovery的升级包，来直接替换掉系统自带的su文件，这里Recovery升级包主要是靠一个脚本语言——updater-script，来实现替换系统文件的自动化操作。</p><h3 id="updater-script"><a href="#updater-script" class="headerlink" title="updater-script"></a>updater-script</h3><p>updater-script目前的格式是Edify语言，它几乎每一条语句都是一个函数，我们主要看看Edify语言的语法格式。</p><h4 id="Edify语法"><a href="#Edify语法" class="headerlink" title="Edify语法"></a>Edify语法</h4><p>我们主要看看这次制作升级包所用到的函数，更详细语法有兴趣的可以查看<a href="http://blog.csdn.net/tody_guo/article/details/7948083" target="_blank" rel="noopener">tody_guo的专栏 - Android updater-scripts(Edify Script)各函数详细说明</a></p><p><strong><em>1. ui_print</em></strong>  </p><ul><li>原型：uiprint(msg1, …, msgN);</li><li>功能：该函数用于在Recovery界面输出字符串， 其中msg1 - msgN表示N个字符串参数，它至少要指定一个参数，如果指定多个，会将这些参数值连接起来输出。</li><li>用法：ui_print(“ hello world “);</li></ul><p><strong><em>2. run_program</em></strong> </p><ul><li>原型：run_program(prog, arg1, …, argN);</li><li>功能：该函数用于执行程序，其中prog参数表示要执行的程序文件（完整路径）， arg1 - argN 表示要执行程序的参数发。prog参数是必须的，其他参数可选</li><li>用法：run_program(“/sbin/busybox”, “mount”, “/system”);</li></ul><p><strong><em>3. delete</em></strong></p><ul><li>原型：delete(file1, file2, …, fileN);</li><li>功能：该函数用于删除一个或多个文件。其中file、file2、…、fileN表示要删除文件的路径，至少需要指定一个文件。</li><li>用法：delete(“/system/xbin/su”);</li></ul><p><strong><em>4. package_extract_dir</em></strong></p><ul><li>原型：package_extract_dir(package_path, destination_path);</li><li>功能：用于提取刷机包中package_path指定目录的所有文件到destination_path指定的目录。其中package_path参数表示刷机包中的目录，destination_path参数表示目标目录。</li><li>用法：package_extract_dir(“system”, “/system”);</li></ul><p><strong><em>5. set_perm</em></strong></p><ul><li>原型：set_perm(uid, gid, mode, file1, file2, …, fileN);</li><li>功能：用于设置一个或多个文件的权限。其中uid参数表示用户ID，gid参数表示用户组ID。如果想让文件的用户和用户组都是Root，uid和gid需要为0。mode参数表示设置的权限。与chmod命令相似。</li><li>用法：set_perm(0, 0, 0777, “/system/xbin/su”);</li></ul><p><strong><em>6. mount</em></strong></p><ul><li>原型：mount(fs_type, partition_type, location, mount_point);</li><li>功能：挂载分区</li><li>用法：mount(“ext4”, “EMMC”, “/dev/block/platform/s3c-sdhci.0/by-name/system”, “/system”);</li></ul><p><strong><em>7. unmount</em></strong></p><ul><li>原型：unmount(mount_point);</li><li>功能：用于解除文件系统的挂载。其中mount_point参数表示文件系统。</li><li>用法：unmount(“/system”);</li></ul><h4 id="编写脚本文件"><a href="#编写脚本文件" class="headerlink" title="编写脚本文件"></a>编写脚本文件</h4><p>了解了基本的语法后，就可以来编写个简单的替换系统文件的脚本了，我们主要进行的操作如下</p><ul><li>以读写模式挂载/system</li><li>删除旧的su文件</li><li>复制新的su文件</li><li>修改su文件的权限</li><li>卸载/system</li></ul><p>根据以上步骤，这里直接给上脚本</p><pre><code class="language-sh">ui_print(&quot;----------------------&quot;);ui_print(&quot;Recovery Upgrade Package&quot;);ui_print(&quot;----------------------&quot;);ui_print(&quot;--- Mounting /system ---&quot;);#以读写模式挂载/systemrun_program(&quot;/sbin/busybox&quot;, &quot;mount&quot;, &quot;-o&quot;, &quot;rw&quot;, &quot;/system&quot;);ui_print(--- Delete /system/xbin/su ---);#删除旧的su文件delete(&quot;/system/xbin/su&quot;);ui_pirnt(&quot;--- Extracting system to /system ---&quot;);#将刷机包中的system目录的所有文件复制到/system目录中的相应位置package_extract_dir(&quot;system&quot;, &quot;/system&quot;);#给su命令添加可执行权限set_perm(0, 0, 0777, &quot;/system/xbin/su&quot;);#卸载/systemunmount(/system);ui_print(&quot;--- finished ---&quot;);</code></pre><h3 id="升级包制作"><a href="#升级包制作" class="headerlink" title="升级包制作"></a>升级包制作</h3><p>制作Recovery升级包需要两个目录</p><ul><li>META-INF/com/google/android</li><li>system/xbin</li></ul><p>前者用来放我们制作的updater-script文件，在 <code>META-INF/com/google/android</code> 目录下还有一个 <code>update-binary</code> 的文件，它是用来解析我们制作的updater-script文件，把su放在 <code>system/xbin</code> 目录下。</p><blockquote><p>目录中的其他东西，可以找一个现成任意的Recovery升级包，把内容复制过来就行了</p></blockquote><p>最后，把这两个目录压缩成 <code>.zip</code> 文件， 升级包就制作完成了。</p><h1 id="替换su文件"><a href="#替换su文件" class="headerlink" title="替换su文件"></a>替换su文件</h1><p>有了升级包之后，我们要做的就是在Recovery里面安装这个升级包，通过adb shell进入recovery模式</p><pre><code class="language-sh">adb reboot recovery</code></pre><p>在Recovery模式下，我们可以直接用 adb 操作这个升级包，比如先push到sdcard里面，然后在Recovery里面手动的选择在sdcard里面找到并安装这个升级包，另外我们也可以通过一个adb命令直接push并安装这个升级包</p><pre><code class="language-sh">adb sideload update.zip</code></pre><p>它会首先将updata.zip下载到手机中，并且执行安装，这里的updata.zip是升级包的路径，而非单单名字。</p><h2 id="使用su命令提取Root权限"><a href="#使用su命令提取Root权限" class="headerlink" title="使用su命令提取Root权限"></a>使用su命令提取Root权限</h2><p>su文件替换完之后，我们就可以通过各种方法获取到Root权限</p><h3 id="在终端中执行su命令提取Root权限"><a href="#在终端中执行su命令提取Root权限" class="headerlink" title="在终端中执行su命令提取Root权限"></a>在终端中执行su命令提取Root权限</h3><p>无论在pc上的adb shell命令还是手机的本地终端，正如我们开篇所说的，直接输入su，即可获取Root权限。</p><h3 id="在App中使用Root权限"><a href="#在App中使用Root权限" class="headerlink" title="在App中使用Root权限"></a>在App中使用Root权限</h3><pre><code class="language-sh">Runtime.getRuntime().exec(&quot;su&quot;);OutputStream os = process.getOutputStream();os.write(&quot;ls /system/app&quot;.getBytes());os.flush();os.close();</code></pre><p>这段代码还没有进行尝试，之后会写个删除系统自带软件的程序来验证下。</p><h2 id="su命令源代码解析"><a href="#su命令源代码解析" class="headerlink" title="su命令源代码解析"></a>su命令源代码解析</h2><p>Android源代码上su.c文件</p><pre><code class="language-c">/* ** ** Copyright 2008, The Android Open Source Project ** ** Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);  ** you may not use this file except in compliance with the License.  ** You may obtain a copy of the License at  ** **     http://www.apache.org/licenses/LICENSE-2.0  ** ** Unless required by applicable law or agreed to in writing, software  ** distributed under the License is distributed on an &quot;AS IS&quot; BASIS,  ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  ** See the License for the specific language governing permissions and  ** limitations under the License. */  #define LOG_TAG &quot;su&quot;  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #include &lt;sys/types.h&gt;  #include &lt;dirent.h&gt;  #include &lt;errno.h&gt;  #include &lt;unistd.h&gt;  #include &lt;time.h&gt;  #include &lt;pwd.h&gt;  #include &lt;private/android_filesystem_config.h&gt;  /*  * SU can be given a specific command to exec. UID _must_ be  * specified for this (ie argc =&gt; 3).  *  * Usage:  * su 1000  * su 1000 ls -l  */  int main(int argc, char **argv)  {      struct passwd *pw;      int uid, gid, myuid;      if(argc &lt; 2) {          uid = gid = 0;      } else {          pw = getpwnam(argv[1]);          if(pw == 0) {              uid = gid = atoi(argv[1]);          } else {              uid = pw-&gt;pw_uid;              gid = pw-&gt;pw_gid;          }      }      /* Until we have something better, only root and the shell can use su. */      myuid = getuid();      if (myuid != AID_ROOT &amp;&amp; myuid != AID_SHELL) {          fprintf(stderr,&quot;su: uid %d not allowed to su\n&quot;, myuid);          return 1;      }      if(setgid(gid) || setuid(uid)) {          fprintf(stderr,&quot;su: permission denied\n&quot;);          return 1;      }      /* User specified command for exec. */      if (argc == 3 ) {          if (execlp(argv[2], argv[2], NULL) &lt; 0) {              fprintf(stderr, &quot;su: exec failed for %s Error:%s\n&quot;, argv[2],                      strerror(errno));              return -errno;          }      } else if (argc &gt; 3) {          /* Copy the rest of the args from main. */          char *exec_args[argc - 1];          memset(exec_args, 0, sizeof(exec_args));          memcpy(exec_args, &amp;argv[2], sizeof(exec_args));          if (execvp(argv[2], exec_args) &lt; 0) {              fprintf(stderr, &quot;su: exec failed for %s Error:%s\n&quot;, argv[2],                      strerror(errno));              return -errno;          }      }      /* Default exec shell. */      execlp(&quot;/system/bin/sh&quot;, &quot;sh&quot;, NULL);      fprintf(stderr, &quot;su: exec failed\n&quot;);      return 1;  }  </code></pre><p>从main函数的源代码中可以看到</p><pre><code class="language-c">/* Until we have something better, only root and the shell can use su. */  myuid = getuid();  if (myuid != AID_ROOT &amp;&amp; myuid != AID_SHELL) {      fprintf(stderr,&quot;su: uid %d not allowed to su\n&quot;, myuid);      return 1;  }  </code></pre><p>这个函数可以看出，su文件检测当前用户如果不是Root用户或者Shell用户，将会直接退出su命令。</p><pre><code class="language-c">if(argc &lt; 2) {      uid = gid = 0;  } else {      pw = getpwnam(argv[1]);      if(pw == 0) {          uid = gid = atoi(argv[1]);      } else {          uid = pw-&gt;pw_uid;          gid = pw-&gt;pw_gid;      }  }  </code></pre><p>如果参数小于2，uid（将要切换的用户id）和gid（将要切换的用户组id）都会切换到Root用户和Root用户组，C语言中如果一个命令不加任何参数，argc值就等于1，也就是说，如果你只输入了su命令，将自动切换到Root用户和Root用户组。</p><pre><code class="language-c">if(setgid(gid) || setuid(uid)) {      fprintf(stderr,&quot;su: permission denied\n&quot;);      return 1;  }</code></pre><p>setgid和setuid函数是最关键的获取Root权限的函数，如果设置成功则返回0，所以只有当两个函数返回都为0的时候，才算成功获取Root权限。</p><pre><code class="language-c">/* Default exec shell. */  execlp(&quot;/system/bin/sh&quot;, &quot;sh&quot;, NULL);  </code></pre><p>这段代码将当前进程替换成一个新进程，也就是以Root用户登录的一个新的Shell。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>有关Android设备提取Root权限最基本的原理就是这些了，但一般情况下往往没这么简单，我们也知道不同的机型Root的方式也不一样，因为厂商对待Root设备的态度不一样，有的坚决反对，有的不鼓励不支持，有的想方设法阻止你Root，或者只有Nexus系列的原生系统才会如此的简单吧，但万变不离其宗，原理上不会差太多，对以后的学习也是一个基础。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计没那么简单</title>
      <link href="/2016/03/11/design-logo/"/>
      <url>/2016/03/11/design-logo/</url>
      
        <content type="html"><![CDATA[<p>以前总觉得，设计就那么回事儿 ，又自信的认为我的审美没有顶尖也是一流了，所以我喜欢设计，但“喜欢”了这么久，从来没真正的入坑过，所以对设计的喜爱至少比不上编程。</p><p>最近初学Android想找个项目练手，自己准备做的项目当时还没构思完成，刚好学弟今年毕业，做的毕业设计简单来说是控制电机的，所以我就“毛遂自荐”的帮学弟做一个手机端的蓝牙控制&amp;反馈的App。</p><a id="more"></a><p>然后某天想到了设计图标，我觉得我不能过于纠结外在，而应该把重点放在软件的易用和稳定性上，所以一开始我打算随便做个草草了事儿了，比如这样：</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/ic_launcher1.png" alt></p><p>简单的直接一个M代表这是控制电机（Motor）的，但不知道怎么脑抽选了暗红的颜色，看着始终别扭，并且这怎么着也算我正式的第一个Android App，所以我打算以我“强大的审美”能力，来设计一个图标，又考虑到图标嘛要足够简单、抽象，所以设计了这样的：</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/ic_launcher2_1.png" alt></p><p>嗯，看着还不错，一个够抽象的电机，上面长了一根天线，然后有信号传出去，多简单吧，又加了光线的阴影啥的，虽然哪里还觉得不对但比第一个还好吧，好吧，吧</p><p>于是放在手机上看看</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/ic_launcher2_2.png" alt></p><p>(；°○° )<br>卧槽这是什么鬼！！<br>简直丑爆了好吗？<br>那个M都看不清了好吗？？</p><p>。_。</p><p>设计没有我想的那么简单，我觉得我图标上的信息已经够少了，但还是东西太多，还是不够简约，回想下，我那个绿色背景简直没起到任何作用，并且过于依赖用线条来表现事物。</p><p>简单</p><p>简单</p><p>简单</p><p>突然灵机一动，我又改成了这样</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/ic_launcher3.png" alt></p><p>哈哈哈哈哈哈，我好有才啊（啪啪啪）</p><p>看似和第一个图标很像，但实际上完全不同，这个是简约，那个叫简陋，一个M代表电机，一个信号的波纹，代表这个电机是可以通过无线控制的，简单明了</p><p>经过这次事情，明显的感觉到，审美和设计不是一回事儿，有审美并不代表一定能设计出来好东西，设计过这个图标后，我之后到酷市场下载东西，都会在意的看一下这个软件的图标是怎么设计的，感觉哪个都比我设计的好，各有千秋</p><p><strong><em>路漫漫其修远兮 吾将上下而求索</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> writing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次折腾刷机的经历</title>
      <link href="/2016/02/06/adb-shell/"/>
      <url>/2016/02/06/adb-shell/</url>
      
        <content type="html"><![CDATA[<p>这两天在折腾华为荣耀3C，型号是H30-T00/1G RAM，芯片是MediaTek6582，ROOT之后先是刷了个TWRP（Team Win Recovery Project）的recovery，之后又刷过CM12.1、MIUI7等第三方ROM，这些ROM大多基于华为官方的B268/Android4.4修改。<br>哦这里话说回来，手机是我爸的:P .于是在强权逼迫下，我不得不寻找把它刷回去的办法（非官方包在通话时均没有扬声器输入），官方的卡刷包各种不好找领导又催的紧，惹急了直接找了个据说是官方的线刷包，用MediaTek的Smart Phone Flash Tools直接把整个包刷进去，果不其然出问题了，各种系统刷之后都无法开机，卡在系统启动的动画里。<br>之后又找了个据说是官方的线刷包刷了进去，直接连recovery都被替换了，官方的各种救砖工具都能成功使用，却没有任何效果，真正的官方升级包无法输入，说是分区有问题。</p><a id="more"></a><h2 id="前言有点儿长，正篇开始。"><a href="#前言有点儿长，正篇开始。" class="headerlink" title="前言有点儿长，正篇开始。"></a>前言有点儿长，正篇开始。</h2><p>首先用SPflash工具把TWRP的Recovery又重新刷了进去，在里面擦除分区时发现，data分区和cust分区（华为自己的分区）都无法挂载，使用Recovery自己的工具把data分区重新格式化，正常挂载了，但是cust还是不行。</p><p>查看当前已有的分区</p><pre><code class="language-console">~ # cat /proc/partitions major minor  #blocks  name 179        0    3830784 mmcblk0 179        1          1 mmcblk0p1 179        2      10240 mmcblk0p2 179        3      10240 mmcblk0p3 179        4       6144 mmcblk0p4 179        5    1048576 mmcblk0p5 179        6     196608 mmcblk0p6 179        7     129024 mmcblk0p7 179        8    2375168 mmcblk0p8 179       64       2048 mmcblk0boot1 179       32       2048 mmcblk0boot0 179       96    3872768 mmcblk1 179       97    3870720 mmcblk1p1</code></pre><p>这里能看到，共有两个disk，分别是mmcblk0和mmcblk1，其中前者被分为10个小分区。后者就是SD card</p><p>查看系统挂载的分区</p><pre><code class="language-console">~ # df -amFilesystem           1M-blocks      Used Available Use% Mounted ontmpfs                      483         0       483   0% /devdevpts                       0         0         0   0% /dev/ptsproc                         0         0         0   0% /procsysfs                        0         0         0   0% /sys/dev/block/mmcblk0p8      2287      1157      1130  51% /data/dev/block/mmcblk0p8      2287      1157      1130  51% /sdcard/dev/block/mmcblk0p7       124         4       120   3% /cache/dev/block/mmcblk1p1      3772      2751      1021  73% /external_sd</code></pre><p>上面能看到已经挂载分区的大小和对应的文件系统分区，但是华为的cust无法挂载，查看/etc/fstab文件系统分区表</p><pre><code class="language-console">/dev/block/mmcblk0p5 /system ext4 rw/dev/block/mmcblk0p8 /data ext4 rw/dev/block/mmcblk0p6 /cust ext4 rw/dev/block/mmcblk0p7 /cache ext4 rw/dev/block/mmcblk1p1 /external_sd vfat rw</code></pre><p>手动挂载cust分区</p><pre><code class="language-console">mount /dev/block/mmcblk0p6 /cust或mount /cust</code></pre><p>提示无效参数，怀疑是mmcblk0p6分区损坏，于是把cache卸载，把cust挂载到mmcblk0p7上，果然成功挂载，于是执行</p><pre><code class="language-sh">make_ext4fs /dev/block/mmcblk0p6</code></pre><p>重新挂载/cust分区，果然成功挂载，至此Recovery已经没有任何报错，重新把/system、/data等等分区全部重新格式化，重新安装lollipop，然而结果没变，还是卡在开机画面。当时和某个QQ群里的“大神”交流了下，“大神”呵呵一笑：不用想了，字库坏了。（一般情况下，字库坏了=主板坏了，不能修）</p><p>说到字库这个词我也想呵呵，手机字库什么的就是Flash，叫的这么不近人情，然而我可以肯定的是，我的“字库肯定没坏啊”，因为我刚刚还在对它进行格式化的操作。</p><p>于是我用ADB进入手机的shell，用刚刚的格式化操作，对前面几个小分区全部格式化了一遍</p><pre><code class="language-sh">make_ext4fs /dev/block/mmcblk0p2make_ext4fs /dev/block/mmcblk0p3make_ext4fs /dev/block/mmcblk0p4</code></pre><p>重新开机，一切正常～～</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这次事情是在刷机的过程中，用一些简单的ADB Shell命令解决了手机系统无法开机的一些问题，Android                      Shell还有更多强大的功能还没用过，并且本文只是记载了自己遇到的问题，仅能做为参考，切勿照搬。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> adb </tag>
            
            <tag> rom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试ADB连接</title>
      <link href="/2016/02/06/adb-connect/"/>
      <url>/2016/02/06/adb-connect/</url>
      
        <content type="html"><![CDATA[<p>很早就会各种刷机，用各种工具，但始终没正式的接触过ADB（Android Debug Bridge），最近才熟悉了下它。首先是连接方式：USB和Wi-Fi</p><h3 id="USB连接"><a href="#USB连接" class="headerlink" title="USB连接"></a>USB连接</h3><p>首先是显示当前连接的设备</p><pre><code class="language-sh">adb devices</code></pre><p>如果有设备通过USB成功连接，会显示如下：</p><pre><code class="language-sh">List of devices attached0123456789ABCDEF    device</code></pre><p>左边的是设备的名字，右边的device代表设备的状态，目前见到过的状态</p><pre><code class="language-sh">device            - 设备通过USB连接成功offline           - 设备的adb usb服务没有启动no permissions    - 需要通过root权限重启adb serverunauthorized      - Android4.4之后，需要在设备上对计算机授权才可调试</code></pre><p>如果出现了上面的no permissions的状态，在teminal进入root用户，或者前面加sudo</p><a id="more"></a><pre><code class="language-sh">adb kill-serveradb devices</code></pre><p>其中，执行<code>adb devices</code>时，adb会首先默认执行<code>adb start-server</code>，之后可以<code>Ctrl+A+D</code>退出root用户，设备应该会是device状态。（调试OPPO U705T - Android4.1时遇到）</p><p>接下来，只要设备是device状态，就可以对它执行各种push、pull、install、shell的命令了。</p><h3 id="Wi-FI连接"><a href="#Wi-FI连接" class="headerlink" title="Wi-FI连接"></a>Wi-FI连接</h3><p>USB一直连着，当然可以保证手机电量是满的，但是如果像我这样笔记本拿来拿去，手机一直挂在上面挺不方便的，这时候就可以用到Wi-Fi连接了，在CM12.1上的开发者选项里直接有<strong>网络ADB调试</strong>的选项，在Android4.1上并没有。这时候就需要我们手动改变它的连接方式了。</p><p>用USB把手机连接到电脑，前提是保证它是device状态，执行<br><code>adb tcpip 5555</code><br>5555是默认端口，可以自己修改，前提是没被其他的进程监听占用。这个命令，嗯我失败了，最保险的办法是在手机上的本地终端，输入su获取root权限，然后执行</p><pre><code class="language-sh">stop adbdsetprop service.adb.tcp.port 5555start adbd</code></pre><p>然后就可以在电脑的teminal上</p><pre><code class="language-sh">adb connect &amp;lt;remotehost&amp;gt;</code></pre><p>其中<code>remotehost</code>是你手机在局域网中的ip地址，这里不需要特别标明端口，我这里是192.168.1.113，结果如下</p><pre><code class="language-sh">liangzr@acer:~$ adb connect 192.168.1.113connected to 192.168.1.113:5555liangzr@acer:~$ adb devicesList of devices attached192.168.1.113:5555    device0123456789ABCDEF    device</code></pre><p>这个时候就可以断开USB来调试了，用Wi-Fi调试和用USB一样一样的，只是在下载速度上会有些慢。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实上面的好多操作，都可以直接在手机的本地终端里完成，并且个别问题的原因并不是很清楚，只是在Google上找到了答案，另外，附送一个国外大神的Script切换USB和Wi-Fi方式。</p><p><a href="https://gist.github.com/liangzr/3efa2aa4fec07fe60a83" target="_blank" rel="noopener">adbwifi.sh</a> - 脚本转自<a href="http://www.stormzhang.com/android/2014/08/27/adb-over-wifi/" target="_blank" rel="noopener">Android通过Wifi来调试你的应用 - stormzhang博客</a></p><p>adbwifi.sh内容：</p><pre><code class="language-sh">#!/bin/bash#Modify this with your IP rangeMY_IP_RANGE=&quot;192\.168\.1&quot;#You usually wouldn&#39;t have to modify thisPORT_BASE=5555#List the devices on the screen for your viewing pleasureadb devicesecho#Find USB devices only (no emulators, genymotion or connected devicesdeclare -a deviceArray=(`adb devices -l | grep -v emulator | grep -v vbox | grep -v &quot;${MY_IP_RANGE}&quot; | grep &quot; device &quot; | awk &#39;{print $1}&#39;`)  echo &quot;found ${#deviceArray[@]} device(s)&quot;echofor index in ${!deviceArray[*]}doecho &quot;finding IP address for device ${deviceArray[index]}&quot;IP_ADDRESS=$(adb -s ${deviceArray[index]} shell ifconfig wlan0 | awk &#39;{print $3}&#39;)echo &quot;IP address found : $IP_ADDRESS &quot;echo &quot;Connecting...&quot;adb -s ${deviceArray[index]} tcpip $(($PORT_BASE + $index))adb -s ${deviceArray[index]} connect &quot;$IP_ADDRESS:$(($PORT_BASE + $index))&quot;echoechodoneadb devices -l#exit&lt;/pre&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> adb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易shell script实现ssh登陆</title>
      <link href="/2016/01/07/easy-shell-script-ssh-login/"/>
      <url>/2016/01/07/easy-shell-script-ssh-login/</url>
      
        <content type="html"><![CDATA[<p>因为想每次管理服务器都要手动输入<code>ssh user@remotehost</code>然后输入密码才能进去，并且经常隔2-3分钟不去管它，控制台就无响应了，所以我就想写个脚本实现自动登陆和无响应重连。于是</p><ul><li>想写个脚本去</li><li>找到篇Advanced Bash-scripting Guide, 想创建一个Github repository来整理</li><li>在2048KB创建个page来收录Github repository, 嫌网站字体太难看要更改字体</li><li>在<code>.css</code>文件里更改font-family由于文件太多又去学了正则表达式</li><li>修改完后发现没效果, 更改<code>.css</code>的font-face实现修改<br>好，还是说正事儿。</li></ul><a id="more"></a><h2 id="Option-1-仅实现登陆"><a href="#Option-1-仅实现登陆" class="headerlink" title="Option 1: 仅实现登陆"></a>Option 1: 仅实现登陆</h2><hr><p>最简单的实现手动的登陆，可以用expect工具来实现，在Ubuntu下需要下载：<br><code>sudo apt-get install expect</code><br>Expect中最关键的四个命令是：</p><ul><li>send：用于向进程发送字符串</li><li>xpect：从进程接收字符串</li><li>spawn：启动新的进程</li><li>interact：允许用户交互</li></ul><p>实现如下：</p><pre><code class="language-sh">#!/usr/bin/expectspawn ssh user@remotehostexpect &quot;*password:&quot;send &quot;userpwd\r&quot;expect &quot;*#&quot;interact</code></pre><p>添加执行权限</p><pre><code class="language-sh">sudo chmod +x ssh-script.sh</code></pre><p>运行以上ssh-script.sh就可以登陆了，也可以把用户命令放入<code>～/bin</code>，在Linux的很多发行版本中默认PATH都加入了这个目录，在Ubuntu上只要在用户根目录下建立了bin文件夹，下次登陆时会自动添加进PATH，如果要手动修改则打开.bashrc文件</p><pre><code class="language-sh">sudo vi ~/.bashrc</code></pre><p>文件末添加</p><pre><code class="language-sh">export PATH = ~/bin:$PATH</code></pre><p>生效改动</p><pre><code class="language-sh">source ~/.bashrc</code></pre><p>这样在teminal里输入ssh-script.sh就能一键登陆VPS了，如果嫌后缀麻烦，可以……删掉好了：P</p><p>未完</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/1970/01/01/hello-world/"/>
      <url>/1970/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
