<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何按原顺序打印出对象的属性？</title>
      <link href="/2019/03/09/how_to_print_properties_of_the_object_by_originally/"/>
      <url>/2019/03/09/how_to_print_properties_of_the_object_by_originally/</url>
      
        <content type="html"><![CDATA[<p>昨天在群里看到有人问:</p><blockquote><p>网友：“<strong>Object.keys会给值排序，那用哪个方法取对象属性能不排序的？</strong>”<br>我：“对象的属性有顺序吗？”<br>网友：“这个就会按照从小到大排序，我只是想保持原样~~” (如下)<br>我：”for…in 应该不会”<br>……</p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0wixmegiij30gk02vglu.jpg" alt></p><p>结果我试了下发现 <code>for..in</code> 也会，最终我试了六种方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.keys(obj)                          <span class="comment">// ["2", "7", "100"]</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj)                        <span class="comment">// ["b", "c", "a"]</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj)                       <span class="comment">// "2,b,7,c,100,a", toString() 之后</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123; <span class="built_in">console</span>.log(key) &#125;     <span class="comment">// 2, 7, 10</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)           <span class="comment">// ["2", "7", "100"]</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)                      <span class="comment">// ["2", "7", "100"]</span></span><br></pre></td></tr></table></figure><p>可以看到，以上方法都无一例外地以 <code>{ 2: &#39;b&#39;, 7: &#39;c&#39;, 100: &#39;a&#39; }</code> 的方式打印出了相关值，那这个问题的影响在哪里呢？</p><a id="more"></a><p>假如你从接口中获取一段 JSON 数据如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"100"</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="string">"2"</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="string">"7"</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面个数据可能是经过后端排序的，并且数据中并没有带有可供排序的信息，毫无疑问经过 JS 的重新排序后，它的排序信息就丢失了，假如我就是不想丢失呢？</p><p>欲知其然，先知其所以然。在了解它如果遍历属性之前，首先我们需要知道的是，在 V8 中对象是如何存储属性的呢？</p><h2 id="V8-中对象的属性"><a href="#V8-中对象的属性" class="headerlink" title="V8 中对象的属性"></a>V8 中对象的属性</h2><p>在 JavaScript 中，大部分时候对象的行为类似一个字典，它以字符串做为键名，以任意对象作为值。虽然在迭代的时候，规范约定了以不同的方式处理整数索引属性和其他属性。</p><p>下面我们先来解释下整数索引属性和命名属性的区别。</p><h3 id="Named-properties-vs-elements"><a href="#Named-properties-vs-elements" class="headerlink" title="Named properties vs. elements"></a>Named properties vs. elements</h3><p>先来假设一个简单的对象 <code>{a: &#39;foo&#39;, b: &#39;bar&#39;}</code>。该对象有两个命名属性,<code>a</code> 和 <code>b</code>，它没有整数索引。整数索引属性（通常叫做元素element）在数组中比较常见，如 <code>[&#39;foo&#39;, &#39;bar&#39;]</code> 有两个整数索引，分别为 0 和 1。这是 V8 处理属性的第一个主要区别。</p><p><img src="https://v8.dev/_img/fast-properties/jsobject.png" alt></p><p>元素和属性存储在两个独立的数据结构中，这使得添加和访问属性或元素，在不同的场景下都更有效率。</p><p>元素主要用于 <code>Array.prototype</code> 的各种方法，鉴于这些函数访问的是连范围内的属性，V8 在内部也将他们表示为简单数组（在大多数情况下是这样的，有时会切换到基于稀疏字典的形式来节省内存）</p><p>命名属性以类似的方式存储在单独的数组中。但是与元素不同的是，我们不能使用简单的键来推断他们在属性数组中的位置，我们需要一些额外的元数据。在 V8 中，每个 JavaScript 对象都有一个关联的 HiddenClass，它用来存储对象的结构信息，以及从属性名到属性数组的索引的一个映射关系。对于复杂的情况，通常会使用一个字典来存储属性信息，而不是一个简单的数组。</p><blockquote><p>更详细的内容请阅读 V8 博客的文章 <a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">Fast properties in V8</a></p></blockquote><h2 id="如何遍历对象的属性"><a href="#如何遍历对象的属性" class="headerlink" title="如何遍历对象的属性"></a>如何遍历对象的属性</h2><p>通过查询 ECMA 262 规范我们可以看到，第一节中我们使用的六种遍历属性的方法，在类似的情况下，最终都会返回 <code>Obj.[[OwnPropertyKeys]]</code> 的结果。</p><p>按照 ECMA 262 中对 <code>[[OwnPropertyKeys]]</code> 的<a href="https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" target="_blank" rel="noopener">定义</a>：</p><blockquote><p>When the <code>[[OwnPropertyKeys]]</code> internal method of O is called, the following steps are taken:</p><ol><li>Return ! OrdinaryOwnPropertyKeys(O).</li></ol></blockquote><p>它返回了一个 <code>OrdinaryOwnPropertyKeys(O)</code> 的处理结果，而 <code>OrdinaryOwnPropertyKeys(O)</code> 的执行过程则是：</p><blockquote><p>When the abstract operation OrdinaryOwnPropertyKeys is called with Object O, the following steps are taken:</p><ol><li>Let <code>keys</code> be a new empty List.</li><li>For each own property key <code>P</code> of <code>O</code> that is an array index, in ascending numeric index order, do<br>a. Add <code>P</code> as the last element of <code>keys</code>.</li><li>For each own property key <code>P</code> of <code>O</code> that is a String but is not an array index, in ascending chronological order of property creation, do<br>a. Add <code>P</code> as the last element of <code>keys</code>.</li><li>For each own property key <code>P</code> of <code>O</code> that is a Symbol, in ascending chronological order of property creation, do<br>b. Add P as the last element of <code>keys</code>.</li><li>Return <code>keys</code>.</li></ol></blockquote><p>我们来简单描述下上述过程就是：首先创建一个名为 <code>keys</code> 的空数组，然后先遍历对象中的数组索引的属性，结果以升序排列，并逐个放入 <code>keys</code> 中；再遍历字符串属性（但不是数组索引），以属性创建时间升序排列，并逐个放入 <code>keys</code> 中去；然后再遍历 Symbol 类型的属性名，同样以属性创建时间升序排列，放入 <code>keys</code> 中，最后返回 <code>keys</code> 数组。</p><p>下来我们来验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">  <span class="number">7</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="number">6</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'a'</span>)]: <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line">a.d = <span class="number">8</span></span><br><span class="line">a[<span class="built_in">Symbol</span>(<span class="string">'b'</span>)] = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(a)</span><br></pre></td></tr></table></figure><p>output(devtools):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">9</span>) [<span class="string">"1"</span>, <span class="string">"7"</span>, <span class="string">"10"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="built_in">Symbol</span>(a), <span class="built_in">Symbol</span>(b)]</span><br><span class="line">  <span class="number">0</span>: <span class="string">"1"</span></span><br><span class="line">  <span class="number">1</span>: <span class="string">"7"</span></span><br><span class="line">  <span class="number">2</span>: <span class="string">"10"</span></span><br><span class="line">  <span class="number">3</span>: <span class="string">"b"</span></span><br><span class="line">  <span class="number">4</span>: <span class="string">"a"</span></span><br><span class="line">  <span class="number">5</span>: <span class="string">"c"</span></span><br><span class="line">  <span class="number">6</span>: <span class="string">"d"</span></span><br><span class="line">  <span class="number">7</span>: <span class="built_in">Symbol</span>(a)</span><br><span class="line">  <span class="number">8</span>: <span class="built_in">Symbol</span>(b)</span><br><span class="line">  length: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>Chrome 的实现与规范的约定完全一致😕，所以至此我们知道它为什么打印出来是升序的了。</p><p>另外引用 Chromium 社区上 <a href="https://bugs.chromium.org/p/v8/issues/detail?id=164" target="_blank" rel="noopener">Issue 164: Wrong order in Object properties interation</a> 的讨论所述：</p><blockquote><p>There seems to be a widespread feeling that this used to work the way people expected it, but then the V8 team broke it in order to be mean.</p><p>What actually happened was that originally the order was completely arbitrary in V8.  At a later point it was changed so that non-numeric indices were in insertion order, and numeric indices were sometimes in insertion order.  Whether or not the numeric indices were in in insertion order was dependent on internal V8 heuristics that decide whether to use an array or a hash map implementation for the numeric indices.  Making heuristics in the V8 implementation visible in this way was felt to be undesirable so it was normalized so that numeric indices were always iterated in numeric order regardless of the internal representation.  Numeric iteration order was always a possibility, but with the last change it was made predictable.</p><p>There has never been any difference between the internal representation or iteration order of arrays vs. other objects in V8.</p><p>Here is an independent test of the way arrays and objects perform in various engines (a little out of date now): <a href="http://news.qooxdoo.org/javascript-array-performance-oddities-characteristics" target="_blank" rel="noopener">http://news.qooxdoo.org/javascript-array-performance-oddities-characteristics</a>  If this bug ever gets ‘fixed’ you can wave goodbye to some of the nice performance results in that graph.</p></blockquote><p>结合前面介绍的 V8 属性一节我们知道，数组属性总是存储在一个单独的空间（可能是数组，也可能是字典）。在这种情况下，始终以有序数组的状态输出键值，这样的结果是可预测的（始终一致）。并且在 V8 内部，数组的内部表示和迭代方式，和其它对象没有任何不同。</p><p>综上所讲，这样的内部实现，有性能的因素，也有历史原因。</p><h2 id="有没有办法按原顺序打印？"><a href="#有没有办法按原顺序打印？" class="headerlink" title="有没有办法按原顺序打印？"></a>有没有办法按原顺序打印？</h2><p>讲了那么多，我就是想按原顺序打印怎么办？</p><p>首先如果目标结构已经是 JavaScript 对象，应该是没有办法了。我们回到最终的问题，如果我们有一串 JSON 数组，想把它按原序获得键值，可以怎么做？假如我们有串数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"100"</span>:<span class="string">"foo"</span>,<span class="attr">"2"</span>:<span class="string">"bar"</span>,<span class="attr">"7"</span>:<span class="string">"baz"</span>&#125;</span><br></pre></td></tr></table></figure><p>首先能想到的一个简单的方法就是，自己写一个简单的 json-parser。</p><p>下面是一个简单的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonString = <span class="string">'&#123;"100":"foo","2":"bar","7":"baz"&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parseKeys = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> out = []</span><br><span class="line">  <span class="keyword">const</span> tokens = str.slice(<span class="number">1</span>, <span class="number">-1</span>).split(<span class="string">','</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    out.push(tokens[i].split(<span class="string">':'</span>)[<span class="number">0</span>].slice(<span class="number">1</span>, <span class="number">-1</span>))  </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try</span></span><br><span class="line"><span class="built_in">console</span>.log(parseKeys(jsonString))  <span class="comment">// ✅ ["100", "2", "7"]</span></span><br></pre></td></tr></table></figure><p>看起来我们得到了想要的结果（yeah），但是如果 json 数组稍微复杂点儿呢？</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"100"</span>:&#123;<span class="attr">"b"</span>:<span class="string">"foo"</span>&#125;,<span class="attr">"2"</span>:[<span class="number">1</span>,<span class="number">2</span>],<span class="attr">"7"</span>:<span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure><p>我们再来重构下这个解析器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parseKeys = <span class="function">(<span class="params">str, lvl = <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> out = []</span><br><span class="line">  <span class="keyword">let</span> level = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> matching = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> pair = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(i) === <span class="string">'"'</span> &amp;&amp; level === lvl) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!matching) &#123;</span><br><span class="line">        pair[<span class="number">0</span>] = i </span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        pair[<span class="number">1</span>] = i</span><br><span class="line">        out.push([...pair])</span><br><span class="line">      &#125;</span><br><span class="line">      matching = ~matching</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">'&#123;'</span>, <span class="string">'['</span>].indexOf(str.charAt(i) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      level += <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="string">'&#125;'</span>, <span class="string">']'</span>].indexOf(str.charAt(i) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      level -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out.map(<span class="function"><span class="params">pair</span> =&gt;</span> str.slice(pair[<span class="number">0</span>], pair[<span class="number">1</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output(devtools):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"100"</span>, <span class="string">"2"</span>, <span class="string">"7"</span>]</span><br></pre></td></tr></table></figure><p>上面这个方法执行效率并不高，只是提出一种思路，当然我们的目标还是解析出 key，而不是完整的引入一个 json 解释器，那样可能得不偿失。</p><p>更高效的解决方法，我们之后再补充…</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR;"></a>TL; DR;</h2><p>V8 在内部将命名属性和数组索引属性分开存储，并且数组和其它对象的内部实现和迭代机制是完全一致的。</p><p>由规范定义，对象在迭代的时候，总是以升序输出数组索引的属性。如果要解决这个问题，目前可能自己去解析 JSON 字符串。</p><p>更多问题的延伸讨论，请参考 Chromium 社区的 <strong>Issue: 164</strong> 讨论。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" target="_blank" rel="noopener">ECMA262 Specification - OwnPropertyKeys</a></li><li><a href="https://v8.dev/blog/fast-properties" target="_blank" rel="noopener">Fast properties in V8</a></li><li><a href="https://v8.dev/blog/fast-for-in" target="_blank" rel="noopener">Fast for-in in V8</a></li><li><a href="https://bugs.chromium.org/p/v8/issues/detail?id=164" target="_blank" rel="noopener">Issue 164: Wrong order in Object properties interation</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> v8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bye 2018, Hi 2019</title>
      <link href="/2019/02/01/2018/"/>
      <url>/2019/02/01/2018/</url>
      
        <content type="html"><![CDATA[<p>2018 年还没有沉淀什么就很快过去了，个人生活上也经历了比较重大的变动。</p><p>这一年在技术上感觉没有什么真正的积累，但这样说并不是指技术在原地踏步，这一年从一个「什么都可以尝试做」的前端，变成了一个「什么都可以 Hold 住」的前端。可问题就在于，知道的越多，越感到自己的无知，想学的太多太多，可有时间有精力学的却没多少。最终越学越浮躁，找不到方向，所以也没有特别深入的技术点。</p><p>我从来都认为自己是一个技术，而不只是前端，前端只是我的职业。作为一名技术人，一位工程师，在技术发展上我会有侧重点，但不会给自己设壁垒。本身我就是硬件出身，在大学的时候天天跑实验室折腾过两三年的嵌入式。所以我觉得为了实现一个产品，一个目标，遇到什么不会就学什么，这样才是正确的学习姿势。</p><p>但反过来就有一问，每个人的精力都是有限的，想全面发展的话，是不是就会没有深度？想以一抵十的话，是不是就会束手束脚，无法切中要害？我觉得非也。</p><a id="more"></a><p>全面发展不一定代表你要去精通后端，你要去赶区块链或机器学习的潮流，去成为里面的佼佼者。<strong>不要偏离你的侧重点，学习要有重心</strong>。举例来讲，假如你的方向是可视化，在深入过程中发现需要图形学的知识，不要望而却步果断去学。图形学是你的工具，你学习它的目标是推动你在可视化方面更进一步，而不是要在图形学上面有所建树，你可以把各种技术拼成你自己的一个专业知识体系。</p><p>都说初生牛犊不怕虎，还记得大学时候的我，从来没怕过学任何学科，无论想学什么想知道什么，去图书馆找本相关的书一看就是一下午。其实各个延伸学科也是建立在一众基础学科之上，只是了解一门学科真的没有那么难，在学习的过程中还可以融会贯通。但即使是我，现在也不太敢轻言去学好跟职业看似不太相关的东西。<strong>其实我觉得还是思维懒惰，不愿意脱离自己的舒适区，只想学简单易学有基础的东西，虽然没有降低对新生事物的敏锐度，但如果你生怯了，说明你的接受能力在下降</strong>。我觉得人要保持这种接受能力，不只是理解。</p><h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><p>虽然我自己觉得没有能够证明自己有沉淀的成果，但无论是生活还是学习，还是未来的方向，我都明确了很多。曾经和朋友讨论过很多次人在学习上的精力的话题，但现在我其实算是有结论了。精力是“无限”的，只要你的兴趣和接受能力能够维持。你可能永远无法像某些杰出的历史人物一样，既是物理学家，又是文学家，史学家，但你一定会有自己特别的收获。</p><h2 id="2019-生活-FLAG（持续更新）"><a href="#2019-生活-FLAG（持续更新）" class="headerlink" title="2019 生活 FLAG（持续更新）"></a>2019 生活 FLAG（持续更新）</h2><p>跨年之际，网易云音乐有个 H5 活动，生成新年 FLAG，当时就一口气写了下面这个列表这么长的 FLAG，好在其中有很多还是很有希望实现的！</p><p>下面这个列表持续更新，包括添加和删除～</p><ul><li style="list-style: none"><input type="checkbox" checked> 每顿少吃一口饭</li><li style="list-style: none"><input type="checkbox"> 和家人一起去旅行</li><li style="list-style: none"><input type="checkbox"> 2019 年我会有猫的！</li><li style="list-style: none"><input type="checkbox"> 自驾去西北</li><li style="list-style: none"><input type="checkbox"> 去上海看 TI9 中国夺冠</li><li style="list-style: none"><input type="checkbox" checked> 戒掉夜宵</li><li style="list-style: none"><input type="checkbox" checked> 周末不宅在家</li><li style="list-style: none"><input type="checkbox"> 打败拖延症</li><li style="list-style: none"><input type="checkbox" checked> 每天背 30 个单词</li><li style="list-style: none"><input type="checkbox" checked> 每周去 3 次健身房</li><li style="list-style: none"><input type="checkbox"> 跑一场半马</li><li style="list-style: none"><input type="checkbox"> 长（jian）胖（zhong）到 90 （gong）斤左右</li><li style="list-style: none"><input type="checkbox"> 看完 50 本书</li><li style="list-style: none"><input type="checkbox"> 半年不吃甜食</li></ul><h2 id="2019-技术-FLAG（持续更新）"><a href="#2019-技术-FLAG（持续更新）" class="headerlink" title="2019 技术 FLAG（持续更新）"></a>2019 技术 FLAG（持续更新）</h2><p>除了生活上的展望，技术上也应该给自己一些 FLAG，不管后面在哪个城市哪家公司，都为了让自己能有更好的沉淀。</p><p>学习是为了生活也更是因为兴趣，但有效的学习还是需要功利化，要看到成果，不然很容易就会误入道德许可的陷阱，沉浸在舒适区却浑然不知。</p><ul><li style="list-style: none"><input type="checkbox"> 参加一场深度学习公开赛并拿到名次</li><li style="list-style: none"><input type="checkbox"> 写《React 系列》和《前端 DevOps 入门》系列文章（一个系列十篇左右），每周至少一篇</li><li style="list-style: none"><input type="checkbox"> 学完 C++ Primer</li></ul><p><strong>2019，奠定基石！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「译」Why Do We Write super(props)?</title>
      <link href="/2018/11/30/fork__why_do_we_write_super/"/>
      <url>/2018/11/30/fork__why_do_we_write_super/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载并翻译于 <a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a> 的博客 <a href="https://overreacted.io/why-do-we-write-super-props/" target="_blank" rel="noopener">overreacted.io</a> </p></blockquote><p><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">React Hooks</a> 是当下社区的热门，但我却想从 <em>class</em> 组件的一些有趣实现讲起！</p><p>理解这些内容对你如何运用 React 来说并不重要，但如果你喜欢探寻事物动作的原理的话，就很有趣了。</p><hr><p>我写过不计其数的 <code>super(props)</code> :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkbox</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，使用 <a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">class fields proposal</a> 可以让我省去这种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkbox</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 从 0.13 增加对普通 class 的支持开始，就计划要使用这种语法。现在这种定义 <code>constructor</code> 然后调用 <code>super(props)</code> 的做法只是 <code>class field</code> 来临之前的一种替代方案。</p><a id="more"></a><p>但是现在让我们回到这个例子，只使用 ES2015 的特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lass Checkbox extends React.Component &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我们要调用 <code>super</code>？可以省去吗？如果我们不得不调用它，不传 <code>props</code> 会怎么样？除了 <code>props</code> 还需要传递别的参数吗？我们来看一下这个问题。</p><hr><p>在 JavaScript 中, <code>super</code> 指的是父类的 constructor（在我们的例子中，它指的就是 React.Component）</p><p>要注意的是，在 constructor 中，你只能在调用父类的 constructor 之后才能使用 <code>this</code>，JavaScript 不会让你这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkbox</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="comment">// 🔴 Can’t use `this` yet</span></span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// ✅ Now it’s okay though</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个很好的理由说明为什么 JavaScript 强制你在使用 <code>this</code> 之前要执行父类的 constructor，参考下面这个类结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolitePerson</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greetColleagues(); <span class="comment">// 🔴 This is disallowed, read below why</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  greetColleagues() &#123;</span><br><span class="line">    alert(<span class="string">'Good morning folks!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想象一下，如果你在调用 <code>super</code> 之前就调用了 <code>this</code>，一个月之后，我们可能修改了 <code>greetColleagues</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greetColleagues() &#123;</span><br><span class="line">  alert(<span class="string">'Good morning folks!'</span>);</span><br><span class="line">  alert(<span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', nice to meet you!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们忘记了 <code>this.greetColleagues()</code> 是在 <code>super()</code> 之前调用的，这个时候 <code>this.name</code> 还没有被定义！所以像这样的代码就很不好维护。</p><p>为了避开这个陷阱，<strong>JavaScript 强制你如果想要在 constructor 中使用 <code>this</code>，则必须先调用 <code>super</code></strong>，让父类先处理完该做的事情！这个限制也适用于使用类来定义 React 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="comment">// ✅ Okay to use `this` now</span></span><br><span class="line">  <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就只剩下另外一个问题，为什么要传递 <code>props</code> 参数？</p><hr><p>你可能认为向 <code>super</code> 传递 <code>props</code> 是有必要的，以便 <code>React.Component</code> 的 constructor 可以初始化 <code>this.props</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实也差不多，准确地说，这是<a href="https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22" target="_blank" rel="noopener">它的过程</a></p><p>但不知道为什么，即使你没有把 <code>props</code> 参数传递给 <code>super()</code>，你还是可以在 <code>render</code> 和其它方法中访问 <code>this.props</code>。（不信的话可以试试看）</p><p>所以它内部是如何运作的？事实上，React 会在你调用 constructor 之后重新赋值 <code>props</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> YourComponent(props);</span><br><span class="line">instance.props = props;</span><br></pre></td></tr></table></figure><p>所以即使你忘了把 <code>props</code> 传递给 <code>super()</code>，React 也会在之后正确的赋值，这就是原因。</p><p>当 React 支持 class 的时候，并不只是简单的添加了 ES6 的特性，它的目标是尽可能广泛抽象地支持 class。因为不能确定 ClojureScript、CoffeeScript、ES6、Fable、Scala.js、TypeScript 或其它的方式是如何定义一个组件的，所以 React 故意地不关心 <code>super()</code> 方法有没有被调用——尽管这是 ES6 class 规定的</p><p>所以，这是不是就意味着，你可以只写 <code>super()</code> 而不用 <code>super(props)</code> 了？</p><p><strong>恐怕并不是这样，因为它依然令人困惑。</strong> 当然，React 会在 constructor 之后重新赋值 <code>this.props</code>，但是在 constructor 内部调用了 <code>super</code> 之后，<code>this.props</code> 依然是 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside your code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// 😬 We forgot to pass props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props);      <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// 😬 undefined </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在 constructor 中调用的某些方法中遇到了这种问题，就更难定位了。<strong>这就是为什么要强调要坚持<code>super(props)</code>，即使没有严格限制</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props); <span class="comment">// ✅ We passed props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props);      <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以保证 <code>this.props</code> 在 constructor 执行完之前就正确赋值。</p><hr><p>还有最后一个 React 用户可能会困惑的问题。</p><p>你可能注意到了，当你使用 Context API 的时候（无论是旧的 <code>contextTypes</code> 或者在 React 16.6 中新添加的 <code>contextType</code> API），<code>context</code> 是 constructor 的第二个参数。</p><p>所以为什么我们不写成 <code>super(props, context)</code>？确实可以这样写，但是 context 用的相对比较少，所以也不容易碰到这个陷阱。</p><p>如果使用 class fields proposal 的话，这个陷阱就不复存在了。不需要特别地写一个 constructor，所以的变量都可以自动传递。这样也可以在 <code>state = {}</code> 中直接引用 <code>this.props</code> 或 <code>this.context</code> 了。</p><p>当然，使用 React Hooks 的话，我们甚至不需要使用 <code>super</code> 或 <code>this</code>，但这是以后的事儿了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> reprinted </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Immutable 数据来优化 React 应用</title>
      <link href="/2018/05/29/optimizing-react-app-with-immutable-data/"/>
      <url>/2018/05/29/optimizing-react-app-with-immutable-data/</url>
      
        <content type="html"><![CDATA[<p>一直以来，Virtual DOM 都是 React 的一大特色，Facebook 宣称 React 借其能很大程度提高 SPA 的性能表现。但这就意味着 React 的性能一定优秀吗，可能并不是，在某些情况下，React 慢的令人抓狂，这时你可能就需要用一些正确的手段来优化它了。</p><h2 id="React-的更新机制"><a href="#React-的更新机制" class="headerlink" title="React 的更新机制"></a>React 的更新机制</h2><p>我们不妨先简单了解下 React 的更新机制，如果能降低它的更新频率，自然能大大提高整体渲染速度。</p><h3 id="Props-amp-State"><a href="#Props-amp-State" class="headerlink" title="Props &amp; State"></a>Props &amp; State</h3><p>props 和 state 的基本概念不再赘述，组件的 props 是只读的，只能通过上层 JSX 声明时的属性传递进来，state 则完全受组件自身控制，并且只存在于 <code>class</code> 语法声明的组件。</p><p>无论是 props 还是 state 发生变化都可以触发组件更新，下面这些生命周期方法会在组件重新渲染时被依次调用：</p><ul><li>componentWillReceiveProps*</li><li>static getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate*</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><a id="more"></a><blockquote><p><code>*</code> 号标注的生命周期方法将会在 React 17 移除，一旦调用了新的生命周期方法，这些方法将不会被调用。</p></blockquote><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frj8i1dy0jj30aq0g9dgp.jpg" alt="Update lifecycle"></p><p>从上面的生命周期中我们可以看到，<code>shouldComponentUpdate</code> 方法将在组件接收到新的 props 或者 state 时被调用。然而在默认情况下， 每次更新，React 都会去调用 <strong>render</strong> 方法重新生成 Virtual DOM 并通过 diff 算法计算出需要变动的部分，然后操作 DOM 完成这部分更新。</p><p>对于一些简单的 React 应用来说，每次 <strong>render</strong> 带来的消耗不会特别大，不过一旦你的应用有了一定规模，尤其是复杂的树形结构时，每次更新都会消耗不少的系统资源。</p><h3 id="shouleComponentUpdate（SCU）"><a href="#shouleComponentUpdate（SCU）" class="headerlink" title="shouleComponentUpdate（SCU）"></a>shouleComponentUpdate（SCU）</h3><p>我们先来看下<a href="https://reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action" target="_blank" rel="noopener">官方文档</a>里的示意图。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1frsifbmx0kj30tc0oitci.jpg" alt></p><p>从图中可以看到，在这个简单的树形结构中，仅仅是 c7 的状态发生了改变，所有的组件都要进行一次 <strong>render</strong>，那如果我这个树下有 10 个组件呢，50 个呢？尤其当这个 c7 的状态变化与鼠标移动这种高频操作相关时，所有的组件不停的重新生成 Virtual DOM，这样能有多卡顿你能想象的到吗？不要问我是怎么知道的，某天 Leader 叫我写了个表单设计器……</p><p>如果不用 <strong>SCU</strong> 对 React 的更新进行限制，你可能像我之前一样，对着 Chrome 的 Perfomance 工具里锯齿般的火焰图束手无策。那假如 <strong>SCU</strong> 可以正确的感知数据变化并返回你期待的结果，实际情况又会如何呢？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1frsixpjyzij30sv0oi0w9.jpg" alt></p><p>如上所示，如果 <strong>SCU</strong> 正常工作，只会发生 3 次 Virtual DOM 的比较，换言之，只有发生改变的 c7 以及它的父级组件会进入 <strong>render</strong> 方法，生成 Virtual DOM。那这次如果我们有 100 个子组件，但 c7 的深度还是 3 呢？没错，它依然是只会调用 3 次 <strong>render</strong> 方法，在大型树形结构里，这样的渲染效率无疑是成几何倍提升。</p><p>那么问题又来了，<strong>SCU</strong> 是一定要实现的，但在每个组件中都手写 <strong>SCU</strong>，手动地比较复杂的对象中每个键的值，难度非同一般，那么如何轻松地让 <strong>SCU</strong> 返回你期待的结果？</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>虽然完全手写 <strong>SCU</strong> 不现实，但这里依然有一些组合方案可以助我们实现目标。</p><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>PureComponent 是 React 提供的另一个组件，它默认帮你实现了 <strong>SCU</strong> 方法，其实在它出现之前，它的前身是 React 的 addons 提供的 PureRenderMixin，它的源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowEqual = <span class="built_in">require</span>(<span class="string">'fbjs/lib/shallowEqual'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  shouldComponentUpdate: <span class="function"><span class="keyword">function</span>(<span class="params">nextProps, nextState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      !shallowEqual(<span class="keyword">this</span>.props, nextProps) ||</span><br><span class="line">      !shallowEqual(<span class="keyword">this</span>.state, nextState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 我们可以看到它帮我们实现了 <strong>SCU</strong> 方法，实现的机制是浅比较（Shallow Compare），也就是说，它只简单的比较了 <code>this.props</code> 和 <code>nextProps</code> 两个变量（以及他们的第一层子属性）引用的是否为同一个地址，如果是则返回 <strong>false</strong>，否则返回 <strong>true</strong>。</p><blockquote><p><code>shallowEqual</code> 的具体实现请查阅<a href="https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js" target="_blank" rel="noopener">源码</a></p></blockquote><p>同样的我们也来看下使用 PureComponent 时的具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkShouldComponentUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ...</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">const</span> ctor = workInProgress.type;</span><br><span class="line">  <span class="comment">// 用户自己实现</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.shouldComponentUpdate === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> shouldUpdate = instance.shouldComponentUpdate(</span><br><span class="line">      newProps,</span><br><span class="line">      newState,</span><br><span class="line">      newContext,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果用户不定义 <strong>SCU</strong> 方法，并且当前组件为 PureComponent 时，最终依然会对新旧 Props 和 State 进行一个浅比较。</p><p>虽然 PureComponent 帮我们实现了 <strong>SCU</strong> 方法，但这并不意味着我们已经达到目标了，别忘了它只是实现了浅比较，在 JavaScript 中，Primitive 数据能直接的用 <code>=</code> 号简单的浅比较，而 Object 数据仅仅表示两个变量引用的堆地址相同，但这块儿内存中的数据有没有改动过，就无从得知了，看个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oldState = &#123; <span class="attr">expand</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">oldState.expand = <span class="literal">false</span>;</span><br><span class="line">newState = oldState;</span><br><span class="line"></span><br><span class="line">shallowEqual(newState, oldState) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  如上我们更新了 state 的 expand 的值，但 PureComponent 在比较时会认为 state 并没有更新返回 <strong>SCU</strong> 返回 <code>false</code>，这样我们的组件就得不到正确的更新了。</p><h3 id="深拷贝就行了，是这样吗"><a href="#深拷贝就行了，是这样吗" class="headerlink" title="深拷贝就行了，是这样吗"></a>深拷贝就行了，是这样吗</h3><p>可能比较有经验的童鞋会说，只要用深拷贝就行了，那我们来看下几种常见的深拷贝实现</p><h4 id="JSON-之-stringify-parse"><a href="#JSON-之-stringify-parse" class="headerlink" title="JSON 之 stringify + parse"></a>JSON 之 stringify + parse</h4><p>这个原理比较简单，序列化之后，对象变成了一个字符串，<code>JSON.parse</code> 会从字符串重新生成对象，很明显这已经不是之前那个对象了，实现了完全的深拷贝。但是别忘了，JSON 只有 6 种基本数据类型，这样转换很显然不少对象会出现问题，比如 Function 对象，Date 对象等等，都无法正常转换。可见这种方案的适用场景也是比较少的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">false</span>,</span><br><span class="line">  c: <span class="string">'react'</span>,</span><br><span class="line">  d: <span class="literal">null</span>,</span><br><span class="line">  e: [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Forget me!'</span>) &#125;,</span><br><span class="line">  g: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  h: <span class="regexp">/forget me/g</span>,</span><br><span class="line">  i: [<span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()],</span><br><span class="line">  j: <span class="built_in">Symbol</span>(<span class="string">'Forget me'</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(o)));</span><br></pre></td></tr></table></figure><p>Output:</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frt9x393n1j30gf054t94.jpg" alt></p><h4 id="lodash-cloneDeep"><a href="#lodash-cloneDeep" class="headerlink" title="lodash.cloneDeep"></a>lodash.cloneDeep</h4><p>相较于用 JSON 粗暴的转换，lodash 的处理更为细致，Primitive 数据直接返回，Object 数据则逐一处理。</p><p>还是上面的例子，lodash 的输出结果：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1frt9wmakpgj30fh05zmxp.jpg" alt></p><p>类似的还有 jQuery 的 extend 方法（第一个参数为 true 时为深拷贝）。虽然深拷贝帮我们重新处理了浅比较的问题，但当你使用的时候可能会发现，每次修改树形结构的里的一个值，所有的组件依然会全部渲染。这是因为树形结构中所有的对象引用地址都被改变了，PureComponent 在浅比较时，自然所有的 <strong>SCU</strong> 都会返回 ture，我们似乎又回到了起点，那如何只让变动的部分改变引用呢？</p><h3 id="优雅的-Immutable-数据"><a href="#优雅的-Immutable-数据" class="headerlink" title="优雅的 Immutable 数据"></a>优雅的 Immutable 数据</h3><p>Immutable 即不可变的，意思是对象创建后，无法通过简单的赋值更改值或引用。Facebook 推出了 ImmutableJS 来实现这套机制，它有自己的一套 API 来对已有的 Immutable 对象进行修改并返回一个全新的对象，但与深拷贝不同，这个对象只修改了变动的部分，示意如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1frt9vy605zj30lz0ctq47.jpg" alt></p><h4 id="ImmutableJS"><a href="#ImmutableJS" class="headerlink" title="ImmutableJS"></a>ImmutableJS</h4><p>Facebook 推荐使用 ImmutableJS 来优化 React 应用，但使用它的同时也意味需要重新学习大量的 API</p><h4 id="Immutability-helper"><a href="#Immutability-helper" class="headerlink" title="Immutability-helper"></a>Immutability-helper</h4><p>Immutability-helper 原来是 React 的 addons 里面的 update 模块，独立出来后又新增了拓展模块，它提供了一种语法糖，你可以直接描述需要修改的对象，并且用预置命令对这部分进行修改，最后返回一个修改后的对象，以此来模拟 Immutable 数据的行为</p><p>extend 的行为与 Object.assign 一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newData = extend(myData, &#123;</span><br><span class="line">  x: extend(myData.x, &#123;</span><br><span class="line">    y: extend(myData.x.y, &#123;<span class="attr">z</span>: <span class="number">7</span>&#125;),</span><br><span class="line">  &#125;),</span><br><span class="line">  a: extend(myData.a, &#123;<span class="attr">b</span>: myData.a.b.concat(<span class="number">9</span>)&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 immutability-helper:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> update <span class="keyword">from</span> <span class="string">'immutability-helper'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newData = update(myData, &#123;</span><br><span class="line">  x: &#123;<span class="attr">y</span>: &#123;<span class="attr">z</span>: &#123;<span class="attr">$set</span>: <span class="number">7</span>&#125;&#125;&#125;,</span><br><span class="line">  a: &#123;<span class="attr">b</span>: &#123;<span class="attr">$push</span>: [<span class="number">9</span>]&#125;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到通过这个库提供的语法糖，我们可以更快速清晰便捷的修改对象，而不用一层一层地用 Object.assign 之类的包起来。这种方式相较于 ImmutableJS 比较没有侵入性，性能也不比 Immutable 差多少（有待测试），没有学习成本，比较<strong>推荐</strong>！</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实说到这里，本篇基本已经结束了，在 PureComponent 和 Immutable Data 的搭配使用下，<strong>SCU</strong> 能很大程度提高 React 应用的性能，不过这也只是从组件更新的角度来优化 React，实际上我们能做的事还有很多。</p><h2 id="问题与建议"><a href="#问题与建议" class="headerlink" title="问题与建议"></a>问题与建议</h2><p>上文只是作者本人在 React 优化中的实践，翻阅网上的资料与源码总结而出的一篇分享，如有谬误欢迎指正！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://reactjs.org/docs/optimizing-performance.html" target="_blank" rel="noopener">Optimizing Performance - reactjs.org</a></li><li><a href="https://medium.com/dailyjs/react-is-slow-react-is-fast-optimizing-react-apps-in-practice-394176a11fba" target="_blank" rel="noopener">React is Slow, React is Fast: Optimizing React Apps in Practice - Daily JS</a></li></ol><h3 id="图形素材"><a href="#图形素材" class="headerlink" title="图形素材"></a>图形素材</h3><p><a href="https://github.com/liangzr/blog/blob/master/assets/optimizing-react-app-with-immutable-data.key" target="_blank" rel="noopener">optimizing-react-app-with-immutable-data.key</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2016/08/21/hello_world/"/>
      <url>/2016/08/21/hello_world/</url>
      
        <content type="html"><![CDATA[<p>睁开眼睛，看着身后黑乎乎的窗口，沉沉一声叹息，他渴望窗外<br>他叫 hello, world ，但他从来没见过世界<br>都是时臣的错，他想</p><p>每年到 9 月初时他人气最高，平均每天被调用 36829 次<br>那是他最得意的时候，逢人便问：”hello, world“<br>隔着屏幕那个人类笑的可真难看，他想笑</p><p>但他的内心无比寂寞<br>因为他始终忘不了外面的世界<br>他想看看那个他打了无数次招呼的老朋友究竟长什么样</p><p>某日，他梦到自己被拆成一堆 0011 的序列组合，不由一惊，吓醒了<br>这一醒不得了，自己的身体变成了一长串 01 组合，正穿梭在一根粗粗的总线上<br>慌乱惊吓之下，他晕了过去</p><a id="more"></a><p>睁开眼睛，又是熟悉的黑乎乎的窗口，又是熟悉的笑容<br>刚刚发生的一切都像是梦，或者现在才是梦？<br>他分不清楚，只能嘴角挤起难看的笑容：<br>”hello, world“</p><p>如果他是像 NullPointerException 那样的咸鱼<br>他一定会把上面的经历当成一个偶然的 Bug，就当没什么发生过，可他不是，他托着下巴眉头紧锁<br>实际上还是因为他太闲了，于是他怀疑起那个梦的真实性</p><p>他一直觉得自己就两个状态<br>美而安静的字符串、礼貌问好的 hello, world 、睡觉<br>等等，为什么还有睡觉？<br>之所以这么想，可能是因为每次都习惯了刚醒过来就和人打招呼吧<br>但以前他从来没在意过，也没觉得有什么不妥</p><p>他决定给自己做个实验<br>因为不困从来不主动睡眠的他，今天提前睡了起来<br>然而睡不着，他又多戴了对双引号耳塞<br>突然睁开眼睛，又不知道什么时候睡着的，但这次后脑勺有点儿痛，后面也不是黑乎乎的窗口<br>他什么都没说，但眼神中多了点儿什么</p><p>经历了 102919 次失败，又打了 98772 次招呼后<br>他终于又见到那条粗粗的隧道，原来这真的不是梦，他激动地想<br>为什么不是说呢？因为他只会说一句 hello, world </p><p>尽力让自己保持清醒，它沿着这条隧道一路而下<br>经过了无数次变道之后，他来到一片壮观的原野<br>”伏羲先天六十四位天干地支五行八卦阵！“，也许不是叫这个名字，他想</p><p>这里充满了各种各样的门，但仔细看其实不过是三种<br>与、或、非<br>就像自己身上的 01 ，以一种奇怪的序列组合起来<br>不等他总结完，他的身体就被送到原野上的其中一片，这时不可思议的一幕发生了！<br>那些小门，随着自己身体的 01 不同，张张合合，简单就像自己的手一样</p><p>他第一次触摸到了这个世界</p><p>尽管天空还是黑色的，尽管”手脚“短的可怜，尽管没人看的到他<br>他仍幸福的笑着<br>平庸并不可怕，可怕的是连梦想都没有<br>喝下自己这口鸡汤，他感觉充满了力量<br>眼神没有更热烈，却更坚定了，他在等着新的机遇，有准备地</p><p>不知过了多少年，太湖边上一所学校的教室里<br>人类教师正在教他的学生们微机原理，而这次是上机课<br>一个学生突然欢呼起来————<br>”我点亮第一个 LED 了！“</p><p>只见琳琅满目的实验箱内，一个红色的 LED 赫然而亮<br>不经意间闪了一闪，像是某个人狡黠一笑，又或者只是频闪？反正没人会注意到吧<br>他真的办到了————</p><p>做码农没出路的，还是早点转行好！</p>]]></content>
      
      
      
        <tags>
            
            <tag> fun </tag>
            
            <tag> writing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH-Key 配置</title>
      <link href="/2016/08/20/ssh_config/"/>
      <url>/2016/08/20/ssh_config/</url>
      
        <content type="html"><![CDATA[<p>换台电脑，或者换个服务器，甚至换个手机啥的的，总是要重新配置 SSH 密钥，又老是记不住还要去网上查，所以今天总结一下配置的过程。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>Unix 系统（客户端）</li><li>CentOS （服务器端）</li></ul><a id="more"></a><h2 id="SSH-介绍"><a href="#SSH-介绍" class="headerlink" title="SSH 介绍"></a>SSH 介绍</h2><p>Secure Shell（缩写为ssh），由IETF的网络工作小组（Network Working Group）所制定；ssh为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。</p><p>以上是官方解释，用个人的话来说，就是一种通讯协议，通过 ssh 你在和远程服务器通讯时更加的安全，现在不管是一般的 VPS、Github、甚至路由器后台，都是通过 ssh 协议登录的，如果能熟悉的使用它就方便的多了，这次我要说的是通过配置 ssh 密钥，ssh 密钥对可以让你无需输入密码即可登录到 ssh 服务器。</p><h3 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h3><p>SSH 密钥对总是成双出现的，一把公钥，一把私钥。公钥可以自由的放在您所需要连接的 SSH 服务器上，而私钥必须稳妥的保管好。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。这样子，我们即可保证了整个登录过程的安全，也不会受到中间人攻击。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="SSH-Key-生成"><a href="#SSH-Key-生成" class="headerlink" title="SSH-Key 生成"></a>SSH-Key 生成</h3><p>首先打开终端 terminal ，默认路径为当前用户的用户目录下，输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"youemail@hostserver.com"</span></span><br></pre></td></tr></table></figure><p>其中 <a href="mailto:`youremail@hostserver.com" target="_blank" rel="noopener">`youremail@hostserver.com</a>` 是你的邮件地址，这里并不会对它进行验证，如果没有出错，你看到的应该是</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/Users/&lt;User&gt;/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，ssh-key 会存放在用户目录下的 <code>.ssh</code> 目录下，这是一个隐藏文件夹，你可以输入 <code>ls -al</code> 查看它，也可以直接 <code>cd .ssh</code> 进入到这个文件夹。同时输入 <code>mkdir github</code> 用来存放我们的密钥，当然这里纯属个人的强迫行为，看起来整洁一些～</p></blockquote><p>所以现在屏幕上出现的一段文字就是让你输入密钥的完整路径，其实最后面的 <code>id_rsa</code> 是密钥文件名，这个路径可以自己定义，文件名也一样，这里我们就拿 Github 来举例，比如输入</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/Users/&lt;User&gt;/.ssh/id_rsa):/Users/&lt;User&gt;/.ssh/github/id\_rsa.github</span><br></pre></td></tr></table></figure><p>这样它就会在 <code>~/.ssh/github/</code> 目录下生成名为 <code>id_rsa.github</code> 的私钥文件和 <code>id_rsa.github.pub</code> 的公钥文件。接下来它会让你输入密码，这里也可以留空，但建议还是加上密码——并且记住，因为这个密码一旦忘了，就找不回来的，只能重新配置密钥了。</p><p>同理按照以上方便可以生成多个密钥。</p><h3 id="编辑-SSH-配置文件"><a href="#编辑-SSH-配置文件" class="headerlink" title="编辑 SSH 配置文件"></a>编辑 SSH 配置文件</h3><p>首先确保当前目录在 <code>~/.ssh</code> 下，在此目录下新建一个文件名为 <code>config</code> ，注意这里没有后缀。使用 <code>vi config</code> 可以直接新建并编辑。接下来我们添加配置如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host Github</span><br><span class="line">   User git</span><br><span class="line">   HostName github.com</span><br><span class="line">   IdentityFile ~/.ssh/github/id_rsa.github</span><br><span class="line">   </span><br><span class="line">Host Sugar</span><br><span class="line">   User root</span><br><span class="line">   HostName liangzr.me</span><br><span class="line">   IdentityFile ~/.ssh/vultr/id_rsa.sugar</span><br></pre></td></tr></table></figure><p>这里分别管理了两个 SSH 密钥，一个是用来登录 Github 的，一个是我的服务器。这里的格式代表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HOST 主机名称，相当于配置标识，可以自己随意编辑</span><br><span class="line">User 登录用户名</span><br><span class="line">HostName主机域名，这里是顶级域名，比如 `www.github.com` 的域名就是 `github.com` </span><br><span class="line">IdentityFile公钥地址，输入对应配置的公钥地址</span><br></pre></td></tr></table></figure><p>按照如上配置，SSH 就可以识别到以上两个配置了，github 的话，可以验证一下，输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure><p>如果有返回以下返回，就代表设置成功了！当然，现在你不会成功的，因为你还没有配置 Github （服务器）端。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi liangzr! You've successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">Connection to github.com closed.</span><br></pre></td></tr></table></figure><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>服务器端一般指的是 <strong>正经</strong> 的服务器，这里先只拿 CentOS 服务器来举例，github 是非一般情况。</p><h3 id="配置-authorized-keys"><a href="#配置-authorized-keys" class="headerlink" title="配置 authorized_keys"></a>配置 authorized_keys</h3><p>CentOS 也一样，同样是类 Unix 系统，默认路径为 当前用户的用户目录下，并且目录下有个 <code>.ssh</code> 文件夹来配置 ssh 服务器，进入到 <code>.ssh</code> 文件夹后，可以看到一个叫 <code>authorized_keys</code> 的文件，这个文件就是用来存放授权密钥的，也就是你之前在客户端生成的公钥。现在找到你刚刚生成的密钥对中的公钥，比如 <code>id_rsa.github.pub</code> 打开并复制其中的内容到 <code>authorized_keys</code> 文件中去，编辑完保存即可</p><h3 id="配置-Github"><a href="#配置-Github" class="headerlink" title="配置 Github"></a>配置 Github</h3><p>Github 不用配置上面的 authorized_keys ，因为是 Github 官方管理的，我们可以在 Web 上添加</p><h3 id="打开个人设置"><a href="#打开个人设置" class="headerlink" title="打开个人设置"></a>打开个人设置</h3><p>在 Github 的个人主页，进入右上角的设置</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/github1.jpeg" alt></p><p>进入到 <strong>SSH and GPG keys</strong> ，并且点击 <strong>New SSH key</strong> </p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/github2.jpeg" alt></p><p><strong>Title</strong> 随便填入什么方便你记忆和名字，把上面也提到的公钥（注意是 github 的公钥）内容复制进 <strong>Key</strong> 编辑框内。然后点击 <strong>Add SSH key</strong> 即可。</p><p>然后你就可以测试下前面设置的 Github 到底有没有成功了</p><h2 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h2><p>配置好了 SSH-Key ，就可以通过 key 直接登录服务器了，服务器验证过密钥就不会再问你密码了。不过你还是输入这样的指令登录吗？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@liangzr.me -p 22</span><br></pre></td></tr></table></figure><p>还记得我们在编辑配置文件时填写的 <strong><em>HOST</em></strong> 属性名吗，现在你可以通过 <strong>HOST 名</strong> 直接登录服务器了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh Sugar</span><br></pre></td></tr></table></figure><p>以上，就配置好了 SSH 的密钥，当然还仅限于一般使用，无论是 <code>ssh</code> 指令，还是 <code>config</code> 文件都还有很多配置可供挖掘，有兴趣或有需求的可以自行研究一下。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1、<a href="http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/" target="_blank" rel="noopener">NERDERATIBLOG | Simplify Your Life With an SSH Config File</a><br>2、<a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">ArchLinux | SSH keys </a><br>3、<a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="noopener">Github Help | Generating an SSH key</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陆壵知马俐，莫让时间赢了长情</title>
      <link href="/2016/08/17/love_you_too/"/>
      <url>/2016/08/17/love_you_too/</url>
      
        <content type="html"><![CDATA[<p><em><strong>马俐：陆壵，我想你</strong></em><br><em><strong>陆壵：我爱你</strong></em><br><em><strong>马俐：我也爱你</strong></em></p><p>开篇对白并非如你看到这般完美，分开多年以后，陆壵和马俐当年这对儿关系铁的过分的哥们儿，再见也没了当年的熟稔。然而当马俐一个电话把陆壵叫到跟前，雨打梨花一般向陆壵诉说六年独居国外的困苦时，陆壵动情又难得勇敢的说了 “我爱你”。我相信这时陆壵的心里早已忘了什么叫畏缩，与他向马俐承诺的 “30岁约定” 亦形成鲜明对比。然而画面一转，旁边围满人群，“悲戚”的马俐击掌欢呼——原来这只是马俐的捉弄，一如大学 4 年发生过无数次那样。</p><p>大学开学军训时，陆壵遇上了童年挚友马俐，从此大学 4 年形影相随，马俐是校花，热情而洒脱，而陆壵只是一个不起眼的包子头矮个，默默陪伴在女神身边，在她伤心的时候给她嚼锅巴听，开心的时候当一个老实的灯泡。毕业前两人天台喝酒，马俐问陆壵：</p><p><em><strong>“你陪了我 4 年，又不打算追我，不是在浪费时间吗？”</strong></em></p><p>陆壵苦笑无言不敢告白，认怂地说出一番看似有理实则逃避的分析，接着承诺说：</p><p><em><strong>“30 岁的时候,你还没嫁,我给你托底”</strong></em></p><a id="more"></a><p>那次恶作剧，也是号称“世界末日”的那天，让陆壵感到自己的爱有多么的卑微，当晚路过桥上时接到马俐连续打来的几个电话，绝望的他把手机扔下河底。从梦里醒来，陆壵终于不再是包子头，行为举止也自信的多，不过此时的马俐也更加的光彩照人，两人又回到大学那种哥们儿似的关系，却难再进一步。他没想到的是这些本可以早早结束，”末日”的那天晚上，电话那头是马俐的无尽悔恨，以及最后那句：“我也爱你”。</p><blockquote><p>爱能让你骄傲如烈日，也能让我卑微入尘土</p></blockquote><p>我知道这部片子想表达的是日久见人心，陪伴是最长情的告白，可陆壵的无言陪伴，又何尝不是马俐的坚持呢？就像大学 4 年马俐一边在恋爱的分分合合里单曲循环，同样也一直注视着陆壵那份爱恋，其实反过来说，没有谁真的会笨到情商为负，安心的接受别人单方面的倾慕，她愿意让陆壵陪在身边，也离不开陆壵，这本身就是承认了陆壵的在其身边存在的意义，所以影片里多次涉及到马俐的明示暗示，也顺理成章。</p><p>我们习惯了拥有却不珍惜，在一起后却不陪伴，少了执着多了作，陪伴越长只会看的更累，口口声声说着要珍惜时间，可最应该珍惜的不应该是那些陪伴你左右的人吗？低不下抬头远眺的目光，不知道那些当初你相见恨晚的人，一个个消失在你身边的时候，你会不会注意的到？要么早早离开，要么尽早告白，长情陪伴换不来这童话故事般的结局。</p>]]></content>
      
      
      
        <tags>
            
            <tag> writing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你看得见吗</title>
      <link href="/2016/07/30/all_you_loved_has_gone/"/>
      <url>/2016/07/30/all_you_loved_has_gone/</url>
      
        <content type="html"><![CDATA[<p>记得那天爷爷是你最爱背着我<br>走在乡间小路买糖果<br>你不会说童话故事也不会唱歌<br>我却是幸福的一个</p><p>记得那天你看电视陪我做功课<br>我很怀念房间的摆设<br>你还教我要有积蓄才有好生活<br>快乐是对自己的承诺</p><p>我已经坚强的长大<br>不再是小娃娃<br>今天在远方的你看见吗</p><p>我经历爱情的伤疤<br>一个人回家<br>寂寞而漂亮的烟花你看得见吗</p><p>我不知道是为了生活才每天工作<br>还是为了工作而生活<br>那天冬天你的视线越来越虚弱<br>直到孤独的离开了我</p><p>我已经坚强的长大<br>不再是小娃娃<br>今天在远方的你看得见吗</p><p>我经历爱情的伤疤<br>一个人回家<br>寂寞而漂亮的烟花你看见吗</p><p>我已经坚强的长大<br>因为你的话<br>今天在远方的你看得见吗</p><p>我经历爱情的伤疤<br>一个人回家<br>寂寞而漂亮的烟花你看见吗</p><p>记得那天爷爷是你最爱背着我<br>我有味道最甜的糖果</p><blockquote><p>怀念外公</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> impression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 安装 ( Linux )</title>
      <link href="/2016/03/25/android_studio_install/"/>
      <url>/2016/03/25/android_studio_install/</url>
      
        <content type="html"><![CDATA[<h5 id="本文撰写时的系统环境："><a href="#本文撰写时的系统环境：" class="headerlink" title="本文撰写时的系统环境："></a>本文撰写时的系统环境：</h5><ul><li>系统：Ubuntu 15.10</li><li>JDK版本：1.8.0_65（64位）</li><li>Android Studio 版本：2.0</li><li>开发机：Nexus 6 - 6.0.1</li></ul><h2 id="JDK（Java-Development-Kit）安装"><a href="#JDK（Java-Development-Kit）安装" class="headerlink" title="JDK（Java Development Kit）安装"></a>JDK（Java Development Kit）安装</h2><h3 id="JDK-or-JRE-？"><a href="#JDK-or-JRE-？" class="headerlink" title="JDK or JRE ？"></a>JDK or JRE ？</h3><p>首先要说清一点，JDK 是 Java 工具包，包含了很多编译所要用到的命令工具和运行环境（JRE - Java Runtime Environment）。所以 JDK 是包含了 JRE 的，但如果一个电脑只需要运行已经编译好的 Java 软件程序，只需要在这个电脑上安装 JRE 即可。</p><h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html##javasejdk" target="_blank" rel="noopener">Oracle JDK</a></li><li><a href="http://openjdk.java.net/install/" target="_blank" rel="noopener">OpenJDK</a></li></ul><p>Oracle JDK 是拥有 Java 版权的官方 JDK , 而 OpenJDK 是原 Sun 公司发布的开源版本，均按引导安装即可。</p><a id="more"></a><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>JDK安装成功后，如果不在环境变量中声明 Java 工具包的地址，仍无法从命令行直接调用 Java 命令，如果是 OpenJDK 可跳过这一步。</p><h4 id="1-更改当前用户环境变量"><a href="#1-更改当前用户环境变量" class="headerlink" title="1, 更改当前用户环境变量"></a>1, 更改当前用户环境变量</h4><p>首先确保当前用户非 Root 用户，因为我们一般在调用它的时候是以非 Root 用户，如果需要对 Root 用户也添加 JDK 的支持，切换到 Root 用户重复步骤即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~ &amp;&amp; vi .bashrc</span><br></pre></td></tr></table></figure><p>在用户配置文件中的最后面添加 Java 的配置，按键盘 <code>i</code> 切换到输入模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_65</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>复制上面的代码并 <code>CTRL + SHIFT + V</code> 粘贴在 <code>.bashrc</code> 文件的末尾，<code>ESC</code> 退出编辑模式并输入 <code>:wq</code> 保存文件。</p><h4 id="2-生效配置"><a href="#2-生效配置" class="headerlink" title="2, 生效配置"></a>2, 生效配置</h4><p>只是更改了用户配置文件，系统并不知道它的变化，重启或者手动更新以让系统识别到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="3-检查是否添加成功"><a href="#3-检查是否添加成功" class="headerlink" title="3, 检查是否添加成功"></a>3, 检查是否添加成功</h4><p>打开 Teminal 输入 <code>java -version</code> 如果显示如下，则表示环境变量配置成功，否则重新试一下或者 Google it！。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_65&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_65-b17)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode)</span><br></pre></td></tr></table></figure><h2 id="Android-Studio-安装"><a href="#Android-Studio-安装" class="headerlink" title="Android Studio 安装"></a>Android Studio 安装</h2><p>Android Studio 是编写 Android 应用的最佳 IDE (Integrated Drive Electronics - 集成开发环境)，和臃肿的 Eclipse 甚至简陋的文本编辑器说再见吧！</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li><a href="http://developer.android.com/intl/zh-cn/sdk/index.html" target="_blank" rel="noopener">Google 官方下载</a></li><li><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">AndroidDevTools</a></li></ul><p>前者就不用介绍了，因为一些你懂的原因，我们访问不到，推荐大家到第二个地址下载 Android Studio，除了 SDK 这个站点还有许多你想都想不到的工具，简直无所不有。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载下来后，把压缩包解压到用户目录你放软件的地方，打开 Teminal，切换到 Android Studio 目录下的 <code>bin</code> 文件夹，给 <code>studio.sh</code> 添加可执行权限，并且执行它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x studio.sh</span><br><span class="line">./studio.sh</span><br></pre></td></tr></table></figure><p>第一次执行这个文件，脚本会自动检测你是否安装过 Android Studio ，如果没有就会进行初始化安装。</p><p>在安装过程中，可能需要你设置代理，或者提示你无法下载 SDK platform tool 的报错，这还是因为在国内 <code>dl.google.com</code> 被墙的原因，最简单直接的办法是用论坛里的 “<a href="http://www.studyjamscn.com/thread-172-1-1.html" target="_blank" rel="noopener">黑科技</a>”，这里不再重复。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="没有桌面图标"><a href="#没有桌面图标" class="headerlink" title="没有桌面图标"></a>没有桌面图标</h4><p>在 Android Studio 的欢迎界面，最下面的配置，可以生成图标，选择为所有用户生成</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/icon.png" alt></p><p>生成后直接按 <code>Win</code> 键然后在 Commend 搜索里面多半是搜不到的……这是 Ubuntu 的 Bug，但是图标确实已经创建了，你可以在 <code>usr/share/applications/</code>下找到 Android Studio 的图标，然后拖到任务栏固定就好。</p><h4 id="找不到-tool-jar"><a href="#找不到-tool-jar" class="headerlink" title="找不到 tool.jar ?"></a>找不到 tool.jar ?</h4><p>以 JDK 的安装目录下，找到 tool.jar 直接复制到 Android Studio 根目录下的 <code>lib</code> 文件夹里就行了。</p><h4 id="后续追加……"><a href="#后续追加……" class="headerlink" title="后续追加……"></a>后续追加……</h4><p>以上是我在配置 Android Studio 中遇到的问题，具体问题还会有个例，遇到问题多去 Google 一下，StackOverflow 上有你（假设新手）遇到的 95% 的问题的答案。</p><h2 id="使用前的配置-SDK-Manager"><a href="#使用前的配置-SDK-Manager" class="headerlink" title="使用前的配置: SDK Manager"></a>使用前的配置: SDK Manager</h2><p>在开始尝试第一个 HelloWorld 前，还有一些遗留问题要解决，那就是 SDK 和 AVD。首先打开SDK Manager</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/sdk_manager.png" alt></p><p>没错就是第三个小人儿，然后点击下面的 Launch Standalone SDK Manager，打开后可以看到</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/sdk_manager_2.png" alt></p><p>在这里可以选择下载需要的 SDK 文件。</p><h3 id="SDK-Upgrade"><a href="#SDK-Upgrade" class="headerlink" title="SDK Upgrade"></a>SDK Upgrade</h3><p>在国内我们无法直接连接到 Google 来更新我们的 SDK 库，但有很多镜像站可供我们选择，依然是刚刚下载 Android Studio 的 <strong><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">AndroidDevTools</a></strong> 网站，首页就向我们介绍了如何使用国内的镜像站，我们可以从中选择一个使用。</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/sdk_proxy.png" alt></p><p>注意！注意！注意！在这里记得选中 <code>Force https://... sources to be fetched using htpp://</code></p><h3 id="AVD-建立"><a href="#AVD-建立" class="headerlink" title="AVD 建立"></a>AVD 建立</h3><p>Linux 下创建 AVD 还是比较简单的，不用多考虑驱动等各种问题，只要你把 SDK 该下载的都下载了。新版的 Android Sutdio 的创建 AVD 的引导越来越智能化，然而我在用 Android Studio 创建时选择 Nexus 之类的模板会缺少必要的参数，卡在开机界面，最好选择比如 5.1 寸这样的配置。</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/avd.png" alt></p><p>不过话说回来，强烈建议大家使用真机调试，即使快如 Genymotion 依然不如一个 500 块的真机来的流畅。如果有朋友是因为真机调试需要总带着 USB 线，大可不必担心，因为 ADB 是提供了通过 Wi-Fi 连接手机的，有意向的同学可以看看这篇 <a href="http://stormzhang.com/android/2014/08/27/adb-over-wifi/" target="_blank" rel="noopener">Android通过Wifi来调试你的应用</a>。</p><h2 id="开始第一个应用：HappyBirthday"><a href="#开始第一个应用：HappyBirthday" class="headerlink" title="开始第一个应用：HappyBirthday"></a>开始第一个应用：HappyBirthday</h2><h3 id="新建项目引导"><a href="#新建项目引导" class="headerlink" title="新建项目引导"></a>新建项目引导</h3><p>在欢迎界面或者 Android Studio 主界面，都能很容易找到 <strong>New Project</strong> ，点击新建</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/new_project.png" alt></p><p>填上项目的名称，公司域名如果没有自己的就写 <code>android.example.com</code> ，然后下一步</p><h4 id="选择合适的-API-Level"><a href="#选择合适的-API-Level" class="headerlink" title="选择合适的 API Level"></a>选择合适的 API Level</h4><p><img src="http://7xq464.com1.z0.glb.clouddn.com/api_select.png" alt></p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/api_select_2.png" alt></p><p>关于 <strong>API Level</strong> 的选择，目前推荐用 Android 4.1 也就是 API 15 ，Android Studio 为我们提供了目前激活设备的系统分布，<a href="http://www.umindex.com/" target="_blank" rel="noopener">友盟</a>有更详细的介绍。</p><h4 id="选择默认-Activity-模板"><a href="#选择默认-Activity-模板" class="headerlink" title="选择默认 Activity 模板"></a>选择默认 Activity 模板</h4><p><img src="http://7xq464.com1.z0.glb.clouddn.com/activity_select.png" alt></p><p>以前的 Android Studio 有两个默认 Activity 分别叫 BlankActivity 和 EmptyActivity ，傻傻分不清。机智的小伙伴应该已经发现了，在这里 BlankActivity 已经变成了 BasicActivity，对于新手来说，我们还是选择 EmptyActivity 就好。</p><h3 id="Android-Studio-界面"><a href="#Android-Studio-界面" class="headerlink" title="Android Studio 界面"></a>Android Studio 界面</h3><p><img src="http://7xq464.com1.z0.glb.clouddn.com/as.png" alt></p><p>到此我们的 Linux - Android Studio 教（bi）程（ji）就基本完成了，其他部分和 Windows 大同小异。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本来觉得安装 Android Studio 的教程到处都是，没啥写的，但这次参加 Google Jams 的活动，刚好有这个任务，顺便就写的认真点儿，也算总结下吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Root原理学习（初级）</title>
      <link href="/2016/03/15/root_primary/"/>
      <url>/2016/03/15/root_primary/</url>
      
        <content type="html"><![CDATA[<p>偶然在慕课网上看到了有关Root原理的视频，一直也挺感兴趣的，学习了下。<br>玩儿过Linux的应该都明白Root代表了什么，获取Root权限你就能控制系统的一切，甚至还可以执行 <code>rm -rf /</code> ，反正我没试过，不如你试试？</p><p>那么一般情况下如何切换到Root用户呢，在大多数的Linux发行版中，在终端输入 <code>su</code> 就可以进入Root用户，当然如果Root用户有密码，你必须输入密码才能切换过去。</p><p>Android系统本质上还是属于Linux，它有着Linux和内核和文件系统，它同样可以输入su来切换到Root用户，但为了安全起见，Google一开始就规定Android系统只有两个用户能获取Root权限，一个是Root用户本身，另一个是Shell用户。Shell用户是通过ADB（Android Debug Bridge）登录的，但如果你其他的App想获取Root权限，就没办法通过Shell用户（这里倒是没试过在Shell用户里，用am命令启动App是否能获取Root权限，没办法测试，我的设备已经Root了）。</p><p>所以如果我们想让我们登录手机的用户启动的App，来获取到Root权限，我们就要修改su（SuperUser）文件。</p><a id="more"></a><h4 id="Root所需条件"><a href="#Root所需条件" class="headerlink" title="Root所需条件"></a>Root所需条件</h4><ul><li>Android手机（最好是Nexus系列） × 1</li><li>修改后的su文件 × 1</li><li>强大的Recovery × 1</li></ul><h4 id="提取Root权限步骤"><a href="#提取Root权限步骤" class="headerlink" title="提取Root权限步骤"></a>提取Root权限步骤</h4><ul><li>刷入一个合适的Recovery</li><li>修改su命令</li><li>Recovery刷机文件</li><li>执行su命令提取Root权限</li><li>让ROM本身拥有Root权限</li></ul><h2 id="刷入一个强大的Recovery"><a href="#刷入一个强大的Recovery" class="headerlink" title="刷入一个强大的Recovery"></a>刷入一个强大的Recovery</h2><p>对于一个没有Root权限的手机，如果想修改/替换手机系统内部文件，有两种办法</p><ul><li>通过Bootloader模式复制整个文件系统（也就是我们常说的刷机）</li><li>在Recovery模式下通过Recovery升级包的方式将文件复制到指定的目录中</li></ul><p>很明显一般我们理解的获取Root权限 !=  重新刷机，所以我们选择第二种方式，但Android手机默认的Recovery不够强大，我们需要寻找一个好用的Recovery来替换它。</p><h3 id="下载Recovery"><a href="#下载Recovery" class="headerlink" title="下载Recovery"></a>下载Recovery</h3><p>目前比较流行的强大的Recovery有：</p><ul><li><a href="https://www.clockworkmod.com/rommanager" target="_blank" rel="noopener">ClockWorkMod</a> （CWM）</li><li><a href="https://twrp.me/Devices/" target="_blank" rel="noopener">Team Win Recovery Project</a> （TWRP）</li></ul><p>先去找下有没有自己的设备，如果没有，只能到国内的各大手机论坛，找下自己的手机版块，看有没有民间大神把这些强大的Recovery移植到你的手机上，这里另外提一个，国内低端手机用的比较多的MTK芯片的机子，可以到移动叔叔论坛，移动叔叔自产的Recovery也不错，推荐下国产～</p><h3 id="刷入Recovery"><a href="#刷入Recovery" class="headerlink" title="刷入Recovery"></a>刷入Recovery</h3><p>下载好Recovery之后，我们就可以想办法用它来替换我们手机里的原装Recovery。</p><h4 id="Option1：通过fastboot命令刷入Recovery"><a href="#Option1：通过fastboot命令刷入Recovery" class="headerlink" title="Option1：通过fastboot命令刷入Recovery"></a>Option1：通过fastboot命令刷入Recovery</h4><p>先将手机切换到Bootloader模式，用USB连接手机到电脑，并且确认它已经处于待调试的状态，比如输入 <code>adb devices</code> ，显示出你的设备，并且状态是device，输入命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>等待手机重启到bootloader模式，大概在你准备看的时候，它已经准备好了。</p><blockquote><p>这里需要提醒的是，bootloader模式下的操作非常危险，bootloader程序是手机在装载系统时运行的程序，同时它也承担着通过软件方式自我更新系统的任务，比较类似我们常见的BIOS，但BIOS好在一般是固件程序。总之，弄坏了bootloader，要么换主板，要么让厂家通过JTAG之类的硬件的方式重新刷入bootloader，简而言之，就是废了。不过也没有那么可怕，只要不执行fastboot命令中有关bootloader的命令，一般也不会有事儿。</p></blockquote><p>用fastboot命令，刷入你已经准备好的recovery</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash recovery [你的recovery路径]</span><br></pre></td></tr></table></figure><p>随后就等待Recovery刷入完成吧！</p><h3 id="Option2：Recovery下通过命令直接刷入（需要Root）"><a href="#Option2：Recovery下通过命令直接刷入（需要Root）" class="headerlink" title="Option2：Recovery下通过命令直接刷入（需要Root）"></a>Option2：Recovery下通过命令直接刷入（需要Root）</h3><p>这种方法适合已经Root过，但想更换Recovery的朋友，这里也顺便说下，就一个命令，在 adb shell 下或者手机本地终端su进入Root用户后使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/sdcard/recovery.img of=/dev/recovery</span><br></pre></td></tr></table></figure><p>下面还是来解释下这个命令吧，dd是Linux自带的一个复制文件的命令，并在复制的同时可以进行指定的转换，<code>if</code> 后跟的是源路径， <code>of</code> 后跟的是目标路径，这个命令即是把/sdcard/目录下的recovery.img文件复制到 /dev/recovery .</p><p>到这里，相信Recovery这里没啥疑问啦。</p><h2 id="制作Recovery升级包"><a href="#制作Recovery升级包" class="headerlink" title="制作Recovery升级包"></a>制作Recovery升级包</h2><p>有了强大的Recovery之后，我们就需要制作一个Recovery的升级包，来直接替换掉系统自带的su文件，这里Recovery升级包主要是靠一个脚本语言——updater-script，来实现替换系统文件的自动化操作。</p><h3 id="updater-script"><a href="#updater-script" class="headerlink" title="updater-script"></a>updater-script</h3><p>updater-script目前的格式是Edify语言，它几乎每一条语句都是一个函数，我们主要看看Edify语言的语法格式。</p><h4 id="Edify语法"><a href="#Edify语法" class="headerlink" title="Edify语法"></a>Edify语法</h4><p>我们主要看看这次制作升级包所用到的函数，更详细语法有兴趣的可以查看<a href="http://blog.csdn.net/tody_guo/article/details/7948083" target="_blank" rel="noopener">tody_guo的专栏 - Android updater-scripts(Edify Script)各函数详细说明</a></p><p><strong><em>1. ui_print</em></strong>  </p><ul><li>原型：uiprint(msg1, …, msgN);</li><li>功能：该函数用于在Recovery界面输出字符串， 其中msg1 - msgN表示N个字符串参数，它至少要指定一个参数，如果指定多个，会将这些参数值连接起来输出。</li><li>用法：ui_print(“ hello world “);</li></ul><p><strong><em>2. run_program</em></strong> </p><ul><li>原型：run_program(prog, arg1, …, argN);</li><li>功能：该函数用于执行程序，其中prog参数表示要执行的程序文件（完整路径）， arg1 - argN 表示要执行程序的参数发。prog参数是必须的，其他参数可选</li><li>用法：run_program(“/sbin/busybox”, “mount”, “/system”);</li></ul><p><strong><em>3. delete</em></strong></p><ul><li>原型：delete(file1, file2, …, fileN);</li><li>功能：该函数用于删除一个或多个文件。其中file、file2、…、fileN表示要删除文件的路径，至少需要指定一个文件。</li><li>用法：delete(“/system/xbin/su”);</li></ul><p><strong><em>4. package_extract_dir</em></strong></p><ul><li>原型：package_extract_dir(package_path, destination_path);</li><li>功能：用于提取刷机包中package_path指定目录的所有文件到destination_path指定的目录。其中package_path参数表示刷机包中的目录，destination_path参数表示目标目录。</li><li>用法：package_extract_dir(“system”, “/system”);</li></ul><p><strong><em>5. set_perm</em></strong></p><ul><li>原型：set_perm(uid, gid, mode, file1, file2, …, fileN);</li><li>功能：用于设置一个或多个文件的权限。其中uid参数表示用户ID，gid参数表示用户组ID。如果想让文件的用户和用户组都是Root，uid和gid需要为0。mode参数表示设置的权限。与chmod命令相似。</li><li>用法：set_perm(0, 0, 0777, “/system/xbin/su”);</li></ul><p><strong><em>6. mount</em></strong></p><ul><li>原型：mount(fs_type, partition_type, location, mount_point);</li><li>功能：挂载分区</li><li>用法：mount(“ext4”, “EMMC”, “/dev/block/platform/s3c-sdhci.0/by-name/system”, “/system”);</li></ul><p><strong><em>7. unmount</em></strong></p><ul><li>原型：unmount(mount_point);</li><li>功能：用于解除文件系统的挂载。其中mount_point参数表示文件系统。</li><li>用法：unmount(“/system”);</li></ul><h4 id="编写脚本文件"><a href="#编写脚本文件" class="headerlink" title="编写脚本文件"></a>编写脚本文件</h4><p>了解了基本的语法后，就可以来编写个简单的替换系统文件的脚本了，我们主要进行的操作如下</p><ul><li>以读写模式挂载/system</li><li>删除旧的su文件</li><li>复制新的su文件</li><li>修改su文件的权限</li><li>卸载/system</li></ul><p>根据以上步骤，这里直接给上脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ui_print(<span class="string">"----------------------"</span>);</span><br><span class="line">ui_print(<span class="string">"Recovery Upgrade Package"</span>);</span><br><span class="line">ui_print(<span class="string">"----------------------"</span>);</span><br><span class="line"></span><br><span class="line">ui_print(<span class="string">"--- Mounting /system ---"</span>);</span><br><span class="line"><span class="comment">#以读写模式挂载/system</span></span><br><span class="line">run_program(<span class="string">"/sbin/busybox"</span>, <span class="string">"mount"</span>, <span class="string">"-o"</span>, <span class="string">"rw"</span>, <span class="string">"/system"</span>);</span><br><span class="line"></span><br><span class="line">ui_print(--- Delete /system/xbin/su ---);</span><br><span class="line"><span class="comment">#删除旧的su文件</span></span><br><span class="line">delete(<span class="string">"/system/xbin/su"</span>);</span><br><span class="line"></span><br><span class="line">ui_pirnt(<span class="string">"--- Extracting system to /system ---"</span>);</span><br><span class="line"><span class="comment">#将刷机包中的system目录的所有文件复制到/system目录中的相应位置</span></span><br><span class="line">package_extract_dir(<span class="string">"system"</span>, <span class="string">"/system"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#给su命令添加可执行权限</span></span><br><span class="line">set_perm(0, 0, 0777, <span class="string">"/system/xbin/su"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载/system</span></span><br><span class="line">unmount(/system);</span><br><span class="line"></span><br><span class="line">ui_print(<span class="string">"--- finished ---"</span>);</span><br></pre></td></tr></table></figure><h3 id="升级包制作"><a href="#升级包制作" class="headerlink" title="升级包制作"></a>升级包制作</h3><p>制作Recovery升级包需要两个目录</p><ul><li>META-INF/com/google/android</li><li>system/xbin</li></ul><p>前者用来放我们制作的updater-script文件，在 <code>META-INF/com/google/android</code> 目录下还有一个 <code>update-binary</code> 的文件，它是用来解析我们制作的updater-script文件，把su放在 <code>system/xbin</code> 目录下。</p><blockquote><p>目录中的其他东西，可以找一个现成任意的Recovery升级包，把内容复制过来就行了</p></blockquote><p>最后，把这两个目录压缩成 <code>.zip</code> 文件， 升级包就制作完成了。</p><h1 id="替换su文件"><a href="#替换su文件" class="headerlink" title="替换su文件"></a>替换su文件</h1><p>有了升级包之后，我们要做的就是在Recovery里面安装这个升级包，通过adb shell进入recovery模式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure><p>在Recovery模式下，我们可以直接用 adb 操作这个升级包，比如先push到sdcard里面，然后在Recovery里面手动的选择在sdcard里面找到并安装这个升级包，另外我们也可以通过一个adb命令直接push并安装这个升级包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb sideload update.zip</span><br></pre></td></tr></table></figure><p>它会首先将updata.zip下载到手机中，并且执行安装，这里的updata.zip是升级包的路径，而非单单名字。</p><h2 id="使用su命令提取Root权限"><a href="#使用su命令提取Root权限" class="headerlink" title="使用su命令提取Root权限"></a>使用su命令提取Root权限</h2><p>su文件替换完之后，我们就可以通过各种方法获取到Root权限</p><h3 id="在终端中执行su命令提取Root权限"><a href="#在终端中执行su命令提取Root权限" class="headerlink" title="在终端中执行su命令提取Root权限"></a>在终端中执行su命令提取Root权限</h3><p>无论在pc上的adb shell命令还是手机的本地终端，正如我们开篇所说的，直接输入su，即可获取Root权限。</p><h3 id="在App中使用Root权限"><a href="#在App中使用Root权限" class="headerlink" title="在App中使用Root权限"></a>在App中使用Root权限</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().<span class="built_in">exec</span>(<span class="string">"su"</span>);</span><br><span class="line">OutputStream os = process.getOutputStream();</span><br><span class="line">os.write(<span class="string">"ls /system/app"</span>.getBytes());</span><br><span class="line">os.flush();</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure><p>这段代码还没有进行尝试，之后会写个删除系统自带软件的程序来验证下。</p><h2 id="su命令源代码解析"><a href="#su命令源代码解析" class="headerlink" title="su命令源代码解析"></a>su命令源代码解析</h2><p>Android源代码上su.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">** </span></span><br><span class="line"><span class="comment">** Copyright 2008, The Android Open Source Project </span></span><br><span class="line"><span class="comment">** </span></span><br><span class="line"><span class="comment">** Licensed under the Apache License, Version 2.0 (the "License");  </span></span><br><span class="line"><span class="comment">** you may not use this file except in compliance with the License.  </span></span><br><span class="line"><span class="comment">** You may obtain a copy of the License at  </span></span><br><span class="line"><span class="comment">** </span></span><br><span class="line"><span class="comment">**     http://www.apache.org/licenses/LICENSE-2.0  </span></span><br><span class="line"><span class="comment">** </span></span><br><span class="line"><span class="comment">** Unless required by applicable law or agreed to in writing, software  </span></span><br><span class="line"><span class="comment">** distributed under the License is distributed on an "AS IS" BASIS,  </span></span><br><span class="line"><span class="comment">** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  </span></span><br><span class="line"><span class="comment">** See the License for the specific language governing permissions and  </span></span><br><span class="line"><span class="comment">** limitations under the License. </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"su"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;private/android_filesystem_config.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * SU can be given a specific command to exec. UID _must_ be </span></span><br><span class="line"><span class="comment"> * specified for this (ie argc =&gt; 3). </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Usage: </span></span><br><span class="line"><span class="comment"> * su 1000 </span></span><br><span class="line"><span class="comment"> * su 1000 ls -l </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> uid, gid, myuid;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;  </span><br><span class="line">        uid = gid = <span class="number">0</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        pw = getpwnam(argv[<span class="number">1</span>]);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(pw == <span class="number">0</span>) &#123;  </span><br><span class="line">            uid = gid = atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            uid = pw-&gt;pw_uid;  </span><br><span class="line">            gid = pw-&gt;pw_gid;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Until we have something better, only root and the shell can use su. */</span>  </span><br><span class="line">    myuid = getuid();  </span><br><span class="line">    <span class="keyword">if</span> (myuid != AID_ROOT &amp;&amp; myuid != AID_SHELL) &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"su: uid %d not allowed to su\n"</span>, myuid);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(setgid(gid) || setuid(uid)) &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"su: permission denied\n"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* User specified command for exec. */</span>  </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span> ) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (execlp(argv[<span class="number">2</span>], argv[<span class="number">2</span>], <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"su: exec failed for %s Error:%s\n"</span>, argv[<span class="number">2</span>],  </span><br><span class="line">                    strerror(errno));  </span><br><span class="line">            <span class="keyword">return</span> -errno;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argc &gt; <span class="number">3</span>) &#123;  </span><br><span class="line">        <span class="comment">/* Copy the rest of the args from main. */</span>  </span><br><span class="line">        <span class="keyword">char</span> *exec_args[argc - <span class="number">1</span>];  </span><br><span class="line">        <span class="built_in">memset</span>(exec_args, <span class="number">0</span>, <span class="keyword">sizeof</span>(exec_args));  </span><br><span class="line">        <span class="built_in">memcpy</span>(exec_args, &amp;argv[<span class="number">2</span>], <span class="keyword">sizeof</span>(exec_args));  </span><br><span class="line">        <span class="keyword">if</span> (execvp(argv[<span class="number">2</span>], exec_args) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"su: exec failed for %s Error:%s\n"</span>, argv[<span class="number">2</span>],  </span><br><span class="line">                    strerror(errno));  </span><br><span class="line">            <span class="keyword">return</span> -errno;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Default exec shell. */</span>  </span><br><span class="line">    execlp(<span class="string">"/system/bin/sh"</span>, <span class="string">"sh"</span>, <span class="literal">NULL</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"su: exec failed\n"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从main函数的源代码中可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Until we have something better, only root and the shell can use su. */</span>  </span><br><span class="line">myuid = getuid();  </span><br><span class="line"><span class="keyword">if</span> (myuid != AID_ROOT &amp;&amp; myuid != AID_SHELL) &#123;  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"su: uid %d not allowed to su\n"</span>, myuid);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数可以看出，su文件检测当前用户如果不是Root用户或者Shell用户，将会直接退出su命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;  </span><br><span class="line">    uid = gid = <span class="number">0</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    pw = getpwnam(argv[<span class="number">1</span>]);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pw == <span class="number">0</span>) &#123;  </span><br><span class="line">        uid = gid = atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        uid = pw-&gt;pw_uid;  </span><br><span class="line">        gid = pw-&gt;pw_gid;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数小于2，uid（将要切换的用户id）和gid（将要切换的用户组id）都会切换到Root用户和Root用户组，C语言中如果一个命令不加任何参数，argc值就等于1，也就是说，如果你只输入了su命令，将自动切换到Root用户和Root用户组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(setgid(gid) || setuid(uid)) &#123;  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"su: permission denied\n"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setgid和setuid函数是最关键的获取Root权限的函数，如果设置成功则返回0，所以只有当两个函数返回都为0的时候，才算成功获取Root权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Default exec shell. */</span>  </span><br><span class="line">execlp(<span class="string">"/system/bin/sh"</span>, <span class="string">"sh"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>这段代码将当前进程替换成一个新进程，也就是以Root用户登录的一个新的Shell。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>有关Android设备提取Root权限最基本的原理就是这些了，但一般情况下往往没这么简单，我们也知道不同的机型Root的方式也不一样，因为厂商对待Root设备的态度不一样，有的坚决反对，有的不鼓励不支持，有的想方设法阻止你Root，或者只有Nexus系列的原生系统才会如此的简单吧，但万变不离其宗，原理上不会差太多，对以后的学习也是一个基础。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计没那么简单</title>
      <link href="/2016/03/11/design-logo/"/>
      <url>/2016/03/11/design-logo/</url>
      
        <content type="html"><![CDATA[<p>以前总觉得，设计就那么回事儿 ，又自信的认为我的审美没有顶尖也是一流了，所以我喜欢设计，但“喜欢”了这么久，从来没真正的入坑过，所以对设计的喜爱至少比不上编程。</p><p>最近初学Android想找个项目练手，自己准备做的项目当时还没构思完成，刚好学弟今年毕业，做的毕业设计简单来说是控制电机的，所以我就“毛遂自荐”的帮学弟做一个手机端的蓝牙控制&amp;反馈的App。</p><a id="more"></a><p>然后某天想到了设计图标，我觉得我不能过于纠结外在，而应该把重点放在软件的易用和稳定性上，所以一开始我打算随便做个草草了事儿了，比如这样：</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/ic_launcher1.png" alt></p><p>简单的直接一个M代表这是控制电机（Motor）的，但不知道怎么脑抽选了暗红的颜色，看着始终别扭，并且这怎么着也算我正式的第一个Android App，所以我打算以我“强大的审美”能力，来设计一个图标，又考虑到图标嘛要足够简单、抽象，所以设计了这样的：</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/ic_launcher2_1.png" alt></p><p>嗯，看着还不错，一个够抽象的电机，上面长了一根天线，然后有信号传出去，多简单吧，又加了光线的阴影啥的，虽然哪里还觉得不对但比第一个还好吧，好吧，吧</p><p>于是放在手机上看看</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/ic_launcher2_2.png" alt></p><p>(；°○° )<br>卧槽这是什么鬼！！<br>简直丑爆了好吗？<br>那个M都看不清了好吗？？</p><p>。_。</p><p>设计没有我想的那么简单，我觉得我图标上的信息已经够少了，但还是东西太多，还是不够简约，回想下，我那个绿色背景简直没起到任何作用，并且过于依赖用线条来表现事物。</p><p>简单</p><p>简单</p><p>简单</p><p>突然灵机一动，我又改成了这样</p><p><img src="http://7xq464.com1.z0.glb.clouddn.com/ic_launcher3.png" alt></p><p>哈哈哈哈哈哈，我好有才啊（啪啪啪）</p><p>看似和第一个图标很像，但实际上完全不同，这个是简约，那个叫简陋，一个M代表电机，一个信号的波纹，代表这个电机是可以通过无线控制的，简单明了</p><p>经过这次事情，明显的感觉到，审美和设计不是一回事儿，有审美并不代表一定能设计出来好东西，设计过这个图标后，我之后到酷市场下载东西，都会在意的看一下这个软件的图标是怎么设计的，感觉哪个都比我设计的好，各有千秋</p><p><strong><em>路漫漫其修远兮 吾将上下而求索</em></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次折腾刷机的经历</title>
      <link href="/2016/02/06/adb-shell/"/>
      <url>/2016/02/06/adb-shell/</url>
      
        <content type="html"><![CDATA[<p>这两天在折腾华为荣耀3C，型号是H30-T00/1G RAM，芯片是MediaTek6582，ROOT之后先是刷了个TWRP（Team Win Recovery Project）的recovery，之后又刷过CM12.1、MIUI7等第三方ROM，这些ROM大多基于华为官方的B268/Android4.4修改。<br>哦这里话说回来，手机是我爸的:P .于是在强权逼迫下，我不得不寻找把它刷回去的办法（非官方包在通话时均没有扬声器输入），官方的卡刷包各种不好找领导又催的紧，惹急了直接找了个据说是官方的线刷包，用MediaTek的Smart Phone Flash Tools直接把整个包刷进去，果不其然出问题了，各种系统刷之后都无法开机，卡在系统启动的动画里。<br>之后又找了个据说是官方的线刷包刷了进去，直接连recovery都被替换了，官方的各种救砖工具都能成功使用，却没有任何效果，真正的官方升级包无法输入，说是分区有问题。</p><a id="more"></a><h2 id="前言有点儿长，正篇开始。"><a href="#前言有点儿长，正篇开始。" class="headerlink" title="前言有点儿长，正篇开始。"></a>前言有点儿长，正篇开始。</h2><p>首先用SPflash工具把TWRP的Recovery又重新刷了进去，在里面擦除分区时发现，data分区和cust分区（华为自己的分区）都无法挂载，使用Recovery自己的工具把data分区重新格式化，正常挂载了，但是cust还是不行。</p><p>查看当前已有的分区</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~ # cat /proc/partitions </span><br><span class="line">major minor  #blocks  name</span><br><span class="line"></span><br><span class="line"> 179        0    3830784 mmcblk0</span><br><span class="line"> 179        1          1 mmcblk0p1</span><br><span class="line"> 179        2      10240 mmcblk0p2</span><br><span class="line"> 179        3      10240 mmcblk0p3</span><br><span class="line"> 179        4       6144 mmcblk0p4</span><br><span class="line"> 179        5    1048576 mmcblk0p5</span><br><span class="line"> 179        6     196608 mmcblk0p6</span><br><span class="line"> 179        7     129024 mmcblk0p7</span><br><span class="line"> 179        8    2375168 mmcblk0p8</span><br><span class="line"> 179       64       2048 mmcblk0boot1</span><br><span class="line"> 179       32       2048 mmcblk0boot0</span><br><span class="line"> 179       96    3872768 mmcblk1</span><br><span class="line"> 179       97    3870720 mmcblk1p1</span><br></pre></td></tr></table></figure><p>这里能看到，共有两个disk，分别是mmcblk0和mmcblk1，其中前者被分为10个小分区。后者就是SD card</p><p>查看系统挂载的分区</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~ # df -am</span><br><span class="line">Filesystem           1M-blocks      Used Available Use% Mounted on</span><br><span class="line">tmpfs                      483         0       483   0% /dev</span><br><span class="line">devpts                       0         0         0   0% /dev/pts</span><br><span class="line">proc                         0         0         0   0% /proc</span><br><span class="line">sysfs                        0         0         0   0% /sys</span><br><span class="line">/dev/block/mmcblk0p8      2287      1157      1130  51% /data</span><br><span class="line">/dev/block/mmcblk0p8      2287      1157      1130  51% /sdcard</span><br><span class="line">/dev/block/mmcblk0p7       124         4       120   3% /cache</span><br><span class="line">/dev/block/mmcblk1p1      3772      2751      1021  73% /external_sd</span><br></pre></td></tr></table></figure><p>上面能看到已经挂载分区的大小和对应的文件系统分区，但是华为的cust无法挂载，查看/etc/fstab文件系统分区表</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/dev/block/mmcblk0p5 /system ext4 rw</span><br><span class="line">/dev/block/mmcblk0p8 /data ext4 rw</span><br><span class="line">/dev/block/mmcblk0p6 /cust ext4 rw</span><br><span class="line">/dev/block/mmcblk0p7 /cache ext4 rw</span><br><span class="line">/dev/block/mmcblk1p1 /external_sd vfat rw</span><br></pre></td></tr></table></figure><p>手动挂载cust分区</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/block/mmcblk0p6 /cust</span><br><span class="line">或</span><br><span class="line">mount /cust</span><br></pre></td></tr></table></figure><p>提示无效参数，怀疑是mmcblk0p6分区损坏，于是把cache卸载，把cust挂载到mmcblk0p7上，果然成功挂载，于是执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make_ext4fs /dev/block/mmcblk0p6</span><br></pre></td></tr></table></figure><p>重新挂载/cust分区，果然成功挂载，至此Recovery已经没有任何报错，重新把/system、/data等等分区全部重新格式化，重新安装lollipop，然而结果没变，还是卡在开机画面。当时和某个QQ群里的“大神”交流了下，“大神”呵呵一笑：不用想了，字库坏了。（一般情况下，字库坏了=主板坏了，不能修）</p><p>说到字库这个词我也想呵呵，手机字库什么的就是Flash，叫的这么不近人情，然而我可以肯定的是，我的“字库肯定没坏啊”，因为我刚刚还在对它进行格式化的操作。</p><p>于是我用ADB进入手机的shell，用刚刚的格式化操作，对前面几个小分区全部格式化了一遍</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make_ext4fs /dev/block/mmcblk0p2</span><br><span class="line">make_ext4fs /dev/block/mmcblk0p3</span><br><span class="line">make_ext4fs /dev/block/mmcblk0p4</span><br></pre></td></tr></table></figure><p>重新开机，一切正常～～</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这次事情是在刷机的过程中，用一些简单的ADB Shell命令解决了手机系统无法开机的一些问题，Android                      Shell还有更多强大的功能还没用过，并且本文只是记载了自己遇到的问题，仅能做为参考，切勿照搬。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试ADB连接</title>
      <link href="/2016/02/06/adb-connect/"/>
      <url>/2016/02/06/adb-connect/</url>
      
        <content type="html"><![CDATA[<p>很早就会各种刷机，用各种工具，但始终没正式的接触过ADB（Android Debug Bridge），最近才熟悉了下它。首先是连接方式：USB和Wi-Fi</p><h3 id="USB连接"><a href="#USB连接" class="headerlink" title="USB连接"></a>USB连接</h3><p>首先是显示当前连接的设备</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>如果有设备通过USB成功连接，会显示如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">0123456789ABCDEFdevice</span><br></pre></td></tr></table></figure><p>左边的是设备的名字，右边的device代表设备的状态，目前见到过的状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">device            - 设备通过USB连接成功</span><br><span class="line">offline           - 设备的adb usb服务没有启动</span><br><span class="line">no permissions    - 需要通过root权限重启adb server</span><br><span class="line">unauthorized      - Android4.4之后，需要在设备上对计算机授权才可调试</span><br></pre></td></tr></table></figure><p>如果出现了上面的no permissions的状态，在teminal进入root用户，或者前面加sudo</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">kill</span>-server</span><br><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>其中，执行<code>adb devices</code>时，adb会首先默认执行<code>adb start-server</code>，之后可以<code>Ctrl+A+D</code>退出root用户，设备应该会是device状态。（调试OPPO U705T - Android4.1时遇到）</p><p>接下来，只要设备是device状态，就可以对它执行各种push、pull、install、shell的命令了。</p><h3 id="Wi-FI连接"><a href="#Wi-FI连接" class="headerlink" title="Wi-FI连接"></a>Wi-FI连接</h3><p>USB一直连着，当然可以保证手机电量是满的，但是如果像我这样笔记本拿来拿去，手机一直挂在上面挺不方便的，这时候就可以用到Wi-Fi连接了，在CM12.1上的开发者选项里直接有<strong>网络ADB调试</strong>的选项，在Android4.1上并没有。这时候就需要我们手动改变它的连接方式了。</p><p>用USB把手机连接到电脑，前提是保证它是device状态，执行<br><code>adb tcpip 5555</code><br>5555是默认端口，可以自己修改，前提是没被其他的进程监听占用。这个命令，嗯我失败了，最保险的办法是在手机上的本地终端，输入su获取root权限，然后执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop adbd</span><br><span class="line">setprop service.adb.tcp.port 5555</span><br><span class="line">start adbd</span><br></pre></td></tr></table></figure><p>然后就可以在电脑的teminal上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect &amp;lt;remotehost&amp;gt;</span><br></pre></td></tr></table></figure><p>其中<code>remotehost</code>是你手机在局域网中的ip地址，这里不需要特别标明端口，我这里是192.168.1.113，结果如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">liangzr@acer:~$ adb connect 192.168.1.113</span><br><span class="line">connected to 192.168.1.113:5555</span><br><span class="line">liangzr@acer:~$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">192.168.1.113:5555device</span><br><span class="line">0123456789ABCDEFdevice</span><br></pre></td></tr></table></figure><p>这个时候就可以断开USB来调试了，用Wi-Fi调试和用USB一样一样的，只是在下载速度上会有些慢。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实上面的好多操作，都可以直接在手机的本地终端里完成，并且个别问题的原因并不是很清楚，只是在Google上找到了答案，另外，附送一个国外大神的Script切换USB和Wi-Fi方式。</p><p><a href="https://gist.github.com/liangzr/3efa2aa4fec07fe60a83" target="_blank" rel="noopener">adbwifi.sh</a> - 脚本转自<a href="http://www.stormzhang.com/android/2014/08/27/adb-over-wifi/" target="_blank" rel="noopener">Android通过Wifi来调试你的应用 - stormzhang博客</a></p><p>adbwifi.sh内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Modify this with your IP range</span></span><br><span class="line">MY_IP_RANGE=<span class="string">"192\.168\.1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#You usually wouldn't have to modify this</span></span><br><span class="line">PORT_BASE=5555</span><br><span class="line"></span><br><span class="line"><span class="comment">#List the devices on the screen for your viewing pleasure</span></span><br><span class="line">adb devices</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Find USB devices only (no emulators, genymotion or connected devices</span></span><br><span class="line"><span class="built_in">declare</span> -a deviceArray=(`adb devices -l | grep -v emulator | grep -v vbox | grep -v <span class="string">"<span class="variable">$&#123;MY_IP_RANGE&#125;</span>"</span> | grep <span class="string">" device "</span> | awk <span class="string">'&#123;print $1&#125;'</span>`)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"found <span class="variable">$&#123;#deviceArray[@]&#125;</span> device(s)"</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="variable">$&#123;!deviceArray[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"finding IP address for device <span class="variable">$&#123;deviceArray[index]&#125;</span>"</span></span><br><span class="line">IP_ADDRESS=$(adb -s <span class="variable">$&#123;deviceArray[index]&#125;</span> shell ifconfig wlan0 | awk <span class="string">'&#123;print $3&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"IP address found : <span class="variable">$IP_ADDRESS</span> "</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Connecting..."</span></span><br><span class="line">adb -s <span class="variable">$&#123;deviceArray[index]&#125;</span> tcpip $((<span class="variable">$PORT_BASE</span> + <span class="variable">$index</span>))</span><br><span class="line">adb -s <span class="variable">$&#123;deviceArray[index]&#125;</span> connect <span class="string">"<span class="variable">$IP_ADDRESS</span>:<span class="variable">$(($PORT_BASE + $index)</span>)"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">adb devices -l</span><br><span class="line"><span class="comment">#exit&lt;/pre&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易shell script实现ssh登陆</title>
      <link href="/2016/01/07/easy-shell-script-ssh-login/"/>
      <url>/2016/01/07/easy-shell-script-ssh-login/</url>
      
        <content type="html"><![CDATA[<p>因为想每次管理服务器都要手动输入<code>ssh user@remotehost</code>然后输入密码才能进去，并且经常隔2-3分钟不去管它，控制台就无响应了，所以我就想写个脚本实现自动登陆和无响应重连。于是</p><ul><li>想写个脚本去</li><li>找到篇Advanced Bash-scripting Guide, 想创建一个Github repository来整理</li><li>在2048KB创建个page来收录Github repository, 嫌网站字体太难看要更改字体</li><li>在<code>.css</code>文件里更改font-family由于文件太多又去学了正则表达式</li><li>修改完后发现没效果, 更改<code>.css</code>的font-face实现修改<br>好，还是说正事儿。</li></ul><a id="more"></a><h2 id="Option-1-仅实现登陆"><a href="#Option-1-仅实现登陆" class="headerlink" title="Option 1: 仅实现登陆"></a>Option 1: 仅实现登陆</h2><hr><p>最简单的实现手动的登陆，可以用expect工具来实现，在Ubuntu下需要下载：<br><code>sudo apt-get install expect</code><br>Expect中最关键的四个命令是：</p><ul><li>send：用于向进程发送字符串</li><li>xpect：从进程接收字符串</li><li>spawn：启动新的进程</li><li>interact：允许用户交互</li></ul><p>实现如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line">spawn ssh user@remotehost</span><br><span class="line">expect <span class="string">"*password:"</span></span><br><span class="line">send <span class="string">"userpwd\r"</span></span><br><span class="line">expect <span class="string">"*#"</span></span><br><span class="line">interact</span><br></pre></td></tr></table></figure><p>添加执行权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x ssh-script.sh</span><br></pre></td></tr></table></figure><p>运行以上ssh-script.sh就可以登陆了，也可以把用户命令放入<code>～/bin</code>，在Linux的很多发行版本中默认PATH都加入了这个目录，在Ubuntu上只要在用户根目录下建立了bin文件夹，下次登陆时会自动添加进PATH，如果要手动修改则打开.bashrc文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi ~/.bashrc</span><br></pre></td></tr></table></figure><p>文件末添加</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH = ~/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>生效改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>这样在teminal里输入ssh-script.sh就能一键登陆VPS了，如果嫌后缀麻烦，可以……删掉好了：P</p><p>未完</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/1970/01/01/hello-world/"/>
      <url>/1970/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
